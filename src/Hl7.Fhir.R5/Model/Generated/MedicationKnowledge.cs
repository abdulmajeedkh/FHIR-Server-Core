// <auto-generated/>
// Contents of: hl7.fhir.r5.expansions@5.0.0, hl7.fhir.r5.core@5.0.0

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using Hl7.Fhir.Introspection;
using Hl7.Fhir.Serialization;
using Hl7.Fhir.Specification;
using Hl7.Fhir.Utility;
using Hl7.Fhir.Validation;
using System.Diagnostics.CodeAnalysis;
using SystemPrimitive = Hl7.Fhir.ElementModel.Types;

#nullable enable

/*
  Copyright (c) 2011+, HL7, Inc.
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
*/

namespace Hl7.Fhir.Model
{
  /// <summary>
  /// Definition of Medication Knowledge
  /// </summary>
  /// <remarks>
  /// Information about a medication that is used to support knowledge.
  /// </remarks>
  [Serializable]
  [DataContract]
  [FhirType("MedicationKnowledge","http://hl7.org/fhir/StructureDefinition/MedicationKnowledge")]
  public partial class MedicationKnowledge : Hl7.Fhir.Model.DomainResource, IIdentifiable<List<Identifier>>
  {
    /// <summary>
    /// FHIR Type Name
    /// </summary>
    public override string TypeName => "MedicationKnowledge";

    /// <summary>
    /// MedicationKnowledge Status Codes
    /// (url: http://hl7.org/fhir/ValueSet/medicationknowledge-status)
    /// (system: http://hl7.org/fhir/CodeSystem/medicationknowledge-status)
    /// </summary>
    [FhirEnumeration("MedicationKnowledgeStatusCodes", "http://hl7.org/fhir/ValueSet/medicationknowledge-status", "http://hl7.org/fhir/CodeSystem/medicationknowledge-status")]
    public enum MedicationKnowledgeStatusCodes
    {
      /// <summary>
      /// The medication referred to by this MedicationKnowledge is in active use within the drug database or inventory system.
      /// (system: http://hl7.org/fhir/CodeSystem/medicationknowledge-status)
      /// </summary>
      [EnumLiteral("active"), Description("Active")]
      Active,
      /// <summary>
      /// The medication referred to by this MedicationKnowledge was entered in error within the drug database or inventory system.
      /// (system: http://hl7.org/fhir/CodeSystem/medicationknowledge-status)
      /// </summary>
      [EnumLiteral("entered-in-error"), Description("Entered in Error")]
      EnteredInError,
      /// <summary>
      /// The medication referred to by this MedicationKnowledge is not in active use within the drug database or inventory system.
      /// (system: http://hl7.org/fhir/CodeSystem/medicationknowledge-status)
      /// </summary>
      [EnumLiteral("inactive"), Description("Inactive")]
      Inactive,
    }

    /// <summary>
    /// Associated or related medication information
    /// </summary>
    /// <remarks>
    /// Associated or related medications. For example, if the medication is a branded product (e.g. Crestor), this is the Therapeutic Moeity (e.g. Rosuvastatin) or if this is a generic medication (e.g. Rosuvastatin), this would link to a branded product (e.g. Crestor.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("MedicationKnowledge.relatedMedicationKnowledge", IsBackboneType=true)]
    public partial class RelatedMedicationKnowledgeComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "MedicationKnowledge.relatedMedicationKnowledge";

      /// <summary>
      /// Category of medicationKnowledge.
      /// </summary>
      [FhirElement("type", Order=40)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Type
      {
        get
        {
          if(_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.CodeableConcept), Overflow["type"]);
          return _Type!;
        }

        set
        {
          if (_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            Overflow.Remove("type");
          _Type = value;
          OnPropertyChanged("Type");
        }

      }

      private Hl7.Fhir.Model.CodeableConcept? _Type;

      /// <summary>
      /// Associated documentation about the associated medication knowledge.
      /// </summary>
      [FhirElement("reference", Order=50)]
      [CLSCompliant(false)]
      [References("MedicationKnowledge")]
      [Cardinality(Min=1,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.ResourceReference> Reference
      {
        get
        {
          if(_Reference.InOverflow<List<Hl7.Fhir.Model.ResourceReference>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.ResourceReference>), Overflow["reference"]);
          return _Reference ??= [];
        }

        set
        {
          if (_Reference.InOverflow<List<Hl7.Fhir.Model.ResourceReference>>())
            Overflow.Remove("reference");
          _Reference = value;
          OnPropertyChanged("Reference");
        }

      }

      private List<Hl7.Fhir.Model.ResourceReference>? _Reference;

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not RelatedMedicationKnowledgeComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_Type is not null) dest.Type = (Hl7.Fhir.Model.CodeableConcept)_Type.DeepCopyInternal();
        if(_Reference is not null) dest.Reference = new List<Hl7.Fhir.Model.ResourceReference>(_Reference.DeepCopyInternal());
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new RelatedMedicationKnowledgeComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not RelatedMedicationKnowledgeComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_Type, otherT._Type)) return false;
        if(!comparer.ListEquals(_Reference, otherT._Reference)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "type":
            if (_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            {
              value = Overflow["type"];
              return true;
            }
            value = _Type;
            return (value as Hl7.Fhir.Model.CodeableConcept) is not null;
          case "reference":
            if (_Reference.InOverflow<List<Hl7.Fhir.Model.ResourceReference>>())
            {
              value = Overflow["reference"];
              return true;
            }
            value = _Reference;
            return (value as List<Hl7.Fhir.Model.ResourceReference>)?.Any() is true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "type":
            if (value is not (Hl7.Fhir.Model.CodeableConcept or null))
            {
              Type = OverflowNull<Hl7.Fhir.Model.CodeableConcept>.INSTANCE;
              Overflow["type"] = value;
            }
            else Type = (Hl7.Fhir.Model.CodeableConcept?)value!;
            return this;
          case "reference":
            if (value is not (List<Hl7.Fhir.Model.ResourceReference> or null))
            {
              Reference = OverflowNull<List<Hl7.Fhir.Model.ResourceReference>>.INSTANCE;
              Overflow["reference"] = value;
            }
            else Reference = (List<Hl7.Fhir.Model.ResourceReference>?)value!;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_Type is not null && !_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>()) yield return new KeyValuePair<string,object>("type",_Type);
        if (_Reference?.Any() is true && !_Reference.InOverflow<List<Hl7.Fhir.Model.ResourceReference>>()) yield return new KeyValuePair<string,object>("reference",_Reference);
      }

    }

    /// <summary>
    /// Associated documentation about the medication
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("MedicationKnowledge.monograph", IsBackboneType=true)]
    public partial class MonographComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "MedicationKnowledge.monograph";

      /// <summary>
      /// The category of medication document.
      /// </summary>
      [FhirElement("type", Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept? Type
      {
        get
        {
          if(_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.CodeableConcept), Overflow["type"]);
          return _Type;
        }

        set
        {
          if (_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            Overflow.Remove("type");
          _Type = value;
          OnPropertyChanged("Type");
        }

      }

      private Hl7.Fhir.Model.CodeableConcept? _Type;

      /// <summary>
      /// Associated documentation about the medication.
      /// </summary>
      [FhirElement("source", Order=50)]
      [CLSCompliant(false)]
      [References("DocumentReference")]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference? Source
      {
        get
        {
          if(_Source.InOverflow<Hl7.Fhir.Model.ResourceReference>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.ResourceReference), Overflow["source"]);
          return _Source;
        }

        set
        {
          if (_Source.InOverflow<Hl7.Fhir.Model.ResourceReference>())
            Overflow.Remove("source");
          _Source = value;
          OnPropertyChanged("Source");
        }

      }

      private Hl7.Fhir.Model.ResourceReference? _Source;

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not MonographComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_Type is not null) dest.Type = (Hl7.Fhir.Model.CodeableConcept)_Type.DeepCopyInternal();
        if(_Source is not null) dest.Source = (Hl7.Fhir.Model.ResourceReference)_Source.DeepCopyInternal();
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new MonographComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not MonographComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_Type, otherT._Type)) return false;
        if(!comparer.Equals(_Source, otherT._Source)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "type":
            if (_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            {
              value = Overflow["type"];
              return true;
            }
            value = _Type;
            return (value as Hl7.Fhir.Model.CodeableConcept) is not null;
          case "source":
            if (_Source.InOverflow<Hl7.Fhir.Model.ResourceReference>())
            {
              value = Overflow["source"];
              return true;
            }
            value = _Source;
            return (value as Hl7.Fhir.Model.ResourceReference) is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "type":
            if (value is not (Hl7.Fhir.Model.CodeableConcept or null))
            {
              Type = OverflowNull<Hl7.Fhir.Model.CodeableConcept>.INSTANCE;
              Overflow["type"] = value;
            }
            else Type = (Hl7.Fhir.Model.CodeableConcept?)value;
            return this;
          case "source":
            if (value is not (Hl7.Fhir.Model.ResourceReference or null))
            {
              Source = OverflowNull<Hl7.Fhir.Model.ResourceReference>.INSTANCE;
              Overflow["source"] = value;
            }
            else Source = (Hl7.Fhir.Model.ResourceReference?)value;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_Type is not null && !_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>()) yield return new KeyValuePair<string,object>("type",_Type);
        if (_Source is not null && !_Source.InOverflow<Hl7.Fhir.Model.ResourceReference>()) yield return new KeyValuePair<string,object>("source",_Source);
      }

    }

    /// <summary>
    /// The pricing of the medication
    /// </summary>
    /// <remarks>
    /// The price of the medication.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("MedicationKnowledge.cost", IsBackboneType=true)]
    public partial class CostComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "MedicationKnowledge.cost";

      /// <summary>
      /// The date range for which the cost is effective.
      /// </summary>
      [FhirElement("effectiveDate", Order=40)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.Period> EffectiveDate
      {
        get
        {
          if(_EffectiveDate.InOverflow<List<Hl7.Fhir.Model.Period>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.Period>), Overflow["effectiveDate"]);
          return _EffectiveDate ??= [];
        }

        set
        {
          if (_EffectiveDate.InOverflow<List<Hl7.Fhir.Model.Period>>())
            Overflow.Remove("effectiveDate");
          _EffectiveDate = value;
          OnPropertyChanged("EffectiveDate");
        }

      }

      private List<Hl7.Fhir.Model.Period>? _EffectiveDate;

      /// <summary>
      /// The category of the cost information.
      /// </summary>
      [FhirElement("type", Order=50)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Type
      {
        get
        {
          if(_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.CodeableConcept), Overflow["type"]);
          return _Type!;
        }

        set
        {
          if (_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            Overflow.Remove("type");
          _Type = value;
          OnPropertyChanged("Type");
        }

      }

      private Hl7.Fhir.Model.CodeableConcept? _Type;

      /// <summary>
      /// The source or owner for the price information.
      /// </summary>
      [FhirElement("source", Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString? SourceElement
      {
        get
        {
          if(_SourceElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirString), Overflow["source"]);
          return _SourceElement;
        }

        set
        {
          if (_SourceElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            Overflow.Remove("source");
          _SourceElement = value;
          OnPropertyChanged("SourceElement");
        }

      }

      private Hl7.Fhir.Model.FhirString? _SourceElement;

      /// <summary>
      /// The source or owner for the price information
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? Source
      {
        get => SourceElement?.Value;
        set
        {
          SourceElement = value is null ? null! : new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Source");
        }
      }

      /// <summary>
      /// The price or category of the cost of the medication.
      /// </summary>
      [FhirElement("cost", Order=70, Choice=ChoiceType.DatatypeChoice)]
      [Binding("MedicationCostCategory")]
      [CLSCompliant(false)]
      [AllowedTypes(typeof(Hl7.Fhir.Model.Money),typeof(Hl7.Fhir.Model.CodeableConcept))]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.DataType Cost
      {
        get
        {
          if(_Cost.InOverflow<DynamicDataType>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.DataType), Overflow["cost"]);
          return _Cost!;
        }

        set
        {
          if (_Cost.InOverflow<DynamicDataType>())
            Overflow.Remove("cost");
          _Cost = value;
          OnPropertyChanged("Cost");
        }

      }

      private Hl7.Fhir.Model.DataType? _Cost;

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not CostComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_EffectiveDate is not null) dest.EffectiveDate = new List<Hl7.Fhir.Model.Period>(_EffectiveDate.DeepCopyInternal());
        if(_Type is not null) dest.Type = (Hl7.Fhir.Model.CodeableConcept)_Type.DeepCopyInternal();
        if(_SourceElement is not null) dest.SourceElement = (Hl7.Fhir.Model.FhirString)_SourceElement.DeepCopyInternal();
        if(_Cost is not null) dest.Cost = (Hl7.Fhir.Model.DataType)_Cost.DeepCopyInternal();
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new CostComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not CostComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.ListEquals(_EffectiveDate, otherT._EffectiveDate)) return false;
        if(!comparer.Equals(_Type, otherT._Type)) return false;
        if(!comparer.Equals(_SourceElement, otherT._SourceElement)) return false;
        if(!comparer.Equals(_Cost, otherT._Cost)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "effectiveDate":
            if (_EffectiveDate.InOverflow<List<Hl7.Fhir.Model.Period>>())
            {
              value = Overflow["effectiveDate"];
              return true;
            }
            value = _EffectiveDate;
            return (value as List<Hl7.Fhir.Model.Period>)?.Any() is true;
          case "type":
            if (_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            {
              value = Overflow["type"];
              return true;
            }
            value = _Type;
            return (value as Hl7.Fhir.Model.CodeableConcept) is not null;
          case "source":
            if (_SourceElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            {
              value = Overflow["source"];
              return true;
            }
            value = _SourceElement;
            return (value as Hl7.Fhir.Model.FhirString) is not null;
          case "cost":
            if (_Cost.InOverflow<DynamicDataType>())
            {
              value = Overflow["cost"];
              return true;
            }
            value = _Cost;
            return (value as Hl7.Fhir.Model.DataType) is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "effectiveDate":
            if (value is not (List<Hl7.Fhir.Model.Period> or null))
            {
              EffectiveDate = OverflowNull<List<Hl7.Fhir.Model.Period>>.INSTANCE;
              Overflow["effectiveDate"] = value;
            }
            else EffectiveDate = (List<Hl7.Fhir.Model.Period>?)value!;
            return this;
          case "type":
            if (value is not (Hl7.Fhir.Model.CodeableConcept or null))
            {
              Type = OverflowNull<Hl7.Fhir.Model.CodeableConcept>.INSTANCE;
              Overflow["type"] = value;
            }
            else Type = (Hl7.Fhir.Model.CodeableConcept?)value!;
            return this;
          case "source":
            if (value is not (Hl7.Fhir.Model.FhirString or null))
            {
              SourceElement = OverflowNull<Hl7.Fhir.Model.FhirString>.INSTANCE;
              Overflow["source"] = value;
            }
            else SourceElement = (Hl7.Fhir.Model.FhirString?)value;
            return this;
          case "cost":
            if (value is not (Hl7.Fhir.Model.DataType or null))
            {
              Cost = OverflowNull<DynamicDataType>.INSTANCE;
              Overflow["cost"] = value;
            }
            else Cost = (Hl7.Fhir.Model.DataType?)value!;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_EffectiveDate?.Any() is true && !_EffectiveDate.InOverflow<List<Hl7.Fhir.Model.Period>>()) yield return new KeyValuePair<string,object>("effectiveDate",_EffectiveDate);
        if (_Type is not null && !_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>()) yield return new KeyValuePair<string,object>("type",_Type);
        if (_SourceElement is not null && !_SourceElement.InOverflow<Hl7.Fhir.Model.FhirString>()) yield return new KeyValuePair<string,object>("source",_SourceElement);
        if (_Cost is not null && !_Cost.InOverflow<DynamicDataType>()) yield return new KeyValuePair<string,object>("cost",_Cost);
      }

    }

    /// <summary>
    /// Program under which a medication is reviewed
    /// </summary>
    /// <remarks>
    /// The program under which the medication is reviewed.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("MedicationKnowledge.monitoringProgram", IsBackboneType=true)]
    public partial class MonitoringProgramComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "MedicationKnowledge.monitoringProgram";

      /// <summary>
      /// Type of program under which the medication is monitored.
      /// </summary>
      [FhirElement("type", Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept? Type
      {
        get
        {
          if(_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.CodeableConcept), Overflow["type"]);
          return _Type;
        }

        set
        {
          if (_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            Overflow.Remove("type");
          _Type = value;
          OnPropertyChanged("Type");
        }

      }

      private Hl7.Fhir.Model.CodeableConcept? _Type;

      /// <summary>
      /// Name of the reviewing program.
      /// </summary>
      [FhirElement("name", Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString? NameElement
      {
        get
        {
          if(_NameElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirString), Overflow["name"]);
          return _NameElement;
        }

        set
        {
          if (_NameElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            Overflow.Remove("name");
          _NameElement = value;
          OnPropertyChanged("NameElement");
        }

      }

      private Hl7.Fhir.Model.FhirString? _NameElement;

      /// <summary>
      /// Name of the reviewing program
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? Name
      {
        get => NameElement?.Value;
        set
        {
          NameElement = value is null ? null! : new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Name");
        }
      }

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not MonitoringProgramComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_Type is not null) dest.Type = (Hl7.Fhir.Model.CodeableConcept)_Type.DeepCopyInternal();
        if(_NameElement is not null) dest.NameElement = (Hl7.Fhir.Model.FhirString)_NameElement.DeepCopyInternal();
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new MonitoringProgramComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not MonitoringProgramComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_Type, otherT._Type)) return false;
        if(!comparer.Equals(_NameElement, otherT._NameElement)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "type":
            if (_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            {
              value = Overflow["type"];
              return true;
            }
            value = _Type;
            return (value as Hl7.Fhir.Model.CodeableConcept) is not null;
          case "name":
            if (_NameElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            {
              value = Overflow["name"];
              return true;
            }
            value = _NameElement;
            return (value as Hl7.Fhir.Model.FhirString) is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "type":
            if (value is not (Hl7.Fhir.Model.CodeableConcept or null))
            {
              Type = OverflowNull<Hl7.Fhir.Model.CodeableConcept>.INSTANCE;
              Overflow["type"] = value;
            }
            else Type = (Hl7.Fhir.Model.CodeableConcept?)value;
            return this;
          case "name":
            if (value is not (Hl7.Fhir.Model.FhirString or null))
            {
              NameElement = OverflowNull<Hl7.Fhir.Model.FhirString>.INSTANCE;
              Overflow["name"] = value;
            }
            else NameElement = (Hl7.Fhir.Model.FhirString?)value;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_Type is not null && !_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>()) yield return new KeyValuePair<string,object>("type",_Type);
        if (_NameElement is not null && !_NameElement.InOverflow<Hl7.Fhir.Model.FhirString>()) yield return new KeyValuePair<string,object>("name",_NameElement);
      }

    }

    /// <summary>
    /// Guidelines or protocols for administration of the medication for an indication
    /// </summary>
    /// <remarks>
    /// Guidelines or protocols that are applicable for the administration of the medication based on indication.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("MedicationKnowledge.indicationGuideline", IsBackboneType=true)]
    public partial class IndicationGuidelineComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "MedicationKnowledge.indicationGuideline";

      /// <summary>
      /// Indication for use that applies to the specific administration guideline.
      /// </summary>
      [FhirElement("indication", Order=40)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.CodeableReference> Indication
      {
        get
        {
          if(_Indication.InOverflow<List<Hl7.Fhir.Model.CodeableReference>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.CodeableReference>), Overflow["indication"]);
          return _Indication ??= [];
        }

        set
        {
          if (_Indication.InOverflow<List<Hl7.Fhir.Model.CodeableReference>>())
            Overflow.Remove("indication");
          _Indication = value;
          OnPropertyChanged("Indication");
        }

      }

      private List<Hl7.Fhir.Model.CodeableReference>? _Indication;

      /// <summary>
      /// Guidelines for dosage of the medication.
      /// </summary>
      [FhirElement("dosingGuideline", Order=50)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.MedicationKnowledge.DosingGuidelineComponent> DosingGuideline
      {
        get
        {
          if(_DosingGuideline.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.DosingGuidelineComponent>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.MedicationKnowledge.DosingGuidelineComponent>), Overflow["dosingGuideline"]);
          return _DosingGuideline ??= [];
        }

        set
        {
          if (_DosingGuideline.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.DosingGuidelineComponent>>())
            Overflow.Remove("dosingGuideline");
          _DosingGuideline = value;
          OnPropertyChanged("DosingGuideline");
        }

      }

      private List<Hl7.Fhir.Model.MedicationKnowledge.DosingGuidelineComponent>? _DosingGuideline;

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not IndicationGuidelineComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_Indication is not null) dest.Indication = new List<Hl7.Fhir.Model.CodeableReference>(_Indication.DeepCopyInternal());
        if(_DosingGuideline is not null) dest.DosingGuideline = new List<Hl7.Fhir.Model.MedicationKnowledge.DosingGuidelineComponent>(_DosingGuideline.DeepCopyInternal());
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new IndicationGuidelineComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not IndicationGuidelineComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.ListEquals(_Indication, otherT._Indication)) return false;
        if(!comparer.ListEquals(_DosingGuideline, otherT._DosingGuideline)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "indication":
            if (_Indication.InOverflow<List<Hl7.Fhir.Model.CodeableReference>>())
            {
              value = Overflow["indication"];
              return true;
            }
            value = _Indication;
            return (value as List<Hl7.Fhir.Model.CodeableReference>)?.Any() is true;
          case "dosingGuideline":
            if (_DosingGuideline.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.DosingGuidelineComponent>>())
            {
              value = Overflow["dosingGuideline"];
              return true;
            }
            value = _DosingGuideline;
            return (value as List<Hl7.Fhir.Model.MedicationKnowledge.DosingGuidelineComponent>)?.Any() is true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "indication":
            if (value is not (List<Hl7.Fhir.Model.CodeableReference> or null))
            {
              Indication = OverflowNull<List<Hl7.Fhir.Model.CodeableReference>>.INSTANCE;
              Overflow["indication"] = value;
            }
            else Indication = (List<Hl7.Fhir.Model.CodeableReference>?)value!;
            return this;
          case "dosingGuideline":
            if (value is not (List<Hl7.Fhir.Model.MedicationKnowledge.DosingGuidelineComponent> or null))
            {
              DosingGuideline = OverflowNull<List<Hl7.Fhir.Model.MedicationKnowledge.DosingGuidelineComponent>>.INSTANCE;
              Overflow["dosingGuideline"] = value;
            }
            else DosingGuideline = (List<Hl7.Fhir.Model.MedicationKnowledge.DosingGuidelineComponent>?)value!;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_Indication?.Any() is true && !_Indication.InOverflow<List<Hl7.Fhir.Model.CodeableReference>>()) yield return new KeyValuePair<string,object>("indication",_Indication);
        if (_DosingGuideline?.Any() is true && !_DosingGuideline.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.DosingGuidelineComponent>>()) yield return new KeyValuePair<string,object>("dosingGuideline",_DosingGuideline);
      }

    }

    /// <summary>
    /// Guidelines for dosage of the medication
    /// </summary>
    /// <remarks>
    /// The guidelines for the dosage of the medication for the indication.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("MedicationKnowledge.indicationGuideline.dosingGuideline", IsBackboneType=true)]
    public partial class DosingGuidelineComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "MedicationKnowledge.indicationGuideline.dosingGuideline";

      /// <summary>
      /// Intention of the treatment.
      /// </summary>
      [FhirElement("treatmentIntent", Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept? TreatmentIntent
      {
        get
        {
          if(_TreatmentIntent.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.CodeableConcept), Overflow["treatmentIntent"]);
          return _TreatmentIntent;
        }

        set
        {
          if (_TreatmentIntent.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            Overflow.Remove("treatmentIntent");
          _TreatmentIntent = value;
          OnPropertyChanged("TreatmentIntent");
        }

      }

      private Hl7.Fhir.Model.CodeableConcept? _TreatmentIntent;

      /// <summary>
      /// Dosage for the medication for the specific guidelines.
      /// </summary>
      [FhirElement("dosage", Order=50)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.MedicationKnowledge.DosageComponent> Dosage
      {
        get
        {
          if(_Dosage.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.DosageComponent>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.MedicationKnowledge.DosageComponent>), Overflow["dosage"]);
          return _Dosage ??= [];
        }

        set
        {
          if (_Dosage.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.DosageComponent>>())
            Overflow.Remove("dosage");
          _Dosage = value;
          OnPropertyChanged("Dosage");
        }

      }

      private List<Hl7.Fhir.Model.MedicationKnowledge.DosageComponent>? _Dosage;

      /// <summary>
      /// Type of treatment the guideline applies to.
      /// </summary>
      [FhirElement("administrationTreatment", Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept? AdministrationTreatment
      {
        get
        {
          if(_AdministrationTreatment.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.CodeableConcept), Overflow["administrationTreatment"]);
          return _AdministrationTreatment;
        }

        set
        {
          if (_AdministrationTreatment.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            Overflow.Remove("administrationTreatment");
          _AdministrationTreatment = value;
          OnPropertyChanged("AdministrationTreatment");
        }

      }

      private Hl7.Fhir.Model.CodeableConcept? _AdministrationTreatment;

      /// <summary>
      /// Characteristics of the patient that are relevant to the administration guidelines.
      /// </summary>
      [FhirElement("patientCharacteristic", Order=70)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.MedicationKnowledge.PatientCharacteristicComponent> PatientCharacteristic
      {
        get
        {
          if(_PatientCharacteristic.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.PatientCharacteristicComponent>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.MedicationKnowledge.PatientCharacteristicComponent>), Overflow["patientCharacteristic"]);
          return _PatientCharacteristic ??= [];
        }

        set
        {
          if (_PatientCharacteristic.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.PatientCharacteristicComponent>>())
            Overflow.Remove("patientCharacteristic");
          _PatientCharacteristic = value;
          OnPropertyChanged("PatientCharacteristic");
        }

      }

      private List<Hl7.Fhir.Model.MedicationKnowledge.PatientCharacteristicComponent>? _PatientCharacteristic;

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not DosingGuidelineComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_TreatmentIntent is not null) dest.TreatmentIntent = (Hl7.Fhir.Model.CodeableConcept)_TreatmentIntent.DeepCopyInternal();
        if(_Dosage is not null) dest.Dosage = new List<Hl7.Fhir.Model.MedicationKnowledge.DosageComponent>(_Dosage.DeepCopyInternal());
        if(_AdministrationTreatment is not null) dest.AdministrationTreatment = (Hl7.Fhir.Model.CodeableConcept)_AdministrationTreatment.DeepCopyInternal();
        if(_PatientCharacteristic is not null) dest.PatientCharacteristic = new List<Hl7.Fhir.Model.MedicationKnowledge.PatientCharacteristicComponent>(_PatientCharacteristic.DeepCopyInternal());
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new DosingGuidelineComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not DosingGuidelineComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_TreatmentIntent, otherT._TreatmentIntent)) return false;
        if(!comparer.ListEquals(_Dosage, otherT._Dosage)) return false;
        if(!comparer.Equals(_AdministrationTreatment, otherT._AdministrationTreatment)) return false;
        if(!comparer.ListEquals(_PatientCharacteristic, otherT._PatientCharacteristic)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "treatmentIntent":
            if (_TreatmentIntent.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            {
              value = Overflow["treatmentIntent"];
              return true;
            }
            value = _TreatmentIntent;
            return (value as Hl7.Fhir.Model.CodeableConcept) is not null;
          case "dosage":
            if (_Dosage.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.DosageComponent>>())
            {
              value = Overflow["dosage"];
              return true;
            }
            value = _Dosage;
            return (value as List<Hl7.Fhir.Model.MedicationKnowledge.DosageComponent>)?.Any() is true;
          case "administrationTreatment":
            if (_AdministrationTreatment.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            {
              value = Overflow["administrationTreatment"];
              return true;
            }
            value = _AdministrationTreatment;
            return (value as Hl7.Fhir.Model.CodeableConcept) is not null;
          case "patientCharacteristic":
            if (_PatientCharacteristic.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.PatientCharacteristicComponent>>())
            {
              value = Overflow["patientCharacteristic"];
              return true;
            }
            value = _PatientCharacteristic;
            return (value as List<Hl7.Fhir.Model.MedicationKnowledge.PatientCharacteristicComponent>)?.Any() is true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "treatmentIntent":
            if (value is not (Hl7.Fhir.Model.CodeableConcept or null))
            {
              TreatmentIntent = OverflowNull<Hl7.Fhir.Model.CodeableConcept>.INSTANCE;
              Overflow["treatmentIntent"] = value;
            }
            else TreatmentIntent = (Hl7.Fhir.Model.CodeableConcept?)value;
            return this;
          case "dosage":
            if (value is not (List<Hl7.Fhir.Model.MedicationKnowledge.DosageComponent> or null))
            {
              Dosage = OverflowNull<List<Hl7.Fhir.Model.MedicationKnowledge.DosageComponent>>.INSTANCE;
              Overflow["dosage"] = value;
            }
            else Dosage = (List<Hl7.Fhir.Model.MedicationKnowledge.DosageComponent>?)value!;
            return this;
          case "administrationTreatment":
            if (value is not (Hl7.Fhir.Model.CodeableConcept or null))
            {
              AdministrationTreatment = OverflowNull<Hl7.Fhir.Model.CodeableConcept>.INSTANCE;
              Overflow["administrationTreatment"] = value;
            }
            else AdministrationTreatment = (Hl7.Fhir.Model.CodeableConcept?)value;
            return this;
          case "patientCharacteristic":
            if (value is not (List<Hl7.Fhir.Model.MedicationKnowledge.PatientCharacteristicComponent> or null))
            {
              PatientCharacteristic = OverflowNull<List<Hl7.Fhir.Model.MedicationKnowledge.PatientCharacteristicComponent>>.INSTANCE;
              Overflow["patientCharacteristic"] = value;
            }
            else PatientCharacteristic = (List<Hl7.Fhir.Model.MedicationKnowledge.PatientCharacteristicComponent>?)value!;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_TreatmentIntent is not null && !_TreatmentIntent.InOverflow<Hl7.Fhir.Model.CodeableConcept>()) yield return new KeyValuePair<string,object>("treatmentIntent",_TreatmentIntent);
        if (_Dosage?.Any() is true && !_Dosage.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.DosageComponent>>()) yield return new KeyValuePair<string,object>("dosage",_Dosage);
        if (_AdministrationTreatment is not null && !_AdministrationTreatment.InOverflow<Hl7.Fhir.Model.CodeableConcept>()) yield return new KeyValuePair<string,object>("administrationTreatment",_AdministrationTreatment);
        if (_PatientCharacteristic?.Any() is true && !_PatientCharacteristic.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.PatientCharacteristicComponent>>()) yield return new KeyValuePair<string,object>("patientCharacteristic",_PatientCharacteristic);
      }

    }

    /// <summary>
    /// Dosage for the medication for the specific guidelines
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("MedicationKnowledge.indicationGuideline.dosingGuideline.dosage", IsBackboneType=true)]
    public partial class DosageComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "MedicationKnowledge.indicationGuideline.dosingGuideline.dosage";

      /// <summary>
      /// Category of dosage for a medication.
      /// </summary>
      [FhirElement("type", Order=40)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Type
      {
        get
        {
          if(_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.CodeableConcept), Overflow["type"]);
          return _Type!;
        }

        set
        {
          if (_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            Overflow.Remove("type");
          _Type = value;
          OnPropertyChanged("Type");
        }

      }

      private Hl7.Fhir.Model.CodeableConcept? _Type;

      /// <summary>
      /// Dosage for the medication for the specific guidelines.
      /// </summary>
      [FhirElement("dosage", Order=50)]
      [Cardinality(Min=1,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.Dosage> Dosage
      {
        get
        {
          if(_Dosage.InOverflow<List<Hl7.Fhir.Model.Dosage>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.Dosage>), Overflow["dosage"]);
          return _Dosage ??= [];
        }

        set
        {
          if (_Dosage.InOverflow<List<Hl7.Fhir.Model.Dosage>>())
            Overflow.Remove("dosage");
          _Dosage = value;
          OnPropertyChanged("Dosage");
        }

      }

      private List<Hl7.Fhir.Model.Dosage>? _Dosage;

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not DosageComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_Type is not null) dest.Type = (Hl7.Fhir.Model.CodeableConcept)_Type.DeepCopyInternal();
        if(_Dosage is not null) dest.Dosage = new List<Hl7.Fhir.Model.Dosage>(_Dosage.DeepCopyInternal());
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new DosageComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not DosageComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_Type, otherT._Type)) return false;
        if(!comparer.ListEquals(_Dosage, otherT._Dosage)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "type":
            if (_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            {
              value = Overflow["type"];
              return true;
            }
            value = _Type;
            return (value as Hl7.Fhir.Model.CodeableConcept) is not null;
          case "dosage":
            if (_Dosage.InOverflow<List<Hl7.Fhir.Model.Dosage>>())
            {
              value = Overflow["dosage"];
              return true;
            }
            value = _Dosage;
            return (value as List<Hl7.Fhir.Model.Dosage>)?.Any() is true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "type":
            if (value is not (Hl7.Fhir.Model.CodeableConcept or null))
            {
              Type = OverflowNull<Hl7.Fhir.Model.CodeableConcept>.INSTANCE;
              Overflow["type"] = value;
            }
            else Type = (Hl7.Fhir.Model.CodeableConcept?)value!;
            return this;
          case "dosage":
            if (value is not (List<Hl7.Fhir.Model.Dosage> or null))
            {
              Dosage = OverflowNull<List<Hl7.Fhir.Model.Dosage>>.INSTANCE;
              Overflow["dosage"] = value;
            }
            else Dosage = (List<Hl7.Fhir.Model.Dosage>?)value!;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_Type is not null && !_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>()) yield return new KeyValuePair<string,object>("type",_Type);
        if (_Dosage?.Any() is true && !_Dosage.InOverflow<List<Hl7.Fhir.Model.Dosage>>()) yield return new KeyValuePair<string,object>("dosage",_Dosage);
      }

    }

    /// <summary>
    /// Characteristics of the patient that are relevant to the administration guidelines
    /// </summary>
    /// <remarks>
    /// Characteristics of the patient that are relevant to the administration guidelines (for example, height, weight, gender, etc.).
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("MedicationKnowledge.indicationGuideline.dosingGuideline.patientCharacteristic", IsBackboneType=true)]
    public partial class PatientCharacteristicComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "MedicationKnowledge.indicationGuideline.dosingGuideline.patientCharacteristic";

      /// <summary>
      /// Categorization of specific characteristic that is relevant to the administration guideline.
      /// </summary>
      [FhirElement("type", Order=40)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Type
      {
        get
        {
          if(_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.CodeableConcept), Overflow["type"]);
          return _Type!;
        }

        set
        {
          if (_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            Overflow.Remove("type");
          _Type = value;
          OnPropertyChanged("Type");
        }

      }

      private Hl7.Fhir.Model.CodeableConcept? _Type;

      /// <summary>
      /// The specific characteristic.
      /// </summary>
      [FhirElement("value", Order=50, Choice=ChoiceType.DatatypeChoice)]
      [CLSCompliant(false)]
      [AllowedTypes(typeof(Hl7.Fhir.Model.CodeableConcept),typeof(Hl7.Fhir.Model.Quantity),typeof(Hl7.Fhir.Model.Range))]
      [DataMember]
      public Hl7.Fhir.Model.DataType? Value
      {
        get
        {
          if(_Value.InOverflow<DynamicDataType>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.DataType), Overflow["value"]);
          return _Value;
        }

        set
        {
          if (_Value.InOverflow<DynamicDataType>())
            Overflow.Remove("value");
          _Value = value;
          OnPropertyChanged("Value");
        }

      }

      private Hl7.Fhir.Model.DataType? _Value;

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not PatientCharacteristicComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_Type is not null) dest.Type = (Hl7.Fhir.Model.CodeableConcept)_Type.DeepCopyInternal();
        if(_Value is not null) dest.Value = (Hl7.Fhir.Model.DataType)_Value.DeepCopyInternal();
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new PatientCharacteristicComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not PatientCharacteristicComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_Type, otherT._Type)) return false;
        if(!comparer.Equals(_Value, otherT._Value)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "type":
            if (_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            {
              value = Overflow["type"];
              return true;
            }
            value = _Type;
            return (value as Hl7.Fhir.Model.CodeableConcept) is not null;
          case "value":
            if (_Value.InOverflow<DynamicDataType>())
            {
              value = Overflow["value"];
              return true;
            }
            value = _Value;
            return (value as Hl7.Fhir.Model.DataType) is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "type":
            if (value is not (Hl7.Fhir.Model.CodeableConcept or null))
            {
              Type = OverflowNull<Hl7.Fhir.Model.CodeableConcept>.INSTANCE;
              Overflow["type"] = value;
            }
            else Type = (Hl7.Fhir.Model.CodeableConcept?)value!;
            return this;
          case "value":
            if (value is not (Hl7.Fhir.Model.DataType or null))
            {
              Value = OverflowNull<DynamicDataType>.INSTANCE;
              Overflow["value"] = value;
            }
            else Value = (Hl7.Fhir.Model.DataType?)value;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_Type is not null && !_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>()) yield return new KeyValuePair<string,object>("type",_Type);
        if (_Value is not null && !_Value.InOverflow<DynamicDataType>()) yield return new KeyValuePair<string,object>("value",_Value);
      }

    }

    /// <summary>
    /// Categorization of the medication within a formulary or classification system
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("MedicationKnowledge.medicineClassification", IsBackboneType=true)]
    public partial class MedicineClassificationComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "MedicationKnowledge.medicineClassification";

      /// <summary>
      /// The type of category for the medication (for example, therapeutic classification, therapeutic sub-classification).
      /// </summary>
      [FhirElement("type", Order=40)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Type
      {
        get
        {
          if(_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.CodeableConcept), Overflow["type"]);
          return _Type!;
        }

        set
        {
          if (_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            Overflow.Remove("type");
          _Type = value;
          OnPropertyChanged("Type");
        }

      }

      private Hl7.Fhir.Model.CodeableConcept? _Type;

      /// <summary>
      /// The source of the classification.
      /// </summary>
      [FhirElement("source", Order=50, Choice=ChoiceType.DatatypeChoice)]
      [CLSCompliant(false)]
      [AllowedTypes(typeof(Hl7.Fhir.Model.FhirString),typeof(Hl7.Fhir.Model.FhirUri))]
      [DataMember]
      public Hl7.Fhir.Model.DataType? Source
      {
        get
        {
          if(_Source.InOverflow<DynamicDataType>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.DataType), Overflow["source"]);
          return _Source;
        }

        set
        {
          if (_Source.InOverflow<DynamicDataType>())
            Overflow.Remove("source");
          _Source = value;
          OnPropertyChanged("Source");
        }

      }

      private Hl7.Fhir.Model.DataType? _Source;

      /// <summary>
      /// Specific category assigned to the medication.
      /// </summary>
      [FhirElement("classification", Order=60)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.CodeableConcept> Classification
      {
        get
        {
          if(_Classification.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.CodeableConcept>), Overflow["classification"]);
          return _Classification ??= [];
        }

        set
        {
          if (_Classification.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>())
            Overflow.Remove("classification");
          _Classification = value;
          OnPropertyChanged("Classification");
        }

      }

      private List<Hl7.Fhir.Model.CodeableConcept>? _Classification;

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not MedicineClassificationComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_Type is not null) dest.Type = (Hl7.Fhir.Model.CodeableConcept)_Type.DeepCopyInternal();
        if(_Source is not null) dest.Source = (Hl7.Fhir.Model.DataType)_Source.DeepCopyInternal();
        if(_Classification is not null) dest.Classification = new List<Hl7.Fhir.Model.CodeableConcept>(_Classification.DeepCopyInternal());
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new MedicineClassificationComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not MedicineClassificationComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_Type, otherT._Type)) return false;
        if(!comparer.Equals(_Source, otherT._Source)) return false;
        if(!comparer.ListEquals(_Classification, otherT._Classification)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "type":
            if (_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            {
              value = Overflow["type"];
              return true;
            }
            value = _Type;
            return (value as Hl7.Fhir.Model.CodeableConcept) is not null;
          case "source":
            if (_Source.InOverflow<DynamicDataType>())
            {
              value = Overflow["source"];
              return true;
            }
            value = _Source;
            return (value as Hl7.Fhir.Model.DataType) is not null;
          case "classification":
            if (_Classification.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>())
            {
              value = Overflow["classification"];
              return true;
            }
            value = _Classification;
            return (value as List<Hl7.Fhir.Model.CodeableConcept>)?.Any() is true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "type":
            if (value is not (Hl7.Fhir.Model.CodeableConcept or null))
            {
              Type = OverflowNull<Hl7.Fhir.Model.CodeableConcept>.INSTANCE;
              Overflow["type"] = value;
            }
            else Type = (Hl7.Fhir.Model.CodeableConcept?)value!;
            return this;
          case "source":
            if (value is not (Hl7.Fhir.Model.DataType or null))
            {
              Source = OverflowNull<DynamicDataType>.INSTANCE;
              Overflow["source"] = value;
            }
            else Source = (Hl7.Fhir.Model.DataType?)value;
            return this;
          case "classification":
            if (value is not (List<Hl7.Fhir.Model.CodeableConcept> or null))
            {
              Classification = OverflowNull<List<Hl7.Fhir.Model.CodeableConcept>>.INSTANCE;
              Overflow["classification"] = value;
            }
            else Classification = (List<Hl7.Fhir.Model.CodeableConcept>?)value!;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_Type is not null && !_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>()) yield return new KeyValuePair<string,object>("type",_Type);
        if (_Source is not null && !_Source.InOverflow<DynamicDataType>()) yield return new KeyValuePair<string,object>("source",_Source);
        if (_Classification?.Any() is true && !_Classification.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>()) yield return new KeyValuePair<string,object>("classification",_Classification);
      }

    }

    /// <summary>
    /// Details about packaged medications
    /// </summary>
    /// <remarks>
    /// Information that only applies to packages (not products).
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("MedicationKnowledge.packaging", IsBackboneType=true)]
    public partial class PackagingComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "MedicationKnowledge.packaging";

      /// <summary>
      /// Cost of the packaged medication.
      /// </summary>
      [FhirElement("cost", Order=40)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.MedicationKnowledge.CostComponent> Cost
      {
        get
        {
          if(_Cost.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.CostComponent>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.MedicationKnowledge.CostComponent>), Overflow["cost"]);
          return _Cost ??= [];
        }

        set
        {
          if (_Cost.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.CostComponent>>())
            Overflow.Remove("cost");
          _Cost = value;
          OnPropertyChanged("Cost");
        }

      }

      private List<Hl7.Fhir.Model.MedicationKnowledge.CostComponent>? _Cost;

      /// <summary>
      /// The packaged medication that is being priced.
      /// </summary>
      [FhirElement("packagedProduct", Order=50)]
      [CLSCompliant(false)]
      [References("PackagedProductDefinition")]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference? PackagedProduct
      {
        get
        {
          if(_PackagedProduct.InOverflow<Hl7.Fhir.Model.ResourceReference>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.ResourceReference), Overflow["packagedProduct"]);
          return _PackagedProduct;
        }

        set
        {
          if (_PackagedProduct.InOverflow<Hl7.Fhir.Model.ResourceReference>())
            Overflow.Remove("packagedProduct");
          _PackagedProduct = value;
          OnPropertyChanged("PackagedProduct");
        }

      }

      private Hl7.Fhir.Model.ResourceReference? _PackagedProduct;

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not PackagingComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_Cost is not null) dest.Cost = new List<Hl7.Fhir.Model.MedicationKnowledge.CostComponent>(_Cost.DeepCopyInternal());
        if(_PackagedProduct is not null) dest.PackagedProduct = (Hl7.Fhir.Model.ResourceReference)_PackagedProduct.DeepCopyInternal();
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new PackagingComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not PackagingComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.ListEquals(_Cost, otherT._Cost)) return false;
        if(!comparer.Equals(_PackagedProduct, otherT._PackagedProduct)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "cost":
            if (_Cost.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.CostComponent>>())
            {
              value = Overflow["cost"];
              return true;
            }
            value = _Cost;
            return (value as List<Hl7.Fhir.Model.MedicationKnowledge.CostComponent>)?.Any() is true;
          case "packagedProduct":
            if (_PackagedProduct.InOverflow<Hl7.Fhir.Model.ResourceReference>())
            {
              value = Overflow["packagedProduct"];
              return true;
            }
            value = _PackagedProduct;
            return (value as Hl7.Fhir.Model.ResourceReference) is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "cost":
            if (value is not (List<Hl7.Fhir.Model.MedicationKnowledge.CostComponent> or null))
            {
              Cost = OverflowNull<List<Hl7.Fhir.Model.MedicationKnowledge.CostComponent>>.INSTANCE;
              Overflow["cost"] = value;
            }
            else Cost = (List<Hl7.Fhir.Model.MedicationKnowledge.CostComponent>?)value!;
            return this;
          case "packagedProduct":
            if (value is not (Hl7.Fhir.Model.ResourceReference or null))
            {
              PackagedProduct = OverflowNull<Hl7.Fhir.Model.ResourceReference>.INSTANCE;
              Overflow["packagedProduct"] = value;
            }
            else PackagedProduct = (Hl7.Fhir.Model.ResourceReference?)value;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_Cost?.Any() is true && !_Cost.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.CostComponent>>()) yield return new KeyValuePair<string,object>("cost",_Cost);
        if (_PackagedProduct is not null && !_PackagedProduct.InOverflow<Hl7.Fhir.Model.ResourceReference>()) yield return new KeyValuePair<string,object>("packagedProduct",_PackagedProduct);
      }

    }

    /// <summary>
    /// How the medication should be stored
    /// </summary>
    /// <remarks>
    /// Information on how the medication should be stored, for example, refrigeration temperatures and length of stability at a given temperature.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("MedicationKnowledge.storageGuideline", IsBackboneType=true)]
    public partial class StorageGuidelineComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "MedicationKnowledge.storageGuideline";

      /// <summary>
      /// Reference to additional information.
      /// </summary>
      [FhirElement("reference", Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.FhirUri? ReferenceElement
      {
        get
        {
          if(_ReferenceElement.InOverflow<Hl7.Fhir.Model.FhirUri>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirUri), Overflow["reference"]);
          return _ReferenceElement;
        }

        set
        {
          if (_ReferenceElement.InOverflow<Hl7.Fhir.Model.FhirUri>())
            Overflow.Remove("reference");
          _ReferenceElement = value;
          OnPropertyChanged("ReferenceElement");
        }

      }

      private Hl7.Fhir.Model.FhirUri? _ReferenceElement;

      /// <summary>
      /// Reference to additional information
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? Reference
      {
        get => ReferenceElement?.Value;
        set
        {
          ReferenceElement = value is null ? null! : new Hl7.Fhir.Model.FhirUri(value);
          OnPropertyChanged("Reference");
        }
      }

      /// <summary>
      /// Additional storage notes.
      /// </summary>
      [FhirElement("note", Order=50)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.Annotation> Note
      {
        get
        {
          if(_Note.InOverflow<List<Hl7.Fhir.Model.Annotation>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.Annotation>), Overflow["note"]);
          return _Note ??= [];
        }

        set
        {
          if (_Note.InOverflow<List<Hl7.Fhir.Model.Annotation>>())
            Overflow.Remove("note");
          _Note = value;
          OnPropertyChanged("Note");
        }

      }

      private List<Hl7.Fhir.Model.Annotation>? _Note;

      /// <summary>
      /// Duration remains stable.
      /// </summary>
      [FhirElement("stabilityDuration", Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.Duration? StabilityDuration
      {
        get
        {
          if(_StabilityDuration.InOverflow<Hl7.Fhir.Model.Duration>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Duration), Overflow["stabilityDuration"]);
          return _StabilityDuration;
        }

        set
        {
          if (_StabilityDuration.InOverflow<Hl7.Fhir.Model.Duration>())
            Overflow.Remove("stabilityDuration");
          _StabilityDuration = value;
          OnPropertyChanged("StabilityDuration");
        }

      }

      private Hl7.Fhir.Model.Duration? _StabilityDuration;

      /// <summary>
      /// Setting or value of environment for adequate storage.
      /// </summary>
      [FhirElement("environmentalSetting", Order=70)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.MedicationKnowledge.EnvironmentalSettingComponent> EnvironmentalSetting
      {
        get
        {
          if(_EnvironmentalSetting.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.EnvironmentalSettingComponent>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.MedicationKnowledge.EnvironmentalSettingComponent>), Overflow["environmentalSetting"]);
          return _EnvironmentalSetting ??= [];
        }

        set
        {
          if (_EnvironmentalSetting.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.EnvironmentalSettingComponent>>())
            Overflow.Remove("environmentalSetting");
          _EnvironmentalSetting = value;
          OnPropertyChanged("EnvironmentalSetting");
        }

      }

      private List<Hl7.Fhir.Model.MedicationKnowledge.EnvironmentalSettingComponent>? _EnvironmentalSetting;

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not StorageGuidelineComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_ReferenceElement is not null) dest.ReferenceElement = (Hl7.Fhir.Model.FhirUri)_ReferenceElement.DeepCopyInternal();
        if(_Note is not null) dest.Note = new List<Hl7.Fhir.Model.Annotation>(_Note.DeepCopyInternal());
        if(_StabilityDuration is not null) dest.StabilityDuration = (Hl7.Fhir.Model.Duration)_StabilityDuration.DeepCopyInternal();
        if(_EnvironmentalSetting is not null) dest.EnvironmentalSetting = new List<Hl7.Fhir.Model.MedicationKnowledge.EnvironmentalSettingComponent>(_EnvironmentalSetting.DeepCopyInternal());
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new StorageGuidelineComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not StorageGuidelineComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_ReferenceElement, otherT._ReferenceElement)) return false;
        if(!comparer.ListEquals(_Note, otherT._Note)) return false;
        if(!comparer.Equals(_StabilityDuration, otherT._StabilityDuration)) return false;
        if(!comparer.ListEquals(_EnvironmentalSetting, otherT._EnvironmentalSetting)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "reference":
            if (_ReferenceElement.InOverflow<Hl7.Fhir.Model.FhirUri>())
            {
              value = Overflow["reference"];
              return true;
            }
            value = _ReferenceElement;
            return (value as Hl7.Fhir.Model.FhirUri) is not null;
          case "note":
            if (_Note.InOverflow<List<Hl7.Fhir.Model.Annotation>>())
            {
              value = Overflow["note"];
              return true;
            }
            value = _Note;
            return (value as List<Hl7.Fhir.Model.Annotation>)?.Any() is true;
          case "stabilityDuration":
            if (_StabilityDuration.InOverflow<Hl7.Fhir.Model.Duration>())
            {
              value = Overflow["stabilityDuration"];
              return true;
            }
            value = _StabilityDuration;
            return (value as Hl7.Fhir.Model.Duration) is not null;
          case "environmentalSetting":
            if (_EnvironmentalSetting.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.EnvironmentalSettingComponent>>())
            {
              value = Overflow["environmentalSetting"];
              return true;
            }
            value = _EnvironmentalSetting;
            return (value as List<Hl7.Fhir.Model.MedicationKnowledge.EnvironmentalSettingComponent>)?.Any() is true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "reference":
            if (value is not (Hl7.Fhir.Model.FhirUri or null))
            {
              ReferenceElement = OverflowNull<Hl7.Fhir.Model.FhirUri>.INSTANCE;
              Overflow["reference"] = value;
            }
            else ReferenceElement = (Hl7.Fhir.Model.FhirUri?)value;
            return this;
          case "note":
            if (value is not (List<Hl7.Fhir.Model.Annotation> or null))
            {
              Note = OverflowNull<List<Hl7.Fhir.Model.Annotation>>.INSTANCE;
              Overflow["note"] = value;
            }
            else Note = (List<Hl7.Fhir.Model.Annotation>?)value!;
            return this;
          case "stabilityDuration":
            if (value is not (Hl7.Fhir.Model.Duration or null))
            {
              StabilityDuration = OverflowNull<Hl7.Fhir.Model.Duration>.INSTANCE;
              Overflow["stabilityDuration"] = value;
            }
            else StabilityDuration = (Hl7.Fhir.Model.Duration?)value;
            return this;
          case "environmentalSetting":
            if (value is not (List<Hl7.Fhir.Model.MedicationKnowledge.EnvironmentalSettingComponent> or null))
            {
              EnvironmentalSetting = OverflowNull<List<Hl7.Fhir.Model.MedicationKnowledge.EnvironmentalSettingComponent>>.INSTANCE;
              Overflow["environmentalSetting"] = value;
            }
            else EnvironmentalSetting = (List<Hl7.Fhir.Model.MedicationKnowledge.EnvironmentalSettingComponent>?)value!;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_ReferenceElement is not null && !_ReferenceElement.InOverflow<Hl7.Fhir.Model.FhirUri>()) yield return new KeyValuePair<string,object>("reference",_ReferenceElement);
        if (_Note?.Any() is true && !_Note.InOverflow<List<Hl7.Fhir.Model.Annotation>>()) yield return new KeyValuePair<string,object>("note",_Note);
        if (_StabilityDuration is not null && !_StabilityDuration.InOverflow<Hl7.Fhir.Model.Duration>()) yield return new KeyValuePair<string,object>("stabilityDuration",_StabilityDuration);
        if (_EnvironmentalSetting?.Any() is true && !_EnvironmentalSetting.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.EnvironmentalSettingComponent>>()) yield return new KeyValuePair<string,object>("environmentalSetting",_EnvironmentalSetting);
      }

    }

    /// <summary>
    /// Setting or value of environment for adequate storage
    /// </summary>
    /// <remarks>
    /// Describes a setting/value on the environment for the adequate storage of the medication and other substances.  Environment settings may involve temperature, humidity, or exposure to light.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("MedicationKnowledge.storageGuideline.environmentalSetting", IsBackboneType=true)]
    public partial class EnvironmentalSettingComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "MedicationKnowledge.storageGuideline.environmentalSetting";

      /// <summary>
      /// Categorization of the setting.
      /// </summary>
      [FhirElement("type", Order=40)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Type
      {
        get
        {
          if(_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.CodeableConcept), Overflow["type"]);
          return _Type!;
        }

        set
        {
          if (_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            Overflow.Remove("type");
          _Type = value;
          OnPropertyChanged("Type");
        }

      }

      private Hl7.Fhir.Model.CodeableConcept? _Type;

      /// <summary>
      /// Value of the setting.
      /// </summary>
      [FhirElement("value", Order=50, Choice=ChoiceType.DatatypeChoice)]
      [CLSCompliant(false)]
      [AllowedTypes(typeof(Hl7.Fhir.Model.Quantity),typeof(Hl7.Fhir.Model.Range),typeof(Hl7.Fhir.Model.CodeableConcept))]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.DataType Value
      {
        get
        {
          if(_Value.InOverflow<DynamicDataType>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.DataType), Overflow["value"]);
          return _Value!;
        }

        set
        {
          if (_Value.InOverflow<DynamicDataType>())
            Overflow.Remove("value");
          _Value = value;
          OnPropertyChanged("Value");
        }

      }

      private Hl7.Fhir.Model.DataType? _Value;

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not EnvironmentalSettingComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_Type is not null) dest.Type = (Hl7.Fhir.Model.CodeableConcept)_Type.DeepCopyInternal();
        if(_Value is not null) dest.Value = (Hl7.Fhir.Model.DataType)_Value.DeepCopyInternal();
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new EnvironmentalSettingComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not EnvironmentalSettingComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_Type, otherT._Type)) return false;
        if(!comparer.Equals(_Value, otherT._Value)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "type":
            if (_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            {
              value = Overflow["type"];
              return true;
            }
            value = _Type;
            return (value as Hl7.Fhir.Model.CodeableConcept) is not null;
          case "value":
            if (_Value.InOverflow<DynamicDataType>())
            {
              value = Overflow["value"];
              return true;
            }
            value = _Value;
            return (value as Hl7.Fhir.Model.DataType) is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "type":
            if (value is not (Hl7.Fhir.Model.CodeableConcept or null))
            {
              Type = OverflowNull<Hl7.Fhir.Model.CodeableConcept>.INSTANCE;
              Overflow["type"] = value;
            }
            else Type = (Hl7.Fhir.Model.CodeableConcept?)value!;
            return this;
          case "value":
            if (value is not (Hl7.Fhir.Model.DataType or null))
            {
              Value = OverflowNull<DynamicDataType>.INSTANCE;
              Overflow["value"] = value;
            }
            else Value = (Hl7.Fhir.Model.DataType?)value!;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_Type is not null && !_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>()) yield return new KeyValuePair<string,object>("type",_Type);
        if (_Value is not null && !_Value.InOverflow<DynamicDataType>()) yield return new KeyValuePair<string,object>("value",_Value);
      }

    }

    /// <summary>
    /// Regulatory information about a medication
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("MedicationKnowledge.regulatory", IsBackboneType=true)]
    public partial class RegulatoryComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "MedicationKnowledge.regulatory";

      /// <summary>
      /// Specifies the authority of the regulation.
      /// </summary>
      [FhirElement("regulatoryAuthority", Order=40)]
      [CLSCompliant(false)]
      [References("Organization")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference RegulatoryAuthority
      {
        get
        {
          if(_RegulatoryAuthority.InOverflow<Hl7.Fhir.Model.ResourceReference>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.ResourceReference), Overflow["regulatoryAuthority"]);
          return _RegulatoryAuthority!;
        }

        set
        {
          if (_RegulatoryAuthority.InOverflow<Hl7.Fhir.Model.ResourceReference>())
            Overflow.Remove("regulatoryAuthority");
          _RegulatoryAuthority = value;
          OnPropertyChanged("RegulatoryAuthority");
        }

      }

      private Hl7.Fhir.Model.ResourceReference? _RegulatoryAuthority;

      /// <summary>
      /// Specifies if changes are allowed when dispensing a medication from a regulatory perspective.
      /// </summary>
      [FhirElement("substitution", Order=50)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.MedicationKnowledge.SubstitutionComponent> Substitution
      {
        get
        {
          if(_Substitution.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.SubstitutionComponent>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.MedicationKnowledge.SubstitutionComponent>), Overflow["substitution"]);
          return _Substitution ??= [];
        }

        set
        {
          if (_Substitution.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.SubstitutionComponent>>())
            Overflow.Remove("substitution");
          _Substitution = value;
          OnPropertyChanged("Substitution");
        }

      }

      private List<Hl7.Fhir.Model.MedicationKnowledge.SubstitutionComponent>? _Substitution;

      /// <summary>
      /// Specifies the schedule of a medication in jurisdiction.
      /// </summary>
      [FhirElement("schedule", Order=60)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.CodeableConcept> Schedule
      {
        get
        {
          if(_Schedule.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.CodeableConcept>), Overflow["schedule"]);
          return _Schedule ??= [];
        }

        set
        {
          if (_Schedule.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>())
            Overflow.Remove("schedule");
          _Schedule = value;
          OnPropertyChanged("Schedule");
        }

      }

      private List<Hl7.Fhir.Model.CodeableConcept>? _Schedule;

      /// <summary>
      /// The maximum number of units of the medication that can be dispensed in a period.
      /// </summary>
      [FhirElement("maxDispense", Order=70)]
      [DataMember]
      public Hl7.Fhir.Model.MedicationKnowledge.MaxDispenseComponent? MaxDispense
      {
        get
        {
          if(_MaxDispense.InOverflow<Hl7.Fhir.Model.MedicationKnowledge.MaxDispenseComponent>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.MedicationKnowledge.MaxDispenseComponent), Overflow["maxDispense"]);
          return _MaxDispense;
        }

        set
        {
          if (_MaxDispense.InOverflow<Hl7.Fhir.Model.MedicationKnowledge.MaxDispenseComponent>())
            Overflow.Remove("maxDispense");
          _MaxDispense = value;
          OnPropertyChanged("MaxDispense");
        }

      }

      private Hl7.Fhir.Model.MedicationKnowledge.MaxDispenseComponent? _MaxDispense;

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not RegulatoryComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_RegulatoryAuthority is not null) dest.RegulatoryAuthority = (Hl7.Fhir.Model.ResourceReference)_RegulatoryAuthority.DeepCopyInternal();
        if(_Substitution is not null) dest.Substitution = new List<Hl7.Fhir.Model.MedicationKnowledge.SubstitutionComponent>(_Substitution.DeepCopyInternal());
        if(_Schedule is not null) dest.Schedule = new List<Hl7.Fhir.Model.CodeableConcept>(_Schedule.DeepCopyInternal());
        if(_MaxDispense is not null) dest.MaxDispense = (Hl7.Fhir.Model.MedicationKnowledge.MaxDispenseComponent)_MaxDispense.DeepCopyInternal();
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new RegulatoryComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not RegulatoryComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_RegulatoryAuthority, otherT._RegulatoryAuthority)) return false;
        if(!comparer.ListEquals(_Substitution, otherT._Substitution)) return false;
        if(!comparer.ListEquals(_Schedule, otherT._Schedule)) return false;
        if(!comparer.Equals(_MaxDispense, otherT._MaxDispense)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "regulatoryAuthority":
            if (_RegulatoryAuthority.InOverflow<Hl7.Fhir.Model.ResourceReference>())
            {
              value = Overflow["regulatoryAuthority"];
              return true;
            }
            value = _RegulatoryAuthority;
            return (value as Hl7.Fhir.Model.ResourceReference) is not null;
          case "substitution":
            if (_Substitution.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.SubstitutionComponent>>())
            {
              value = Overflow["substitution"];
              return true;
            }
            value = _Substitution;
            return (value as List<Hl7.Fhir.Model.MedicationKnowledge.SubstitutionComponent>)?.Any() is true;
          case "schedule":
            if (_Schedule.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>())
            {
              value = Overflow["schedule"];
              return true;
            }
            value = _Schedule;
            return (value as List<Hl7.Fhir.Model.CodeableConcept>)?.Any() is true;
          case "maxDispense":
            if (_MaxDispense.InOverflow<Hl7.Fhir.Model.MedicationKnowledge.MaxDispenseComponent>())
            {
              value = Overflow["maxDispense"];
              return true;
            }
            value = _MaxDispense;
            return (value as Hl7.Fhir.Model.MedicationKnowledge.MaxDispenseComponent) is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "regulatoryAuthority":
            if (value is not (Hl7.Fhir.Model.ResourceReference or null))
            {
              RegulatoryAuthority = OverflowNull<Hl7.Fhir.Model.ResourceReference>.INSTANCE;
              Overflow["regulatoryAuthority"] = value;
            }
            else RegulatoryAuthority = (Hl7.Fhir.Model.ResourceReference?)value!;
            return this;
          case "substitution":
            if (value is not (List<Hl7.Fhir.Model.MedicationKnowledge.SubstitutionComponent> or null))
            {
              Substitution = OverflowNull<List<Hl7.Fhir.Model.MedicationKnowledge.SubstitutionComponent>>.INSTANCE;
              Overflow["substitution"] = value;
            }
            else Substitution = (List<Hl7.Fhir.Model.MedicationKnowledge.SubstitutionComponent>?)value!;
            return this;
          case "schedule":
            if (value is not (List<Hl7.Fhir.Model.CodeableConcept> or null))
            {
              Schedule = OverflowNull<List<Hl7.Fhir.Model.CodeableConcept>>.INSTANCE;
              Overflow["schedule"] = value;
            }
            else Schedule = (List<Hl7.Fhir.Model.CodeableConcept>?)value!;
            return this;
          case "maxDispense":
            if (value is not (Hl7.Fhir.Model.MedicationKnowledge.MaxDispenseComponent or null))
            {
              MaxDispense = OverflowNull<Hl7.Fhir.Model.MedicationKnowledge.MaxDispenseComponent>.INSTANCE;
              Overflow["maxDispense"] = value;
            }
            else MaxDispense = (Hl7.Fhir.Model.MedicationKnowledge.MaxDispenseComponent?)value;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_RegulatoryAuthority is not null && !_RegulatoryAuthority.InOverflow<Hl7.Fhir.Model.ResourceReference>()) yield return new KeyValuePair<string,object>("regulatoryAuthority",_RegulatoryAuthority);
        if (_Substitution?.Any() is true && !_Substitution.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.SubstitutionComponent>>()) yield return new KeyValuePair<string,object>("substitution",_Substitution);
        if (_Schedule?.Any() is true && !_Schedule.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>()) yield return new KeyValuePair<string,object>("schedule",_Schedule);
        if (_MaxDispense is not null && !_MaxDispense.InOverflow<Hl7.Fhir.Model.MedicationKnowledge.MaxDispenseComponent>()) yield return new KeyValuePair<string,object>("maxDispense",_MaxDispense);
      }

    }

    /// <summary>
    /// Specifies if changes are allowed when dispensing a medication from a regulatory perspective
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("MedicationKnowledge.regulatory.substitution", IsBackboneType=true)]
    public partial class SubstitutionComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "MedicationKnowledge.regulatory.substitution";

      /// <summary>
      /// Specifies the type of substitution allowed.
      /// </summary>
      [FhirElement("type", Order=40)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept Type
      {
        get
        {
          if(_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.CodeableConcept), Overflow["type"]);
          return _Type!;
        }

        set
        {
          if (_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            Overflow.Remove("type");
          _Type = value;
          OnPropertyChanged("Type");
        }

      }

      private Hl7.Fhir.Model.CodeableConcept? _Type;

      /// <summary>
      /// Specifies if regulation allows for changes in the medication when dispensing.
      /// </summary>
      [FhirElement("allowed", Order=50)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.FhirBoolean AllowedElement
      {
        get
        {
          if(_AllowedElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirBoolean), Overflow["allowed"]);
          return _AllowedElement!;
        }

        set
        {
          if (_AllowedElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>())
            Overflow.Remove("allowed");
          _AllowedElement = value;
          OnPropertyChanged("AllowedElement");
        }

      }

      private Hl7.Fhir.Model.FhirBoolean? _AllowedElement;

      /// <summary>
      /// Specifies if regulation allows for changes in the medication when dispensing
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public bool? Allowed
      {
        get => AllowedElement?.Value;
        set
        {
          AllowedElement = value is null ? null! : new Hl7.Fhir.Model.FhirBoolean(value);
          OnPropertyChanged("Allowed");
        }
      }

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not SubstitutionComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_Type is not null) dest.Type = (Hl7.Fhir.Model.CodeableConcept)_Type.DeepCopyInternal();
        if(_AllowedElement is not null) dest.AllowedElement = (Hl7.Fhir.Model.FhirBoolean)_AllowedElement.DeepCopyInternal();
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new SubstitutionComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not SubstitutionComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_Type, otherT._Type)) return false;
        if(!comparer.Equals(_AllowedElement, otherT._AllowedElement)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "type":
            if (_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            {
              value = Overflow["type"];
              return true;
            }
            value = _Type;
            return (value as Hl7.Fhir.Model.CodeableConcept) is not null;
          case "allowed":
            if (_AllowedElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>())
            {
              value = Overflow["allowed"];
              return true;
            }
            value = _AllowedElement;
            return (value as Hl7.Fhir.Model.FhirBoolean) is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "type":
            if (value is not (Hl7.Fhir.Model.CodeableConcept or null))
            {
              Type = OverflowNull<Hl7.Fhir.Model.CodeableConcept>.INSTANCE;
              Overflow["type"] = value;
            }
            else Type = (Hl7.Fhir.Model.CodeableConcept?)value!;
            return this;
          case "allowed":
            if (value is not (Hl7.Fhir.Model.FhirBoolean or null))
            {
              AllowedElement = OverflowNull<Hl7.Fhir.Model.FhirBoolean>.INSTANCE;
              Overflow["allowed"] = value;
            }
            else AllowedElement = (Hl7.Fhir.Model.FhirBoolean?)value!;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_Type is not null && !_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>()) yield return new KeyValuePair<string,object>("type",_Type);
        if (_AllowedElement is not null && !_AllowedElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>()) yield return new KeyValuePair<string,object>("allowed",_AllowedElement);
      }

    }

    /// <summary>
    /// The maximum number of units of the medication that can be dispensed in a period
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("MedicationKnowledge.regulatory.maxDispense", IsBackboneType=true)]
    public partial class MaxDispenseComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "MedicationKnowledge.regulatory.maxDispense";

      /// <summary>
      /// The maximum number of units of the medication that can be dispensed.
      /// </summary>
      [FhirElement("quantity", Order=40)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.Quantity Quantity
      {
        get
        {
          if(_Quantity.InOverflow<Hl7.Fhir.Model.Quantity>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Quantity), Overflow["quantity"]);
          return _Quantity!;
        }

        set
        {
          if (_Quantity.InOverflow<Hl7.Fhir.Model.Quantity>())
            Overflow.Remove("quantity");
          _Quantity = value;
          OnPropertyChanged("Quantity");
        }

      }

      private Hl7.Fhir.Model.Quantity? _Quantity;

      /// <summary>
      /// The period that applies to the maximum number of units.
      /// </summary>
      [FhirElement("period", Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.Duration? Period
      {
        get
        {
          if(_Period.InOverflow<Hl7.Fhir.Model.Duration>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Duration), Overflow["period"]);
          return _Period;
        }

        set
        {
          if (_Period.InOverflow<Hl7.Fhir.Model.Duration>())
            Overflow.Remove("period");
          _Period = value;
          OnPropertyChanged("Period");
        }

      }

      private Hl7.Fhir.Model.Duration? _Period;

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not MaxDispenseComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_Quantity is not null) dest.Quantity = (Hl7.Fhir.Model.Quantity)_Quantity.DeepCopyInternal();
        if(_Period is not null) dest.Period = (Hl7.Fhir.Model.Duration)_Period.DeepCopyInternal();
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new MaxDispenseComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not MaxDispenseComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_Quantity, otherT._Quantity)) return false;
        if(!comparer.Equals(_Period, otherT._Period)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "quantity":
            if (_Quantity.InOverflow<Hl7.Fhir.Model.Quantity>())
            {
              value = Overflow["quantity"];
              return true;
            }
            value = _Quantity;
            return (value as Hl7.Fhir.Model.Quantity) is not null;
          case "period":
            if (_Period.InOverflow<Hl7.Fhir.Model.Duration>())
            {
              value = Overflow["period"];
              return true;
            }
            value = _Period;
            return (value as Hl7.Fhir.Model.Duration) is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "quantity":
            if (value is not (Hl7.Fhir.Model.Quantity or null))
            {
              Quantity = OverflowNull<Hl7.Fhir.Model.Quantity>.INSTANCE;
              Overflow["quantity"] = value;
            }
            else Quantity = (Hl7.Fhir.Model.Quantity?)value!;
            return this;
          case "period":
            if (value is not (Hl7.Fhir.Model.Duration or null))
            {
              Period = OverflowNull<Hl7.Fhir.Model.Duration>.INSTANCE;
              Overflow["period"] = value;
            }
            else Period = (Hl7.Fhir.Model.Duration?)value;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_Quantity is not null && !_Quantity.InOverflow<Hl7.Fhir.Model.Quantity>()) yield return new KeyValuePair<string,object>("quantity",_Quantity);
        if (_Period is not null && !_Period.InOverflow<Hl7.Fhir.Model.Duration>()) yield return new KeyValuePair<string,object>("period",_Period);
      }

    }

    /// <summary>
    /// Minimal definition information about the medication
    /// </summary>
    /// <remarks>
    /// Along with the link to a Medicinal Product Definition resource, this information provides common definitional elements that are needed to understand the specific medication that is being described.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("MedicationKnowledge.definitional", IsBackboneType=true)]
    public partial class DefinitionalComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "MedicationKnowledge.definitional";

      /// <summary>
      /// Definitional resources that provide more information about this medication.
      /// </summary>
      [FhirElement("definition", Order=40)]
      [CLSCompliant(false)]
      [References("MedicinalProductDefinition")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.ResourceReference> Definition
      {
        get
        {
          if(_Definition.InOverflow<List<Hl7.Fhir.Model.ResourceReference>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.ResourceReference>), Overflow["definition"]);
          return _Definition ??= [];
        }

        set
        {
          if (_Definition.InOverflow<List<Hl7.Fhir.Model.ResourceReference>>())
            Overflow.Remove("definition");
          _Definition = value;
          OnPropertyChanged("Definition");
        }

      }

      private List<Hl7.Fhir.Model.ResourceReference>? _Definition;

      /// <summary>
      /// powder | tablets | capsule +.
      /// </summary>
      [FhirElement("doseForm", Order=50)]
      [Binding("MedicationForm")]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept? DoseForm
      {
        get
        {
          if(_DoseForm.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.CodeableConcept), Overflow["doseForm"]);
          return _DoseForm;
        }

        set
        {
          if (_DoseForm.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            Overflow.Remove("doseForm");
          _DoseForm = value;
          OnPropertyChanged("DoseForm");
        }

      }

      private Hl7.Fhir.Model.CodeableConcept? _DoseForm;

      /// <summary>
      /// The intended or approved route of administration.
      /// </summary>
      [FhirElement("intendedRoute", Order=60)]
      [Binding("MedicationRoute")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.CodeableConcept> IntendedRoute
      {
        get
        {
          if(_IntendedRoute.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.CodeableConcept>), Overflow["intendedRoute"]);
          return _IntendedRoute ??= [];
        }

        set
        {
          if (_IntendedRoute.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>())
            Overflow.Remove("intendedRoute");
          _IntendedRoute = value;
          OnPropertyChanged("IntendedRoute");
        }

      }

      private List<Hl7.Fhir.Model.CodeableConcept>? _IntendedRoute;

      /// <summary>
      /// Active or inactive ingredient.
      /// </summary>
      [FhirElement("ingredient", InSummary=true, Order=70)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.MedicationKnowledge.IngredientComponent> Ingredient
      {
        get
        {
          if(_Ingredient.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.IngredientComponent>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.MedicationKnowledge.IngredientComponent>), Overflow["ingredient"]);
          return _Ingredient ??= [];
        }

        set
        {
          if (_Ingredient.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.IngredientComponent>>())
            Overflow.Remove("ingredient");
          _Ingredient = value;
          OnPropertyChanged("Ingredient");
        }

      }

      private List<Hl7.Fhir.Model.MedicationKnowledge.IngredientComponent>? _Ingredient;

      /// <summary>
      /// Specifies descriptive properties of the medicine.
      /// </summary>
      [FhirElement("drugCharacteristic", Order=80)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.MedicationKnowledge.DrugCharacteristicComponent> DrugCharacteristic
      {
        get
        {
          if(_DrugCharacteristic.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.DrugCharacteristicComponent>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.MedicationKnowledge.DrugCharacteristicComponent>), Overflow["drugCharacteristic"]);
          return _DrugCharacteristic ??= [];
        }

        set
        {
          if (_DrugCharacteristic.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.DrugCharacteristicComponent>>())
            Overflow.Remove("drugCharacteristic");
          _DrugCharacteristic = value;
          OnPropertyChanged("DrugCharacteristic");
        }

      }

      private List<Hl7.Fhir.Model.MedicationKnowledge.DrugCharacteristicComponent>? _DrugCharacteristic;

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not DefinitionalComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_Definition is not null) dest.Definition = new List<Hl7.Fhir.Model.ResourceReference>(_Definition.DeepCopyInternal());
        if(_DoseForm is not null) dest.DoseForm = (Hl7.Fhir.Model.CodeableConcept)_DoseForm.DeepCopyInternal();
        if(_IntendedRoute is not null) dest.IntendedRoute = new List<Hl7.Fhir.Model.CodeableConcept>(_IntendedRoute.DeepCopyInternal());
        if(_Ingredient is not null) dest.Ingredient = new List<Hl7.Fhir.Model.MedicationKnowledge.IngredientComponent>(_Ingredient.DeepCopyInternal());
        if(_DrugCharacteristic is not null) dest.DrugCharacteristic = new List<Hl7.Fhir.Model.MedicationKnowledge.DrugCharacteristicComponent>(_DrugCharacteristic.DeepCopyInternal());
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new DefinitionalComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not DefinitionalComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.ListEquals(_Definition, otherT._Definition)) return false;
        if(!comparer.Equals(_DoseForm, otherT._DoseForm)) return false;
        if(!comparer.ListEquals(_IntendedRoute, otherT._IntendedRoute)) return false;
        if(!comparer.ListEquals(_Ingredient, otherT._Ingredient)) return false;
        if(!comparer.ListEquals(_DrugCharacteristic, otherT._DrugCharacteristic)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "definition":
            if (_Definition.InOverflow<List<Hl7.Fhir.Model.ResourceReference>>())
            {
              value = Overflow["definition"];
              return true;
            }
            value = _Definition;
            return (value as List<Hl7.Fhir.Model.ResourceReference>)?.Any() is true;
          case "doseForm":
            if (_DoseForm.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            {
              value = Overflow["doseForm"];
              return true;
            }
            value = _DoseForm;
            return (value as Hl7.Fhir.Model.CodeableConcept) is not null;
          case "intendedRoute":
            if (_IntendedRoute.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>())
            {
              value = Overflow["intendedRoute"];
              return true;
            }
            value = _IntendedRoute;
            return (value as List<Hl7.Fhir.Model.CodeableConcept>)?.Any() is true;
          case "ingredient":
            if (_Ingredient.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.IngredientComponent>>())
            {
              value = Overflow["ingredient"];
              return true;
            }
            value = _Ingredient;
            return (value as List<Hl7.Fhir.Model.MedicationKnowledge.IngredientComponent>)?.Any() is true;
          case "drugCharacteristic":
            if (_DrugCharacteristic.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.DrugCharacteristicComponent>>())
            {
              value = Overflow["drugCharacteristic"];
              return true;
            }
            value = _DrugCharacteristic;
            return (value as List<Hl7.Fhir.Model.MedicationKnowledge.DrugCharacteristicComponent>)?.Any() is true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "definition":
            if (value is not (List<Hl7.Fhir.Model.ResourceReference> or null))
            {
              Definition = OverflowNull<List<Hl7.Fhir.Model.ResourceReference>>.INSTANCE;
              Overflow["definition"] = value;
            }
            else Definition = (List<Hl7.Fhir.Model.ResourceReference>?)value!;
            return this;
          case "doseForm":
            if (value is not (Hl7.Fhir.Model.CodeableConcept or null))
            {
              DoseForm = OverflowNull<Hl7.Fhir.Model.CodeableConcept>.INSTANCE;
              Overflow["doseForm"] = value;
            }
            else DoseForm = (Hl7.Fhir.Model.CodeableConcept?)value;
            return this;
          case "intendedRoute":
            if (value is not (List<Hl7.Fhir.Model.CodeableConcept> or null))
            {
              IntendedRoute = OverflowNull<List<Hl7.Fhir.Model.CodeableConcept>>.INSTANCE;
              Overflow["intendedRoute"] = value;
            }
            else IntendedRoute = (List<Hl7.Fhir.Model.CodeableConcept>?)value!;
            return this;
          case "ingredient":
            if (value is not (List<Hl7.Fhir.Model.MedicationKnowledge.IngredientComponent> or null))
            {
              Ingredient = OverflowNull<List<Hl7.Fhir.Model.MedicationKnowledge.IngredientComponent>>.INSTANCE;
              Overflow["ingredient"] = value;
            }
            else Ingredient = (List<Hl7.Fhir.Model.MedicationKnowledge.IngredientComponent>?)value!;
            return this;
          case "drugCharacteristic":
            if (value is not (List<Hl7.Fhir.Model.MedicationKnowledge.DrugCharacteristicComponent> or null))
            {
              DrugCharacteristic = OverflowNull<List<Hl7.Fhir.Model.MedicationKnowledge.DrugCharacteristicComponent>>.INSTANCE;
              Overflow["drugCharacteristic"] = value;
            }
            else DrugCharacteristic = (List<Hl7.Fhir.Model.MedicationKnowledge.DrugCharacteristicComponent>?)value!;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_Definition?.Any() is true && !_Definition.InOverflow<List<Hl7.Fhir.Model.ResourceReference>>()) yield return new KeyValuePair<string,object>("definition",_Definition);
        if (_DoseForm is not null && !_DoseForm.InOverflow<Hl7.Fhir.Model.CodeableConcept>()) yield return new KeyValuePair<string,object>("doseForm",_DoseForm);
        if (_IntendedRoute?.Any() is true && !_IntendedRoute.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>()) yield return new KeyValuePair<string,object>("intendedRoute",_IntendedRoute);
        if (_Ingredient?.Any() is true && !_Ingredient.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.IngredientComponent>>()) yield return new KeyValuePair<string,object>("ingredient",_Ingredient);
        if (_DrugCharacteristic?.Any() is true && !_DrugCharacteristic.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.DrugCharacteristicComponent>>()) yield return new KeyValuePair<string,object>("drugCharacteristic",_DrugCharacteristic);
      }

    }

    /// <summary>
    /// Active or inactive ingredient
    /// </summary>
    /// <remarks>
    /// Identifies a particular constituent of interest in the product.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("MedicationKnowledge.definitional.ingredient", IsBackboneType=true)]
    public partial class IngredientComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "MedicationKnowledge.definitional.ingredient";

      /// <summary>
      /// Substances contained in the medication.
      /// </summary>
      [FhirElement("item", InSummary=true, Order=40)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableReference Item
      {
        get
        {
          if(_Item.InOverflow<Hl7.Fhir.Model.CodeableReference>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.CodeableReference), Overflow["item"]);
          return _Item!;
        }

        set
        {
          if (_Item.InOverflow<Hl7.Fhir.Model.CodeableReference>())
            Overflow.Remove("item");
          _Item = value;
          OnPropertyChanged("Item");
        }

      }

      private Hl7.Fhir.Model.CodeableReference? _Item;

      /// <summary>
      /// A code that defines the type of ingredient, active, base, etc.
      /// </summary>
      [FhirElement("type", Order=50)]
      [Binding("MedicationIngredientIsActive")]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept? Type
      {
        get
        {
          if(_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.CodeableConcept), Overflow["type"]);
          return _Type;
        }

        set
        {
          if (_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            Overflow.Remove("type");
          _Type = value;
          OnPropertyChanged("Type");
        }

      }

      private Hl7.Fhir.Model.CodeableConcept? _Type;

      /// <summary>
      /// Quantity of ingredient present.
      /// </summary>
      [FhirElement("strength", Order=60, Choice=ChoiceType.DatatypeChoice)]
      [Binding("MedicationIngredientStrength")]
      [CLSCompliant(false)]
      [AllowedTypes(typeof(Hl7.Fhir.Model.Ratio),typeof(Hl7.Fhir.Model.CodeableConcept),typeof(Hl7.Fhir.Model.Quantity))]
      [DataMember]
      public Hl7.Fhir.Model.DataType? Strength
      {
        get
        {
          if(_Strength.InOverflow<DynamicDataType>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.DataType), Overflow["strength"]);
          return _Strength;
        }

        set
        {
          if (_Strength.InOverflow<DynamicDataType>())
            Overflow.Remove("strength");
          _Strength = value;
          OnPropertyChanged("Strength");
        }

      }

      private Hl7.Fhir.Model.DataType? _Strength;

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not IngredientComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_Item is not null) dest.Item = (Hl7.Fhir.Model.CodeableReference)_Item.DeepCopyInternal();
        if(_Type is not null) dest.Type = (Hl7.Fhir.Model.CodeableConcept)_Type.DeepCopyInternal();
        if(_Strength is not null) dest.Strength = (Hl7.Fhir.Model.DataType)_Strength.DeepCopyInternal();
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new IngredientComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not IngredientComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_Item, otherT._Item)) return false;
        if(!comparer.Equals(_Type, otherT._Type)) return false;
        if(!comparer.Equals(_Strength, otherT._Strength)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "item":
            if (_Item.InOverflow<Hl7.Fhir.Model.CodeableReference>())
            {
              value = Overflow["item"];
              return true;
            }
            value = _Item;
            return (value as Hl7.Fhir.Model.CodeableReference) is not null;
          case "type":
            if (_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            {
              value = Overflow["type"];
              return true;
            }
            value = _Type;
            return (value as Hl7.Fhir.Model.CodeableConcept) is not null;
          case "strength":
            if (_Strength.InOverflow<DynamicDataType>())
            {
              value = Overflow["strength"];
              return true;
            }
            value = _Strength;
            return (value as Hl7.Fhir.Model.DataType) is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "item":
            if (value is not (Hl7.Fhir.Model.CodeableReference or null))
            {
              Item = OverflowNull<Hl7.Fhir.Model.CodeableReference>.INSTANCE;
              Overflow["item"] = value;
            }
            else Item = (Hl7.Fhir.Model.CodeableReference?)value!;
            return this;
          case "type":
            if (value is not (Hl7.Fhir.Model.CodeableConcept or null))
            {
              Type = OverflowNull<Hl7.Fhir.Model.CodeableConcept>.INSTANCE;
              Overflow["type"] = value;
            }
            else Type = (Hl7.Fhir.Model.CodeableConcept?)value;
            return this;
          case "strength":
            if (value is not (Hl7.Fhir.Model.DataType or null))
            {
              Strength = OverflowNull<DynamicDataType>.INSTANCE;
              Overflow["strength"] = value;
            }
            else Strength = (Hl7.Fhir.Model.DataType?)value;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_Item is not null && !_Item.InOverflow<Hl7.Fhir.Model.CodeableReference>()) yield return new KeyValuePair<string,object>("item",_Item);
        if (_Type is not null && !_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>()) yield return new KeyValuePair<string,object>("type",_Type);
        if (_Strength is not null && !_Strength.InOverflow<DynamicDataType>()) yield return new KeyValuePair<string,object>("strength",_Strength);
      }

    }

    /// <summary>
    /// Specifies descriptive properties of the medicine
    /// </summary>
    /// <remarks>
    /// Specifies descriptive properties of the medicine, such as color, shape, imprints, etc.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("MedicationKnowledge.definitional.drugCharacteristic", IsBackboneType=true)]
    public partial class DrugCharacteristicComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "MedicationKnowledge.definitional.drugCharacteristic";

      /// <summary>
      /// Code specifying the type of characteristic of medication.
      /// </summary>
      [FhirElement("type", Order=40)]
      [Binding("MedicationCharacteristic")]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept? Type
      {
        get
        {
          if(_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.CodeableConcept), Overflow["type"]);
          return _Type;
        }

        set
        {
          if (_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            Overflow.Remove("type");
          _Type = value;
          OnPropertyChanged("Type");
        }

      }

      private Hl7.Fhir.Model.CodeableConcept? _Type;

      /// <summary>
      /// Description of the characteristic.
      /// </summary>
      [FhirElement("value", Order=50, Choice=ChoiceType.DatatypeChoice)]
      [CLSCompliant(false)]
      [AllowedTypes(typeof(Hl7.Fhir.Model.CodeableConcept),typeof(Hl7.Fhir.Model.FhirString),typeof(Hl7.Fhir.Model.Quantity),typeof(Hl7.Fhir.Model.Base64Binary),typeof(Hl7.Fhir.Model.Attachment))]
      [DataMember]
      public Hl7.Fhir.Model.DataType? Value
      {
        get
        {
          if(_Value.InOverflow<DynamicDataType>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.DataType), Overflow["value"]);
          return _Value;
        }

        set
        {
          if (_Value.InOverflow<DynamicDataType>())
            Overflow.Remove("value");
          _Value = value;
          OnPropertyChanged("Value");
        }

      }

      private Hl7.Fhir.Model.DataType? _Value;

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not DrugCharacteristicComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_Type is not null) dest.Type = (Hl7.Fhir.Model.CodeableConcept)_Type.DeepCopyInternal();
        if(_Value is not null) dest.Value = (Hl7.Fhir.Model.DataType)_Value.DeepCopyInternal();
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new DrugCharacteristicComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not DrugCharacteristicComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_Type, otherT._Type)) return false;
        if(!comparer.Equals(_Value, otherT._Value)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "type":
            if (_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            {
              value = Overflow["type"];
              return true;
            }
            value = _Type;
            return (value as Hl7.Fhir.Model.CodeableConcept) is not null;
          case "value":
            if (_Value.InOverflow<DynamicDataType>())
            {
              value = Overflow["value"];
              return true;
            }
            value = _Value;
            return (value as Hl7.Fhir.Model.DataType) is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "type":
            if (value is not (Hl7.Fhir.Model.CodeableConcept or null))
            {
              Type = OverflowNull<Hl7.Fhir.Model.CodeableConcept>.INSTANCE;
              Overflow["type"] = value;
            }
            else Type = (Hl7.Fhir.Model.CodeableConcept?)value;
            return this;
          case "value":
            if (value is not (Hl7.Fhir.Model.DataType or null))
            {
              Value = OverflowNull<DynamicDataType>.INSTANCE;
              Overflow["value"] = value;
            }
            else Value = (Hl7.Fhir.Model.DataType?)value;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_Type is not null && !_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>()) yield return new KeyValuePair<string,object>("type",_Type);
        if (_Value is not null && !_Value.InOverflow<DynamicDataType>()) yield return new KeyValuePair<string,object>("value",_Value);
      }

    }

    /// <summary>
    /// Business identifier for this medication.
    /// </summary>
    [FhirElement("identifier", InSummary=true, Order=90)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Hl7.Fhir.Model.Identifier> Identifier
    {
      get
      {
        if(_Identifier.InOverflow<List<Hl7.Fhir.Model.Identifier>>())
          throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.Identifier>), Overflow["identifier"]);
        return _Identifier ??= [];
      }

      set
      {
        if (_Identifier.InOverflow<List<Hl7.Fhir.Model.Identifier>>())
          Overflow.Remove("identifier");
        _Identifier = value;
        OnPropertyChanged("Identifier");
      }

    }

    private List<Hl7.Fhir.Model.Identifier>? _Identifier;

    /// <summary>
    /// Code that identifies this medication.
    /// </summary>
    [FhirElement("code", InSummary=true, Order=100, FiveWs="FiveWs.class")]
    [Binding("MedicationFormalRepresentation")]
    [DataMember]
    public Hl7.Fhir.Model.CodeableConcept? Code
    {
      get
      {
        if(_Code.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.CodeableConcept), Overflow["code"]);
        return _Code;
      }

      set
      {
        if (_Code.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
          Overflow.Remove("code");
        _Code = value;
        OnPropertyChanged("Code");
      }

    }

    private Hl7.Fhir.Model.CodeableConcept? _Code;

    /// <summary>
    /// active | entered-in-error | inactive.
    /// </summary>
    [FhirElement("status", InSummary=true, IsModifier=true, Order=110)]
    [Binding("MedicationKnowledgeStatus")]
    [DataMember]
    public Code<Hl7.Fhir.Model.MedicationKnowledge.MedicationKnowledgeStatusCodes>? StatusElement
    {
      get
      {
        if(_StatusElement.InOverflow<Code<Hl7.Fhir.Model.MedicationKnowledge.MedicationKnowledgeStatusCodes>>())
          throw CodedValidationException.FromTypes(typeof(Code<Hl7.Fhir.Model.MedicationKnowledge.MedicationKnowledgeStatusCodes>), Overflow["status"]);
        return _StatusElement;
      }

      set
      {
        if (_StatusElement.InOverflow<Code<Hl7.Fhir.Model.MedicationKnowledge.MedicationKnowledgeStatusCodes>>())
          Overflow.Remove("status");
        _StatusElement = value;
        OnPropertyChanged("StatusElement");
      }

    }

    private Code<Hl7.Fhir.Model.MedicationKnowledge.MedicationKnowledgeStatusCodes>? _StatusElement;

    /// <summary>
    /// active | entered-in-error | inactive
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public Hl7.Fhir.Model.MedicationKnowledge.MedicationKnowledgeStatusCodes? Status
    {
      get => StatusElement?.Value;
      set
      {
        StatusElement = value is null ? null! : new Code<Hl7.Fhir.Model.MedicationKnowledge.MedicationKnowledgeStatusCodes>(value);
        OnPropertyChanged("Status");
      }
    }

    /// <summary>
    /// Creator or owner of the knowledge or information about the medication.
    /// </summary>
    [FhirElement("author", Order=120, FiveWs="FiveWs.actor")]
    [CLSCompliant(false)]
    [References("Organization")]
    [DataMember]
    public Hl7.Fhir.Model.ResourceReference? Author
    {
      get
      {
        if(_Author.InOverflow<Hl7.Fhir.Model.ResourceReference>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.ResourceReference), Overflow["author"]);
        return _Author;
      }

      set
      {
        if (_Author.InOverflow<Hl7.Fhir.Model.ResourceReference>())
          Overflow.Remove("author");
        _Author = value;
        OnPropertyChanged("Author");
      }

    }

    private Hl7.Fhir.Model.ResourceReference? _Author;

    /// <summary>
    /// Codes that identify the different jurisdictions for which the information of this resource was created.
    /// </summary>
    [FhirElement("intendedJurisdiction", Order=130)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Hl7.Fhir.Model.CodeableConcept> IntendedJurisdiction
    {
      get
      {
        if(_IntendedJurisdiction.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>())
          throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.CodeableConcept>), Overflow["intendedJurisdiction"]);
        return _IntendedJurisdiction ??= [];
      }

      set
      {
        if (_IntendedJurisdiction.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>())
          Overflow.Remove("intendedJurisdiction");
        _IntendedJurisdiction = value;
        OnPropertyChanged("IntendedJurisdiction");
      }

    }

    private List<Hl7.Fhir.Model.CodeableConcept>? _IntendedJurisdiction;

    /// <summary>
    /// A name associated with the medication being described.
    /// </summary>
    [FhirElement("name", InSummary=true, Order=140)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Hl7.Fhir.Model.FhirString> NameElement
    {
      get
      {
        if(_NameElement.InOverflow<List<Hl7.Fhir.Model.FhirString>>())
          throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.FhirString>), Overflow["name"]);
        return _NameElement ??= [];
      }

      set
      {
        if (_NameElement.InOverflow<List<Hl7.Fhir.Model.FhirString>>())
          Overflow.Remove("name");
        _NameElement = value;
        OnPropertyChanged("NameElement");
      }

    }

    private List<Hl7.Fhir.Model.FhirString>? _NameElement;

    /// <summary>
    /// A name associated with the medication being described
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public IEnumerable<string?> Name
    {
      get => _NameElement?.Select(elem => elem.Value) ?? [];
      set
      {
        if (value == null)
          NameElement = null!;
        else
          NameElement = new List<Hl7.Fhir.Model.FhirString>(value.Select(elem=>new Hl7.Fhir.Model.FhirString(elem)));
        OnPropertyChanged("Name");
      }
    }

    /// <summary>
    /// Associated or related medication information.
    /// </summary>
    [FhirElement("relatedMedicationKnowledge", Order=150)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Hl7.Fhir.Model.MedicationKnowledge.RelatedMedicationKnowledgeComponent> RelatedMedicationKnowledge
    {
      get
      {
        if(_RelatedMedicationKnowledge.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.RelatedMedicationKnowledgeComponent>>())
          throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.MedicationKnowledge.RelatedMedicationKnowledgeComponent>), Overflow["relatedMedicationKnowledge"]);
        return _RelatedMedicationKnowledge ??= [];
      }

      set
      {
        if (_RelatedMedicationKnowledge.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.RelatedMedicationKnowledgeComponent>>())
          Overflow.Remove("relatedMedicationKnowledge");
        _RelatedMedicationKnowledge = value;
        OnPropertyChanged("RelatedMedicationKnowledge");
      }

    }

    private List<Hl7.Fhir.Model.MedicationKnowledge.RelatedMedicationKnowledgeComponent>? _RelatedMedicationKnowledge;

    /// <summary>
    /// The set of medication resources that are associated with this medication.
    /// </summary>
    [FhirElement("associatedMedication", Order=160)]
    [CLSCompliant(false)]
    [References("Medication")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Hl7.Fhir.Model.ResourceReference> AssociatedMedication
    {
      get
      {
        if(_AssociatedMedication.InOverflow<List<Hl7.Fhir.Model.ResourceReference>>())
          throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.ResourceReference>), Overflow["associatedMedication"]);
        return _AssociatedMedication ??= [];
      }

      set
      {
        if (_AssociatedMedication.InOverflow<List<Hl7.Fhir.Model.ResourceReference>>())
          Overflow.Remove("associatedMedication");
        _AssociatedMedication = value;
        OnPropertyChanged("AssociatedMedication");
      }

    }

    private List<Hl7.Fhir.Model.ResourceReference>? _AssociatedMedication;

    /// <summary>
    /// Category of the medication or product.
    /// </summary>
    [FhirElement("productType", Order=170)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Hl7.Fhir.Model.CodeableConcept> ProductType
    {
      get
      {
        if(_ProductType.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>())
          throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.CodeableConcept>), Overflow["productType"]);
        return _ProductType ??= [];
      }

      set
      {
        if (_ProductType.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>())
          Overflow.Remove("productType");
        _ProductType = value;
        OnPropertyChanged("ProductType");
      }

    }

    private List<Hl7.Fhir.Model.CodeableConcept>? _ProductType;

    /// <summary>
    /// Associated documentation about the medication.
    /// </summary>
    [FhirElement("monograph", Order=180)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Hl7.Fhir.Model.MedicationKnowledge.MonographComponent> Monograph
    {
      get
      {
        if(_Monograph.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.MonographComponent>>())
          throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.MedicationKnowledge.MonographComponent>), Overflow["monograph"]);
        return _Monograph ??= [];
      }

      set
      {
        if (_Monograph.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.MonographComponent>>())
          Overflow.Remove("monograph");
        _Monograph = value;
        OnPropertyChanged("Monograph");
      }

    }

    private List<Hl7.Fhir.Model.MedicationKnowledge.MonographComponent>? _Monograph;

    /// <summary>
    /// The instructions for preparing the medication.
    /// </summary>
    [FhirElement("preparationInstruction", Order=190)]
    [DataMember]
    public Hl7.Fhir.Model.Markdown? PreparationInstructionElement
    {
      get
      {
        if(_PreparationInstructionElement.InOverflow<Hl7.Fhir.Model.Markdown>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Markdown), Overflow["preparationInstruction"]);
        return _PreparationInstructionElement;
      }

      set
      {
        if (_PreparationInstructionElement.InOverflow<Hl7.Fhir.Model.Markdown>())
          Overflow.Remove("preparationInstruction");
        _PreparationInstructionElement = value;
        OnPropertyChanged("PreparationInstructionElement");
      }

    }

    private Hl7.Fhir.Model.Markdown? _PreparationInstructionElement;

    /// <summary>
    /// The instructions for preparing the medication
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string? PreparationInstruction
    {
      get => PreparationInstructionElement?.Value;
      set
      {
        PreparationInstructionElement = value is null ? null! : new Hl7.Fhir.Model.Markdown(value);
        OnPropertyChanged("PreparationInstruction");
      }
    }

    /// <summary>
    /// The pricing of the medication.
    /// </summary>
    [FhirElement("cost", Order=200)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Hl7.Fhir.Model.MedicationKnowledge.CostComponent> Cost
    {
      get
      {
        if(_Cost.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.CostComponent>>())
          throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.MedicationKnowledge.CostComponent>), Overflow["cost"]);
        return _Cost ??= [];
      }

      set
      {
        if (_Cost.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.CostComponent>>())
          Overflow.Remove("cost");
        _Cost = value;
        OnPropertyChanged("Cost");
      }

    }

    private List<Hl7.Fhir.Model.MedicationKnowledge.CostComponent>? _Cost;

    /// <summary>
    /// Program under which a medication is reviewed.
    /// </summary>
    [FhirElement("monitoringProgram", InSummary=true, Order=210)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Hl7.Fhir.Model.MedicationKnowledge.MonitoringProgramComponent> MonitoringProgram
    {
      get
      {
        if(_MonitoringProgram.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.MonitoringProgramComponent>>())
          throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.MedicationKnowledge.MonitoringProgramComponent>), Overflow["monitoringProgram"]);
        return _MonitoringProgram ??= [];
      }

      set
      {
        if (_MonitoringProgram.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.MonitoringProgramComponent>>())
          Overflow.Remove("monitoringProgram");
        _MonitoringProgram = value;
        OnPropertyChanged("MonitoringProgram");
      }

    }

    private List<Hl7.Fhir.Model.MedicationKnowledge.MonitoringProgramComponent>? _MonitoringProgram;

    /// <summary>
    /// Guidelines or protocols for administration of the medication for an indication.
    /// </summary>
    [FhirElement("indicationGuideline", Order=220)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Hl7.Fhir.Model.MedicationKnowledge.IndicationGuidelineComponent> IndicationGuideline
    {
      get
      {
        if(_IndicationGuideline.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.IndicationGuidelineComponent>>())
          throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.MedicationKnowledge.IndicationGuidelineComponent>), Overflow["indicationGuideline"]);
        return _IndicationGuideline ??= [];
      }

      set
      {
        if (_IndicationGuideline.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.IndicationGuidelineComponent>>())
          Overflow.Remove("indicationGuideline");
        _IndicationGuideline = value;
        OnPropertyChanged("IndicationGuideline");
      }

    }

    private List<Hl7.Fhir.Model.MedicationKnowledge.IndicationGuidelineComponent>? _IndicationGuideline;

    /// <summary>
    /// Categorization of the medication within a formulary or classification system.
    /// </summary>
    [FhirElement("medicineClassification", Order=230)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Hl7.Fhir.Model.MedicationKnowledge.MedicineClassificationComponent> MedicineClassification
    {
      get
      {
        if(_MedicineClassification.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.MedicineClassificationComponent>>())
          throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.MedicationKnowledge.MedicineClassificationComponent>), Overflow["medicineClassification"]);
        return _MedicineClassification ??= [];
      }

      set
      {
        if (_MedicineClassification.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.MedicineClassificationComponent>>())
          Overflow.Remove("medicineClassification");
        _MedicineClassification = value;
        OnPropertyChanged("MedicineClassification");
      }

    }

    private List<Hl7.Fhir.Model.MedicationKnowledge.MedicineClassificationComponent>? _MedicineClassification;

    /// <summary>
    /// Details about packaged medications.
    /// </summary>
    [FhirElement("packaging", Order=240)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Hl7.Fhir.Model.MedicationKnowledge.PackagingComponent> Packaging
    {
      get
      {
        if(_Packaging.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.PackagingComponent>>())
          throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.MedicationKnowledge.PackagingComponent>), Overflow["packaging"]);
        return _Packaging ??= [];
      }

      set
      {
        if (_Packaging.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.PackagingComponent>>())
          Overflow.Remove("packaging");
        _Packaging = value;
        OnPropertyChanged("Packaging");
      }

    }

    private List<Hl7.Fhir.Model.MedicationKnowledge.PackagingComponent>? _Packaging;

    /// <summary>
    /// Potential clinical issue with or between medication(s).
    /// </summary>
    [FhirElement("clinicalUseIssue", Order=250)]
    [CLSCompliant(false)]
    [References("ClinicalUseDefinition")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Hl7.Fhir.Model.ResourceReference> ClinicalUseIssue
    {
      get
      {
        if(_ClinicalUseIssue.InOverflow<List<Hl7.Fhir.Model.ResourceReference>>())
          throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.ResourceReference>), Overflow["clinicalUseIssue"]);
        return _ClinicalUseIssue ??= [];
      }

      set
      {
        if (_ClinicalUseIssue.InOverflow<List<Hl7.Fhir.Model.ResourceReference>>())
          Overflow.Remove("clinicalUseIssue");
        _ClinicalUseIssue = value;
        OnPropertyChanged("ClinicalUseIssue");
      }

    }

    private List<Hl7.Fhir.Model.ResourceReference>? _ClinicalUseIssue;

    /// <summary>
    /// How the medication should be stored.
    /// </summary>
    [FhirElement("storageGuideline", Order=260)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Hl7.Fhir.Model.MedicationKnowledge.StorageGuidelineComponent> StorageGuideline
    {
      get
      {
        if(_StorageGuideline.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.StorageGuidelineComponent>>())
          throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.MedicationKnowledge.StorageGuidelineComponent>), Overflow["storageGuideline"]);
        return _StorageGuideline ??= [];
      }

      set
      {
        if (_StorageGuideline.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.StorageGuidelineComponent>>())
          Overflow.Remove("storageGuideline");
        _StorageGuideline = value;
        OnPropertyChanged("StorageGuideline");
      }

    }

    private List<Hl7.Fhir.Model.MedicationKnowledge.StorageGuidelineComponent>? _StorageGuideline;

    /// <summary>
    /// Regulatory information about a medication.
    /// </summary>
    [FhirElement("regulatory", Order=270)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Hl7.Fhir.Model.MedicationKnowledge.RegulatoryComponent> Regulatory
    {
      get
      {
        if(_Regulatory.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.RegulatoryComponent>>())
          throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.MedicationKnowledge.RegulatoryComponent>), Overflow["regulatory"]);
        return _Regulatory ??= [];
      }

      set
      {
        if (_Regulatory.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.RegulatoryComponent>>())
          Overflow.Remove("regulatory");
        _Regulatory = value;
        OnPropertyChanged("Regulatory");
      }

    }

    private List<Hl7.Fhir.Model.MedicationKnowledge.RegulatoryComponent>? _Regulatory;

    /// <summary>
    /// Minimal definition information about the medication.
    /// </summary>
    [FhirElement("definitional", Order=280)]
    [DataMember]
    public Hl7.Fhir.Model.MedicationKnowledge.DefinitionalComponent? Definitional
    {
      get
      {
        if(_Definitional.InOverflow<Hl7.Fhir.Model.MedicationKnowledge.DefinitionalComponent>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.MedicationKnowledge.DefinitionalComponent), Overflow["definitional"]);
        return _Definitional;
      }

      set
      {
        if (_Definitional.InOverflow<Hl7.Fhir.Model.MedicationKnowledge.DefinitionalComponent>())
          Overflow.Remove("definitional");
        _Definitional = value;
        OnPropertyChanged("Definitional");
      }

    }

    private Hl7.Fhir.Model.MedicationKnowledge.DefinitionalComponent? _Definitional;

    List<Identifier> IIdentifiable<List<Identifier>>.Identifier { get => Identifier; set => Identifier = value!; }

    protected internal override void CopyToInternal(Base other)
    {
      if(other is not MedicationKnowledge dest)
        throw new ArgumentException("Can only copy to an object of the same type", "other");

      base.CopyToInternal(dest);
      if(_Identifier is not null) dest.Identifier = new List<Hl7.Fhir.Model.Identifier>(_Identifier.DeepCopyInternal());
      if(_Code is not null) dest.Code = (Hl7.Fhir.Model.CodeableConcept)_Code.DeepCopyInternal();
      if(_StatusElement is not null) dest.StatusElement = (Code<Hl7.Fhir.Model.MedicationKnowledge.MedicationKnowledgeStatusCodes>)_StatusElement.DeepCopyInternal();
      if(_Author is not null) dest.Author = (Hl7.Fhir.Model.ResourceReference)_Author.DeepCopyInternal();
      if(_IntendedJurisdiction is not null) dest.IntendedJurisdiction = new List<Hl7.Fhir.Model.CodeableConcept>(_IntendedJurisdiction.DeepCopyInternal());
      if(_NameElement is not null) dest.NameElement = new List<Hl7.Fhir.Model.FhirString>(_NameElement.DeepCopyInternal());
      if(_RelatedMedicationKnowledge is not null) dest.RelatedMedicationKnowledge = new List<Hl7.Fhir.Model.MedicationKnowledge.RelatedMedicationKnowledgeComponent>(_RelatedMedicationKnowledge.DeepCopyInternal());
      if(_AssociatedMedication is not null) dest.AssociatedMedication = new List<Hl7.Fhir.Model.ResourceReference>(_AssociatedMedication.DeepCopyInternal());
      if(_ProductType is not null) dest.ProductType = new List<Hl7.Fhir.Model.CodeableConcept>(_ProductType.DeepCopyInternal());
      if(_Monograph is not null) dest.Monograph = new List<Hl7.Fhir.Model.MedicationKnowledge.MonographComponent>(_Monograph.DeepCopyInternal());
      if(_PreparationInstructionElement is not null) dest.PreparationInstructionElement = (Hl7.Fhir.Model.Markdown)_PreparationInstructionElement.DeepCopyInternal();
      if(_Cost is not null) dest.Cost = new List<Hl7.Fhir.Model.MedicationKnowledge.CostComponent>(_Cost.DeepCopyInternal());
      if(_MonitoringProgram is not null) dest.MonitoringProgram = new List<Hl7.Fhir.Model.MedicationKnowledge.MonitoringProgramComponent>(_MonitoringProgram.DeepCopyInternal());
      if(_IndicationGuideline is not null) dest.IndicationGuideline = new List<Hl7.Fhir.Model.MedicationKnowledge.IndicationGuidelineComponent>(_IndicationGuideline.DeepCopyInternal());
      if(_MedicineClassification is not null) dest.MedicineClassification = new List<Hl7.Fhir.Model.MedicationKnowledge.MedicineClassificationComponent>(_MedicineClassification.DeepCopyInternal());
      if(_Packaging is not null) dest.Packaging = new List<Hl7.Fhir.Model.MedicationKnowledge.PackagingComponent>(_Packaging.DeepCopyInternal());
      if(_ClinicalUseIssue is not null) dest.ClinicalUseIssue = new List<Hl7.Fhir.Model.ResourceReference>(_ClinicalUseIssue.DeepCopyInternal());
      if(_StorageGuideline is not null) dest.StorageGuideline = new List<Hl7.Fhir.Model.MedicationKnowledge.StorageGuidelineComponent>(_StorageGuideline.DeepCopyInternal());
      if(_Regulatory is not null) dest.Regulatory = new List<Hl7.Fhir.Model.MedicationKnowledge.RegulatoryComponent>(_Regulatory.DeepCopyInternal());
      if(_Definitional is not null) dest.Definitional = (Hl7.Fhir.Model.MedicationKnowledge.DefinitionalComponent)_Definitional.DeepCopyInternal();
    }

    protected internal override Base DeepCopyInternal()
    {
      var instance = new MedicationKnowledge();
      CopyToInternal(instance);
      return instance;
    }

    public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
    {
      if(other is not MedicationKnowledge otherT) return false;

      if(!base.CompareChildren(otherT, comparer)) return false;
      #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
      if(!comparer.ListEquals(_Identifier, otherT._Identifier)) return false;
      if(!comparer.Equals(_Code, otherT._Code)) return false;
      if(!comparer.Equals(_StatusElement, otherT._StatusElement)) return false;
      if(!comparer.Equals(_Author, otherT._Author)) return false;
      if(!comparer.ListEquals(_IntendedJurisdiction, otherT._IntendedJurisdiction)) return false;
      if(!comparer.ListEquals(_NameElement, otherT._NameElement)) return false;
      if(!comparer.ListEquals(_RelatedMedicationKnowledge, otherT._RelatedMedicationKnowledge)) return false;
      if(!comparer.ListEquals(_AssociatedMedication, otherT._AssociatedMedication)) return false;
      if(!comparer.ListEquals(_ProductType, otherT._ProductType)) return false;
      if(!comparer.ListEquals(_Monograph, otherT._Monograph)) return false;
      if(!comparer.Equals(_PreparationInstructionElement, otherT._PreparationInstructionElement)) return false;
      if(!comparer.ListEquals(_Cost, otherT._Cost)) return false;
      if(!comparer.ListEquals(_MonitoringProgram, otherT._MonitoringProgram)) return false;
      if(!comparer.ListEquals(_IndicationGuideline, otherT._IndicationGuideline)) return false;
      if(!comparer.ListEquals(_MedicineClassification, otherT._MedicineClassification)) return false;
      if(!comparer.ListEquals(_Packaging, otherT._Packaging)) return false;
      if(!comparer.ListEquals(_ClinicalUseIssue, otherT._ClinicalUseIssue)) return false;
      if(!comparer.ListEquals(_StorageGuideline, otherT._StorageGuideline)) return false;
      if(!comparer.ListEquals(_Regulatory, otherT._Regulatory)) return false;
      if(!comparer.Equals(_Definitional, otherT._Definitional)) return false;
      #pragma warning restore CS8604 // Possible null reference argument.

      return true;
    }

    public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
    {
      switch (key)
      {
        case "identifier":
          if (_Identifier.InOverflow<List<Hl7.Fhir.Model.Identifier>>())
          {
            value = Overflow["identifier"];
            return true;
          }
          value = _Identifier;
          return (value as List<Hl7.Fhir.Model.Identifier>)?.Any() is true;
        case "code":
          if (_Code.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
          {
            value = Overflow["code"];
            return true;
          }
          value = _Code;
          return (value as Hl7.Fhir.Model.CodeableConcept) is not null;
        case "status":
          if (_StatusElement.InOverflow<Code<Hl7.Fhir.Model.MedicationKnowledge.MedicationKnowledgeStatusCodes>>())
          {
            value = Overflow["status"];
            return true;
          }
          value = _StatusElement;
          return (value as Code<Hl7.Fhir.Model.MedicationKnowledge.MedicationKnowledgeStatusCodes>) is not null;
        case "author":
          if (_Author.InOverflow<Hl7.Fhir.Model.ResourceReference>())
          {
            value = Overflow["author"];
            return true;
          }
          value = _Author;
          return (value as Hl7.Fhir.Model.ResourceReference) is not null;
        case "intendedJurisdiction":
          if (_IntendedJurisdiction.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>())
          {
            value = Overflow["intendedJurisdiction"];
            return true;
          }
          value = _IntendedJurisdiction;
          return (value as List<Hl7.Fhir.Model.CodeableConcept>)?.Any() is true;
        case "name":
          if (_NameElement.InOverflow<List<Hl7.Fhir.Model.FhirString>>())
          {
            value = Overflow["name"];
            return true;
          }
          value = _NameElement;
          return (value as List<Hl7.Fhir.Model.FhirString>)?.Any() is true;
        case "relatedMedicationKnowledge":
          if (_RelatedMedicationKnowledge.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.RelatedMedicationKnowledgeComponent>>())
          {
            value = Overflow["relatedMedicationKnowledge"];
            return true;
          }
          value = _RelatedMedicationKnowledge;
          return (value as List<Hl7.Fhir.Model.MedicationKnowledge.RelatedMedicationKnowledgeComponent>)?.Any() is true;
        case "associatedMedication":
          if (_AssociatedMedication.InOverflow<List<Hl7.Fhir.Model.ResourceReference>>())
          {
            value = Overflow["associatedMedication"];
            return true;
          }
          value = _AssociatedMedication;
          return (value as List<Hl7.Fhir.Model.ResourceReference>)?.Any() is true;
        case "productType":
          if (_ProductType.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>())
          {
            value = Overflow["productType"];
            return true;
          }
          value = _ProductType;
          return (value as List<Hl7.Fhir.Model.CodeableConcept>)?.Any() is true;
        case "monograph":
          if (_Monograph.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.MonographComponent>>())
          {
            value = Overflow["monograph"];
            return true;
          }
          value = _Monograph;
          return (value as List<Hl7.Fhir.Model.MedicationKnowledge.MonographComponent>)?.Any() is true;
        case "preparationInstruction":
          if (_PreparationInstructionElement.InOverflow<Hl7.Fhir.Model.Markdown>())
          {
            value = Overflow["preparationInstruction"];
            return true;
          }
          value = _PreparationInstructionElement;
          return (value as Hl7.Fhir.Model.Markdown) is not null;
        case "cost":
          if (_Cost.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.CostComponent>>())
          {
            value = Overflow["cost"];
            return true;
          }
          value = _Cost;
          return (value as List<Hl7.Fhir.Model.MedicationKnowledge.CostComponent>)?.Any() is true;
        case "monitoringProgram":
          if (_MonitoringProgram.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.MonitoringProgramComponent>>())
          {
            value = Overflow["monitoringProgram"];
            return true;
          }
          value = _MonitoringProgram;
          return (value as List<Hl7.Fhir.Model.MedicationKnowledge.MonitoringProgramComponent>)?.Any() is true;
        case "indicationGuideline":
          if (_IndicationGuideline.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.IndicationGuidelineComponent>>())
          {
            value = Overflow["indicationGuideline"];
            return true;
          }
          value = _IndicationGuideline;
          return (value as List<Hl7.Fhir.Model.MedicationKnowledge.IndicationGuidelineComponent>)?.Any() is true;
        case "medicineClassification":
          if (_MedicineClassification.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.MedicineClassificationComponent>>())
          {
            value = Overflow["medicineClassification"];
            return true;
          }
          value = _MedicineClassification;
          return (value as List<Hl7.Fhir.Model.MedicationKnowledge.MedicineClassificationComponent>)?.Any() is true;
        case "packaging":
          if (_Packaging.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.PackagingComponent>>())
          {
            value = Overflow["packaging"];
            return true;
          }
          value = _Packaging;
          return (value as List<Hl7.Fhir.Model.MedicationKnowledge.PackagingComponent>)?.Any() is true;
        case "clinicalUseIssue":
          if (_ClinicalUseIssue.InOverflow<List<Hl7.Fhir.Model.ResourceReference>>())
          {
            value = Overflow["clinicalUseIssue"];
            return true;
          }
          value = _ClinicalUseIssue;
          return (value as List<Hl7.Fhir.Model.ResourceReference>)?.Any() is true;
        case "storageGuideline":
          if (_StorageGuideline.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.StorageGuidelineComponent>>())
          {
            value = Overflow["storageGuideline"];
            return true;
          }
          value = _StorageGuideline;
          return (value as List<Hl7.Fhir.Model.MedicationKnowledge.StorageGuidelineComponent>)?.Any() is true;
        case "regulatory":
          if (_Regulatory.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.RegulatoryComponent>>())
          {
            value = Overflow["regulatory"];
            return true;
          }
          value = _Regulatory;
          return (value as List<Hl7.Fhir.Model.MedicationKnowledge.RegulatoryComponent>)?.Any() is true;
        case "definitional":
          if (_Definitional.InOverflow<Hl7.Fhir.Model.MedicationKnowledge.DefinitionalComponent>())
          {
            value = Overflow["definitional"];
            return true;
          }
          value = _Definitional;
          return (value as Hl7.Fhir.Model.MedicationKnowledge.DefinitionalComponent) is not null;
        default:
          return base.TryGetValue(key, out value);
      }

    }

    public override Base SetValue(string key, object? value)
    {
      if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
      switch (key)
      {
        case "identifier":
          if (value is not (List<Hl7.Fhir.Model.Identifier> or null))
          {
            Identifier = OverflowNull<List<Hl7.Fhir.Model.Identifier>>.INSTANCE;
            Overflow["identifier"] = value;
          }
          else Identifier = (List<Hl7.Fhir.Model.Identifier>?)value!;
          return this;
        case "code":
          if (value is not (Hl7.Fhir.Model.CodeableConcept or null))
          {
            Code = OverflowNull<Hl7.Fhir.Model.CodeableConcept>.INSTANCE;
            Overflow["code"] = value;
          }
          else Code = (Hl7.Fhir.Model.CodeableConcept?)value;
          return this;
        case "status":
          if (value is not (Code<Hl7.Fhir.Model.MedicationKnowledge.MedicationKnowledgeStatusCodes> or null))
          {
            StatusElement = OverflowNull<Code<Hl7.Fhir.Model.MedicationKnowledge.MedicationKnowledgeStatusCodes>>.INSTANCE;
            Overflow["status"] = value;
          }
          else StatusElement = (Code<Hl7.Fhir.Model.MedicationKnowledge.MedicationKnowledgeStatusCodes>?)value;
          return this;
        case "author":
          if (value is not (Hl7.Fhir.Model.ResourceReference or null))
          {
            Author = OverflowNull<Hl7.Fhir.Model.ResourceReference>.INSTANCE;
            Overflow["author"] = value;
          }
          else Author = (Hl7.Fhir.Model.ResourceReference?)value;
          return this;
        case "intendedJurisdiction":
          if (value is not (List<Hl7.Fhir.Model.CodeableConcept> or null))
          {
            IntendedJurisdiction = OverflowNull<List<Hl7.Fhir.Model.CodeableConcept>>.INSTANCE;
            Overflow["intendedJurisdiction"] = value;
          }
          else IntendedJurisdiction = (List<Hl7.Fhir.Model.CodeableConcept>?)value!;
          return this;
        case "name":
          if (value is not (List<Hl7.Fhir.Model.FhirString> or null))
          {
            NameElement = OverflowNull<List<Hl7.Fhir.Model.FhirString>>.INSTANCE;
            Overflow["name"] = value;
          }
          else NameElement = (List<Hl7.Fhir.Model.FhirString>?)value!;
          return this;
        case "relatedMedicationKnowledge":
          if (value is not (List<Hl7.Fhir.Model.MedicationKnowledge.RelatedMedicationKnowledgeComponent> or null))
          {
            RelatedMedicationKnowledge = OverflowNull<List<Hl7.Fhir.Model.MedicationKnowledge.RelatedMedicationKnowledgeComponent>>.INSTANCE;
            Overflow["relatedMedicationKnowledge"] = value;
          }
          else RelatedMedicationKnowledge = (List<Hl7.Fhir.Model.MedicationKnowledge.RelatedMedicationKnowledgeComponent>?)value!;
          return this;
        case "associatedMedication":
          if (value is not (List<Hl7.Fhir.Model.ResourceReference> or null))
          {
            AssociatedMedication = OverflowNull<List<Hl7.Fhir.Model.ResourceReference>>.INSTANCE;
            Overflow["associatedMedication"] = value;
          }
          else AssociatedMedication = (List<Hl7.Fhir.Model.ResourceReference>?)value!;
          return this;
        case "productType":
          if (value is not (List<Hl7.Fhir.Model.CodeableConcept> or null))
          {
            ProductType = OverflowNull<List<Hl7.Fhir.Model.CodeableConcept>>.INSTANCE;
            Overflow["productType"] = value;
          }
          else ProductType = (List<Hl7.Fhir.Model.CodeableConcept>?)value!;
          return this;
        case "monograph":
          if (value is not (List<Hl7.Fhir.Model.MedicationKnowledge.MonographComponent> or null))
          {
            Monograph = OverflowNull<List<Hl7.Fhir.Model.MedicationKnowledge.MonographComponent>>.INSTANCE;
            Overflow["monograph"] = value;
          }
          else Monograph = (List<Hl7.Fhir.Model.MedicationKnowledge.MonographComponent>?)value!;
          return this;
        case "preparationInstruction":
          if (value is not (Hl7.Fhir.Model.Markdown or null))
          {
            PreparationInstructionElement = OverflowNull<Hl7.Fhir.Model.Markdown>.INSTANCE;
            Overflow["preparationInstruction"] = value;
          }
          else PreparationInstructionElement = (Hl7.Fhir.Model.Markdown?)value;
          return this;
        case "cost":
          if (value is not (List<Hl7.Fhir.Model.MedicationKnowledge.CostComponent> or null))
          {
            Cost = OverflowNull<List<Hl7.Fhir.Model.MedicationKnowledge.CostComponent>>.INSTANCE;
            Overflow["cost"] = value;
          }
          else Cost = (List<Hl7.Fhir.Model.MedicationKnowledge.CostComponent>?)value!;
          return this;
        case "monitoringProgram":
          if (value is not (List<Hl7.Fhir.Model.MedicationKnowledge.MonitoringProgramComponent> or null))
          {
            MonitoringProgram = OverflowNull<List<Hl7.Fhir.Model.MedicationKnowledge.MonitoringProgramComponent>>.INSTANCE;
            Overflow["monitoringProgram"] = value;
          }
          else MonitoringProgram = (List<Hl7.Fhir.Model.MedicationKnowledge.MonitoringProgramComponent>?)value!;
          return this;
        case "indicationGuideline":
          if (value is not (List<Hl7.Fhir.Model.MedicationKnowledge.IndicationGuidelineComponent> or null))
          {
            IndicationGuideline = OverflowNull<List<Hl7.Fhir.Model.MedicationKnowledge.IndicationGuidelineComponent>>.INSTANCE;
            Overflow["indicationGuideline"] = value;
          }
          else IndicationGuideline = (List<Hl7.Fhir.Model.MedicationKnowledge.IndicationGuidelineComponent>?)value!;
          return this;
        case "medicineClassification":
          if (value is not (List<Hl7.Fhir.Model.MedicationKnowledge.MedicineClassificationComponent> or null))
          {
            MedicineClassification = OverflowNull<List<Hl7.Fhir.Model.MedicationKnowledge.MedicineClassificationComponent>>.INSTANCE;
            Overflow["medicineClassification"] = value;
          }
          else MedicineClassification = (List<Hl7.Fhir.Model.MedicationKnowledge.MedicineClassificationComponent>?)value!;
          return this;
        case "packaging":
          if (value is not (List<Hl7.Fhir.Model.MedicationKnowledge.PackagingComponent> or null))
          {
            Packaging = OverflowNull<List<Hl7.Fhir.Model.MedicationKnowledge.PackagingComponent>>.INSTANCE;
            Overflow["packaging"] = value;
          }
          else Packaging = (List<Hl7.Fhir.Model.MedicationKnowledge.PackagingComponent>?)value!;
          return this;
        case "clinicalUseIssue":
          if (value is not (List<Hl7.Fhir.Model.ResourceReference> or null))
          {
            ClinicalUseIssue = OverflowNull<List<Hl7.Fhir.Model.ResourceReference>>.INSTANCE;
            Overflow["clinicalUseIssue"] = value;
          }
          else ClinicalUseIssue = (List<Hl7.Fhir.Model.ResourceReference>?)value!;
          return this;
        case "storageGuideline":
          if (value is not (List<Hl7.Fhir.Model.MedicationKnowledge.StorageGuidelineComponent> or null))
          {
            StorageGuideline = OverflowNull<List<Hl7.Fhir.Model.MedicationKnowledge.StorageGuidelineComponent>>.INSTANCE;
            Overflow["storageGuideline"] = value;
          }
          else StorageGuideline = (List<Hl7.Fhir.Model.MedicationKnowledge.StorageGuidelineComponent>?)value!;
          return this;
        case "regulatory":
          if (value is not (List<Hl7.Fhir.Model.MedicationKnowledge.RegulatoryComponent> or null))
          {
            Regulatory = OverflowNull<List<Hl7.Fhir.Model.MedicationKnowledge.RegulatoryComponent>>.INSTANCE;
            Overflow["regulatory"] = value;
          }
          else Regulatory = (List<Hl7.Fhir.Model.MedicationKnowledge.RegulatoryComponent>?)value!;
          return this;
        case "definitional":
          if (value is not (Hl7.Fhir.Model.MedicationKnowledge.DefinitionalComponent or null))
          {
            Definitional = OverflowNull<Hl7.Fhir.Model.MedicationKnowledge.DefinitionalComponent>.INSTANCE;
            Overflow["definitional"] = value;
          }
          else Definitional = (Hl7.Fhir.Model.MedicationKnowledge.DefinitionalComponent?)value;
          return this;
        default:
          return base.SetValue(key, value);
      }

    }

    public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
    {
      foreach (var kvp in base.EnumerateElements()) yield return kvp;
      if (_Identifier?.Any() is true && !_Identifier.InOverflow<List<Hl7.Fhir.Model.Identifier>>()) yield return new KeyValuePair<string,object>("identifier",_Identifier);
      if (_Code is not null && !_Code.InOverflow<Hl7.Fhir.Model.CodeableConcept>()) yield return new KeyValuePair<string,object>("code",_Code);
      if (_StatusElement is not null && !_StatusElement.InOverflow<Code<Hl7.Fhir.Model.MedicationKnowledge.MedicationKnowledgeStatusCodes>>()) yield return new KeyValuePair<string,object>("status",_StatusElement);
      if (_Author is not null && !_Author.InOverflow<Hl7.Fhir.Model.ResourceReference>()) yield return new KeyValuePair<string,object>("author",_Author);
      if (_IntendedJurisdiction?.Any() is true && !_IntendedJurisdiction.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>()) yield return new KeyValuePair<string,object>("intendedJurisdiction",_IntendedJurisdiction);
      if (_NameElement?.Any() is true && !_NameElement.InOverflow<List<Hl7.Fhir.Model.FhirString>>()) yield return new KeyValuePair<string,object>("name",_NameElement);
      if (_RelatedMedicationKnowledge?.Any() is true && !_RelatedMedicationKnowledge.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.RelatedMedicationKnowledgeComponent>>()) yield return new KeyValuePair<string,object>("relatedMedicationKnowledge",_RelatedMedicationKnowledge);
      if (_AssociatedMedication?.Any() is true && !_AssociatedMedication.InOverflow<List<Hl7.Fhir.Model.ResourceReference>>()) yield return new KeyValuePair<string,object>("associatedMedication",_AssociatedMedication);
      if (_ProductType?.Any() is true && !_ProductType.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>()) yield return new KeyValuePair<string,object>("productType",_ProductType);
      if (_Monograph?.Any() is true && !_Monograph.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.MonographComponent>>()) yield return new KeyValuePair<string,object>("monograph",_Monograph);
      if (_PreparationInstructionElement is not null && !_PreparationInstructionElement.InOverflow<Hl7.Fhir.Model.Markdown>()) yield return new KeyValuePair<string,object>("preparationInstruction",_PreparationInstructionElement);
      if (_Cost?.Any() is true && !_Cost.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.CostComponent>>()) yield return new KeyValuePair<string,object>("cost",_Cost);
      if (_MonitoringProgram?.Any() is true && !_MonitoringProgram.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.MonitoringProgramComponent>>()) yield return new KeyValuePair<string,object>("monitoringProgram",_MonitoringProgram);
      if (_IndicationGuideline?.Any() is true && !_IndicationGuideline.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.IndicationGuidelineComponent>>()) yield return new KeyValuePair<string,object>("indicationGuideline",_IndicationGuideline);
      if (_MedicineClassification?.Any() is true && !_MedicineClassification.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.MedicineClassificationComponent>>()) yield return new KeyValuePair<string,object>("medicineClassification",_MedicineClassification);
      if (_Packaging?.Any() is true && !_Packaging.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.PackagingComponent>>()) yield return new KeyValuePair<string,object>("packaging",_Packaging);
      if (_ClinicalUseIssue?.Any() is true && !_ClinicalUseIssue.InOverflow<List<Hl7.Fhir.Model.ResourceReference>>()) yield return new KeyValuePair<string,object>("clinicalUseIssue",_ClinicalUseIssue);
      if (_StorageGuideline?.Any() is true && !_StorageGuideline.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.StorageGuidelineComponent>>()) yield return new KeyValuePair<string,object>("storageGuideline",_StorageGuideline);
      if (_Regulatory?.Any() is true && !_Regulatory.InOverflow<List<Hl7.Fhir.Model.MedicationKnowledge.RegulatoryComponent>>()) yield return new KeyValuePair<string,object>("regulatory",_Regulatory);
      if (_Definitional is not null && !_Definitional.InOverflow<Hl7.Fhir.Model.MedicationKnowledge.DefinitionalComponent>()) yield return new KeyValuePair<string,object>("definitional",_Definitional);
    }

  }

}

// end of file
