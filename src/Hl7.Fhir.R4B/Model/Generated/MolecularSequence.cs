// <auto-generated/>
// Contents of: hl7.fhir.r4b.expansions@4.3.0, hl7.fhir.r4b.core@4.3.0

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using Hl7.Fhir.Introspection;
using Hl7.Fhir.Serialization;
using Hl7.Fhir.Specification;
using Hl7.Fhir.Utility;
using Hl7.Fhir.Validation;
using System.Diagnostics.CodeAnalysis;
using SystemPrimitive = Hl7.Fhir.ElementModel.Types;

#nullable enable

/*
  Copyright (c) 2011+, HL7, Inc.
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
*/

namespace Hl7.Fhir.Model
{
  /// <summary>
  /// Information about a biological sequence
  /// </summary>
  /// <remarks>
  /// Raw data describing a biological sequence.
  /// </remarks>
  [Serializable]
  [DataContract]
  [FhirType("MolecularSequence","http://hl7.org/fhir/StructureDefinition/MolecularSequence")]
  public partial class MolecularSequence : Hl7.Fhir.Model.DomainResource, IIdentifiable<List<Identifier>>
  {
    /// <summary>
    /// FHIR Type Name
    /// </summary>
    public override string TypeName => "MolecularSequence";

    /// <summary>
    /// Type if a sequence -- DNA, RNA, or amino acid sequence.
    /// (url: http://hl7.org/fhir/ValueSet/sequence-type)
    /// (system: http://hl7.org/fhir/sequence-type)
    /// </summary>
    [FhirEnumeration("sequenceType", "http://hl7.org/fhir/ValueSet/sequence-type", "http://hl7.org/fhir/sequence-type")]
    public enum SequenceType
    {
      /// <summary>
      /// Amino acid sequence.
      /// (system: http://hl7.org/fhir/sequence-type)
      /// </summary>
      [EnumLiteral("aa"), Description("AA Sequence")]
      Aa,
      /// <summary>
      /// DNA Sequence.
      /// (system: http://hl7.org/fhir/sequence-type)
      /// </summary>
      [EnumLiteral("dna"), Description("DNA Sequence")]
      Dna,
      /// <summary>
      /// RNA Sequence.
      /// (system: http://hl7.org/fhir/sequence-type)
      /// </summary>
      [EnumLiteral("rna"), Description("RNA Sequence")]
      Rna,
    }

    /// <summary>
    /// Type for orientation.
    /// (url: http://hl7.org/fhir/ValueSet/orientation-type)
    /// (system: http://hl7.org/fhir/orientation-type)
    /// </summary>
    [FhirEnumeration("orientationType", "http://hl7.org/fhir/ValueSet/orientation-type", "http://hl7.org/fhir/orientation-type")]
    public enum OrientationType
    {
      /// <summary>
      /// Sense orientation of reference sequence.
      /// (system: http://hl7.org/fhir/orientation-type)
      /// </summary>
      [EnumLiteral("sense"), Description("Sense orientation of referenceSeq")]
      Sense,
      /// <summary>
      /// Antisense orientation of reference sequence.
      /// (system: http://hl7.org/fhir/orientation-type)
      /// </summary>
      [EnumLiteral("antisense"), Description("Antisense orientation of referenceSeq")]
      Antisense,
    }

    /// <summary>
    /// Type for strand.
    /// (url: http://hl7.org/fhir/ValueSet/strand-type)
    /// (system: http://hl7.org/fhir/strand-type)
    /// </summary>
    [FhirEnumeration("strandType", "http://hl7.org/fhir/ValueSet/strand-type", "http://hl7.org/fhir/strand-type")]
    public enum StrandType
    {
      /// <summary>
      /// Watson strand of reference sequence.
      /// (system: http://hl7.org/fhir/strand-type)
      /// </summary>
      [EnumLiteral("watson"), Description("Watson strand of referenceSeq")]
      Watson,
      /// <summary>
      /// Crick strand of reference sequence.
      /// (system: http://hl7.org/fhir/strand-type)
      /// </summary>
      [EnumLiteral("crick"), Description("Crick strand of referenceSeq")]
      Crick,
    }

    /// <summary>
    /// Type for quality report.
    /// (url: http://hl7.org/fhir/ValueSet/quality-type)
    /// (system: http://hl7.org/fhir/quality-type)
    /// </summary>
    [FhirEnumeration("qualityType", "http://hl7.org/fhir/ValueSet/quality-type", "http://hl7.org/fhir/quality-type")]
    public enum QualityType
    {
      /// <summary>
      /// INDEL Comparison.
      /// (system: http://hl7.org/fhir/quality-type)
      /// </summary>
      [EnumLiteral("indel"), Description("INDEL Comparison")]
      Indel,
      /// <summary>
      /// SNP Comparison.
      /// (system: http://hl7.org/fhir/quality-type)
      /// </summary>
      [EnumLiteral("snp"), Description("SNP Comparison")]
      Snp,
      /// <summary>
      /// UNKNOWN Comparison.
      /// (system: http://hl7.org/fhir/quality-type)
      /// </summary>
      [EnumLiteral("unknown"), Description("UNKNOWN Comparison")]
      Unknown,
    }

    /// <summary>
    /// Type for access of external URI.
    /// (url: http://hl7.org/fhir/ValueSet/repository-type)
    /// (system: http://hl7.org/fhir/repository-type)
    /// </summary>
    [FhirEnumeration("repositoryType", "http://hl7.org/fhir/ValueSet/repository-type", "http://hl7.org/fhir/repository-type")]
    public enum RepositoryType
    {
      /// <summary>
      /// When URL is clicked, the resource can be seen directly (by webpage or by download link format).
      /// (system: http://hl7.org/fhir/repository-type)
      /// </summary>
      [EnumLiteral("directlink"), Description("Click and see")]
      Directlink,
      /// <summary>
      /// When the API method (e.g. [base_url]/[parameter]) related with the URL of the website is executed, the resource can be seen directly (usually in JSON or XML format).
      /// (system: http://hl7.org/fhir/repository-type)
      /// </summary>
      [EnumLiteral("openapi"), Description("The URL is the RESTful or other kind of API that can access to the result.")]
      Openapi,
      /// <summary>
      /// When logged into the website, the resource can be seen.
      /// (system: http://hl7.org/fhir/repository-type)
      /// </summary>
      [EnumLiteral("login"), Description("Result cannot be access unless an account is logged in")]
      Login,
      /// <summary>
      /// When logged in and  follow the API in the website related with URL, the resource can be seen.
      /// (system: http://hl7.org/fhir/repository-type)
      /// </summary>
      [EnumLiteral("oauth"), Description("Result need to be fetched with API and need LOGIN( or cookies are required when visiting the link of resource)")]
      Oauth,
      /// <summary>
      /// Some other complicated or particular way to get resource from URL.
      /// (system: http://hl7.org/fhir/repository-type)
      /// </summary>
      [EnumLiteral("other"), Description("Some other complicated or particular way to get resource from URL.")]
      Other,
    }

    /// <summary>
    /// A sequence used as reference
    /// </summary>
    /// <remarks>
    /// A sequence that is used as a reference to describe variants that are present in a sequence analyzed.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("MolecularSequence.referenceSeq", IsBackboneType=true)]
    public partial class ReferenceSeqComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "MolecularSequence.referenceSeq";

      /// <summary>
      /// Chromosome containing genetic finding.
      /// </summary>
      [FhirElement("chromosome", InSummary=true, Order=40)]
      [Binding("chromosome-human")]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept? Chromosome
      {
        get
        {
          if(_Chromosome.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.CodeableConcept), Overflow["chromosome"]);
          return _Chromosome;
        }

        set
        {
          if (_Chromosome.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            Overflow.Remove("chromosome");
          _Chromosome = value;
          OnPropertyChanged("Chromosome");
        }

      }

      private Hl7.Fhir.Model.CodeableConcept? _Chromosome;

      /// <summary>
      /// The Genome Build used for reference, following GRCh build versions e.g. 'GRCh 37'.
      /// </summary>
      [FhirElement("genomeBuild", InSummary=true, Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString? GenomeBuildElement
      {
        get
        {
          if(_GenomeBuildElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirString), Overflow["genomeBuild"]);
          return _GenomeBuildElement;
        }

        set
        {
          if (_GenomeBuildElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            Overflow.Remove("genomeBuild");
          _GenomeBuildElement = value;
          OnPropertyChanged("GenomeBuildElement");
        }

      }

      private Hl7.Fhir.Model.FhirString? _GenomeBuildElement;

      /// <summary>
      /// The Genome Build used for reference, following GRCh build versions e.g. 'GRCh 37'
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? GenomeBuild
      {
        get => GenomeBuildElement?.Value;
        set
        {
          GenomeBuildElement = value is null ? null! : new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("GenomeBuild");
        }
      }

      /// <summary>
      /// sense | antisense.
      /// </summary>
      [FhirElement("orientation", InSummary=true, Order=60)]
      [Binding("orientationType")]
      [DataMember]
      public Code<Hl7.Fhir.Model.MolecularSequence.OrientationType>? OrientationElement
      {
        get
        {
          if(_OrientationElement.InOverflow<Code<Hl7.Fhir.Model.MolecularSequence.OrientationType>>())
            throw CodedValidationException.FromTypes(typeof(Code<Hl7.Fhir.Model.MolecularSequence.OrientationType>), Overflow["orientation"]);
          return _OrientationElement;
        }

        set
        {
          if (_OrientationElement.InOverflow<Code<Hl7.Fhir.Model.MolecularSequence.OrientationType>>())
            Overflow.Remove("orientation");
          _OrientationElement = value;
          OnPropertyChanged("OrientationElement");
        }

      }

      private Code<Hl7.Fhir.Model.MolecularSequence.OrientationType>? _OrientationElement;

      /// <summary>
      /// sense | antisense
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public Hl7.Fhir.Model.MolecularSequence.OrientationType? Orientation
      {
        get => OrientationElement?.Value;
        set
        {
          OrientationElement = value is null ? null! : new Code<Hl7.Fhir.Model.MolecularSequence.OrientationType>(value);
          OnPropertyChanged("Orientation");
        }
      }

      /// <summary>
      /// Reference identifier.
      /// </summary>
      [FhirElement("referenceSeqId", InSummary=true, Order=70)]
      [Binding("sequenceReference")]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept? ReferenceSeqId
      {
        get
        {
          if(_ReferenceSeqId.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.CodeableConcept), Overflow["referenceSeqId"]);
          return _ReferenceSeqId;
        }

        set
        {
          if (_ReferenceSeqId.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            Overflow.Remove("referenceSeqId");
          _ReferenceSeqId = value;
          OnPropertyChanged("ReferenceSeqId");
        }

      }

      private Hl7.Fhir.Model.CodeableConcept? _ReferenceSeqId;

      /// <summary>
      /// A pointer to another MolecularSequence entity as reference sequence.
      /// </summary>
      [FhirElement("referenceSeqPointer", InSummary=true, Order=80)]
      [CLSCompliant(false)]
      [References("MolecularSequence")]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference? ReferenceSeqPointer
      {
        get
        {
          if(_ReferenceSeqPointer.InOverflow<Hl7.Fhir.Model.ResourceReference>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.ResourceReference), Overflow["referenceSeqPointer"]);
          return _ReferenceSeqPointer;
        }

        set
        {
          if (_ReferenceSeqPointer.InOverflow<Hl7.Fhir.Model.ResourceReference>())
            Overflow.Remove("referenceSeqPointer");
          _ReferenceSeqPointer = value;
          OnPropertyChanged("ReferenceSeqPointer");
        }

      }

      private Hl7.Fhir.Model.ResourceReference? _ReferenceSeqPointer;

      /// <summary>
      /// A string to represent reference sequence.
      /// </summary>
      [FhirElement("referenceSeqString", InSummary=true, Order=90)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString? ReferenceSeqStringElement
      {
        get
        {
          if(_ReferenceSeqStringElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirString), Overflow["referenceSeqString"]);
          return _ReferenceSeqStringElement;
        }

        set
        {
          if (_ReferenceSeqStringElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            Overflow.Remove("referenceSeqString");
          _ReferenceSeqStringElement = value;
          OnPropertyChanged("ReferenceSeqStringElement");
        }

      }

      private Hl7.Fhir.Model.FhirString? _ReferenceSeqStringElement;

      /// <summary>
      /// A string to represent reference sequence
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? ReferenceSeqString
      {
        get => ReferenceSeqStringElement?.Value;
        set
        {
          ReferenceSeqStringElement = value is null ? null! : new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("ReferenceSeqString");
        }
      }

      /// <summary>
      /// watson | crick.
      /// </summary>
      [FhirElement("strand", InSummary=true, Order=100)]
      [Binding("strandType")]
      [DataMember]
      public Code<Hl7.Fhir.Model.MolecularSequence.StrandType>? StrandElement
      {
        get
        {
          if(_StrandElement.InOverflow<Code<Hl7.Fhir.Model.MolecularSequence.StrandType>>())
            throw CodedValidationException.FromTypes(typeof(Code<Hl7.Fhir.Model.MolecularSequence.StrandType>), Overflow["strand"]);
          return _StrandElement;
        }

        set
        {
          if (_StrandElement.InOverflow<Code<Hl7.Fhir.Model.MolecularSequence.StrandType>>())
            Overflow.Remove("strand");
          _StrandElement = value;
          OnPropertyChanged("StrandElement");
        }

      }

      private Code<Hl7.Fhir.Model.MolecularSequence.StrandType>? _StrandElement;

      /// <summary>
      /// watson | crick
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public Hl7.Fhir.Model.MolecularSequence.StrandType? Strand
      {
        get => StrandElement?.Value;
        set
        {
          StrandElement = value is null ? null! : new Code<Hl7.Fhir.Model.MolecularSequence.StrandType>(value);
          OnPropertyChanged("Strand");
        }
      }

      /// <summary>
      /// Start position of the window on the  reference sequence.
      /// </summary>
      [FhirElement("windowStart", InSummary=true, Order=110)]
      [DataMember]
      public Hl7.Fhir.Model.Integer? WindowStartElement
      {
        get
        {
          if(_WindowStartElement.InOverflow<Hl7.Fhir.Model.Integer>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Integer), Overflow["windowStart"]);
          return _WindowStartElement;
        }

        set
        {
          if (_WindowStartElement.InOverflow<Hl7.Fhir.Model.Integer>())
            Overflow.Remove("windowStart");
          _WindowStartElement = value;
          OnPropertyChanged("WindowStartElement");
        }

      }

      private Hl7.Fhir.Model.Integer? _WindowStartElement;

      /// <summary>
      /// Start position of the window on the  reference sequence
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? WindowStart
      {
        get => WindowStartElement?.Value;
        set
        {
          WindowStartElement = value is null ? null! : new Hl7.Fhir.Model.Integer(value);
          OnPropertyChanged("WindowStart");
        }
      }

      /// <summary>
      /// End position of the window on the reference sequence.
      /// </summary>
      [FhirElement("windowEnd", InSummary=true, Order=120)]
      [DataMember]
      public Hl7.Fhir.Model.Integer? WindowEndElement
      {
        get
        {
          if(_WindowEndElement.InOverflow<Hl7.Fhir.Model.Integer>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Integer), Overflow["windowEnd"]);
          return _WindowEndElement;
        }

        set
        {
          if (_WindowEndElement.InOverflow<Hl7.Fhir.Model.Integer>())
            Overflow.Remove("windowEnd");
          _WindowEndElement = value;
          OnPropertyChanged("WindowEndElement");
        }

      }

      private Hl7.Fhir.Model.Integer? _WindowEndElement;

      /// <summary>
      /// End position of the window on the reference sequence
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? WindowEnd
      {
        get => WindowEndElement?.Value;
        set
        {
          WindowEndElement = value is null ? null! : new Hl7.Fhir.Model.Integer(value);
          OnPropertyChanged("WindowEnd");
        }
      }

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not ReferenceSeqComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_Chromosome is not null) dest.Chromosome = (Hl7.Fhir.Model.CodeableConcept)_Chromosome.DeepCopyInternal();
        if(_GenomeBuildElement is not null) dest.GenomeBuildElement = (Hl7.Fhir.Model.FhirString)_GenomeBuildElement.DeepCopyInternal();
        if(_OrientationElement is not null) dest.OrientationElement = (Code<Hl7.Fhir.Model.MolecularSequence.OrientationType>)_OrientationElement.DeepCopyInternal();
        if(_ReferenceSeqId is not null) dest.ReferenceSeqId = (Hl7.Fhir.Model.CodeableConcept)_ReferenceSeqId.DeepCopyInternal();
        if(_ReferenceSeqPointer is not null) dest.ReferenceSeqPointer = (Hl7.Fhir.Model.ResourceReference)_ReferenceSeqPointer.DeepCopyInternal();
        if(_ReferenceSeqStringElement is not null) dest.ReferenceSeqStringElement = (Hl7.Fhir.Model.FhirString)_ReferenceSeqStringElement.DeepCopyInternal();
        if(_StrandElement is not null) dest.StrandElement = (Code<Hl7.Fhir.Model.MolecularSequence.StrandType>)_StrandElement.DeepCopyInternal();
        if(_WindowStartElement is not null) dest.WindowStartElement = (Hl7.Fhir.Model.Integer)_WindowStartElement.DeepCopyInternal();
        if(_WindowEndElement is not null) dest.WindowEndElement = (Hl7.Fhir.Model.Integer)_WindowEndElement.DeepCopyInternal();
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new ReferenceSeqComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not ReferenceSeqComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_Chromosome, otherT._Chromosome)) return false;
        if(!comparer.Equals(_GenomeBuildElement, otherT._GenomeBuildElement)) return false;
        if(!comparer.Equals(_OrientationElement, otherT._OrientationElement)) return false;
        if(!comparer.Equals(_ReferenceSeqId, otherT._ReferenceSeqId)) return false;
        if(!comparer.Equals(_ReferenceSeqPointer, otherT._ReferenceSeqPointer)) return false;
        if(!comparer.Equals(_ReferenceSeqStringElement, otherT._ReferenceSeqStringElement)) return false;
        if(!comparer.Equals(_StrandElement, otherT._StrandElement)) return false;
        if(!comparer.Equals(_WindowStartElement, otherT._WindowStartElement)) return false;
        if(!comparer.Equals(_WindowEndElement, otherT._WindowEndElement)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "chromosome":
            if (_Chromosome.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            {
              value = Overflow["chromosome"];
              return true;
            }
            value = _Chromosome;
            return (value as Hl7.Fhir.Model.CodeableConcept) is not null;
          case "genomeBuild":
            if (_GenomeBuildElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            {
              value = Overflow["genomeBuild"];
              return true;
            }
            value = _GenomeBuildElement;
            return (value as Hl7.Fhir.Model.FhirString) is not null;
          case "orientation":
            if (_OrientationElement.InOverflow<Code<Hl7.Fhir.Model.MolecularSequence.OrientationType>>())
            {
              value = Overflow["orientation"];
              return true;
            }
            value = _OrientationElement;
            return (value as Code<Hl7.Fhir.Model.MolecularSequence.OrientationType>) is not null;
          case "referenceSeqId":
            if (_ReferenceSeqId.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            {
              value = Overflow["referenceSeqId"];
              return true;
            }
            value = _ReferenceSeqId;
            return (value as Hl7.Fhir.Model.CodeableConcept) is not null;
          case "referenceSeqPointer":
            if (_ReferenceSeqPointer.InOverflow<Hl7.Fhir.Model.ResourceReference>())
            {
              value = Overflow["referenceSeqPointer"];
              return true;
            }
            value = _ReferenceSeqPointer;
            return (value as Hl7.Fhir.Model.ResourceReference) is not null;
          case "referenceSeqString":
            if (_ReferenceSeqStringElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            {
              value = Overflow["referenceSeqString"];
              return true;
            }
            value = _ReferenceSeqStringElement;
            return (value as Hl7.Fhir.Model.FhirString) is not null;
          case "strand":
            if (_StrandElement.InOverflow<Code<Hl7.Fhir.Model.MolecularSequence.StrandType>>())
            {
              value = Overflow["strand"];
              return true;
            }
            value = _StrandElement;
            return (value as Code<Hl7.Fhir.Model.MolecularSequence.StrandType>) is not null;
          case "windowStart":
            if (_WindowStartElement.InOverflow<Hl7.Fhir.Model.Integer>())
            {
              value = Overflow["windowStart"];
              return true;
            }
            value = _WindowStartElement;
            return (value as Hl7.Fhir.Model.Integer) is not null;
          case "windowEnd":
            if (_WindowEndElement.InOverflow<Hl7.Fhir.Model.Integer>())
            {
              value = Overflow["windowEnd"];
              return true;
            }
            value = _WindowEndElement;
            return (value as Hl7.Fhir.Model.Integer) is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "chromosome":
            if (value is not (Hl7.Fhir.Model.CodeableConcept or null))
            {
              Chromosome = OverflowNull<Hl7.Fhir.Model.CodeableConcept>.INSTANCE;
              Overflow["chromosome"] = value;
            }
            else Chromosome = (Hl7.Fhir.Model.CodeableConcept?)value;
            return this;
          case "genomeBuild":
            if (value is not (Hl7.Fhir.Model.FhirString or null))
            {
              GenomeBuildElement = OverflowNull<Hl7.Fhir.Model.FhirString>.INSTANCE;
              Overflow["genomeBuild"] = value;
            }
            else GenomeBuildElement = (Hl7.Fhir.Model.FhirString?)value;
            return this;
          case "orientation":
            if (value is not (Code<Hl7.Fhir.Model.MolecularSequence.OrientationType> or null))
            {
              OrientationElement = OverflowNull<Code<Hl7.Fhir.Model.MolecularSequence.OrientationType>>.INSTANCE;
              Overflow["orientation"] = value;
            }
            else OrientationElement = (Code<Hl7.Fhir.Model.MolecularSequence.OrientationType>?)value;
            return this;
          case "referenceSeqId":
            if (value is not (Hl7.Fhir.Model.CodeableConcept or null))
            {
              ReferenceSeqId = OverflowNull<Hl7.Fhir.Model.CodeableConcept>.INSTANCE;
              Overflow["referenceSeqId"] = value;
            }
            else ReferenceSeqId = (Hl7.Fhir.Model.CodeableConcept?)value;
            return this;
          case "referenceSeqPointer":
            if (value is not (Hl7.Fhir.Model.ResourceReference or null))
            {
              ReferenceSeqPointer = OverflowNull<Hl7.Fhir.Model.ResourceReference>.INSTANCE;
              Overflow["referenceSeqPointer"] = value;
            }
            else ReferenceSeqPointer = (Hl7.Fhir.Model.ResourceReference?)value;
            return this;
          case "referenceSeqString":
            if (value is not (Hl7.Fhir.Model.FhirString or null))
            {
              ReferenceSeqStringElement = OverflowNull<Hl7.Fhir.Model.FhirString>.INSTANCE;
              Overflow["referenceSeqString"] = value;
            }
            else ReferenceSeqStringElement = (Hl7.Fhir.Model.FhirString?)value;
            return this;
          case "strand":
            if (value is not (Code<Hl7.Fhir.Model.MolecularSequence.StrandType> or null))
            {
              StrandElement = OverflowNull<Code<Hl7.Fhir.Model.MolecularSequence.StrandType>>.INSTANCE;
              Overflow["strand"] = value;
            }
            else StrandElement = (Code<Hl7.Fhir.Model.MolecularSequence.StrandType>?)value;
            return this;
          case "windowStart":
            if (value is not (Hl7.Fhir.Model.Integer or null))
            {
              WindowStartElement = OverflowNull<Hl7.Fhir.Model.Integer>.INSTANCE;
              Overflow["windowStart"] = value;
            }
            else WindowStartElement = (Hl7.Fhir.Model.Integer?)value;
            return this;
          case "windowEnd":
            if (value is not (Hl7.Fhir.Model.Integer or null))
            {
              WindowEndElement = OverflowNull<Hl7.Fhir.Model.Integer>.INSTANCE;
              Overflow["windowEnd"] = value;
            }
            else WindowEndElement = (Hl7.Fhir.Model.Integer?)value;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_Chromosome is not null && !_Chromosome.InOverflow<Hl7.Fhir.Model.CodeableConcept>()) yield return new KeyValuePair<string,object>("chromosome",_Chromosome);
        if (_GenomeBuildElement is not null && !_GenomeBuildElement.InOverflow<Hl7.Fhir.Model.FhirString>()) yield return new KeyValuePair<string,object>("genomeBuild",_GenomeBuildElement);
        if (_OrientationElement is not null && !_OrientationElement.InOverflow<Code<Hl7.Fhir.Model.MolecularSequence.OrientationType>>()) yield return new KeyValuePair<string,object>("orientation",_OrientationElement);
        if (_ReferenceSeqId is not null && !_ReferenceSeqId.InOverflow<Hl7.Fhir.Model.CodeableConcept>()) yield return new KeyValuePair<string,object>("referenceSeqId",_ReferenceSeqId);
        if (_ReferenceSeqPointer is not null && !_ReferenceSeqPointer.InOverflow<Hl7.Fhir.Model.ResourceReference>()) yield return new KeyValuePair<string,object>("referenceSeqPointer",_ReferenceSeqPointer);
        if (_ReferenceSeqStringElement is not null && !_ReferenceSeqStringElement.InOverflow<Hl7.Fhir.Model.FhirString>()) yield return new KeyValuePair<string,object>("referenceSeqString",_ReferenceSeqStringElement);
        if (_StrandElement is not null && !_StrandElement.InOverflow<Code<Hl7.Fhir.Model.MolecularSequence.StrandType>>()) yield return new KeyValuePair<string,object>("strand",_StrandElement);
        if (_WindowStartElement is not null && !_WindowStartElement.InOverflow<Hl7.Fhir.Model.Integer>()) yield return new KeyValuePair<string,object>("windowStart",_WindowStartElement);
        if (_WindowEndElement is not null && !_WindowEndElement.InOverflow<Hl7.Fhir.Model.Integer>()) yield return new KeyValuePair<string,object>("windowEnd",_WindowEndElement);
      }

    }

    /// <summary>
    /// Variant in sequence
    /// </summary>
    /// <remarks>
    /// The definition of variant here originates from Sequence ontology ([variant_of](http://www.sequenceontology.org/browser/current_svn/term/variant_of)). This element can represent amino acid or nucleic sequence change(including insertion,deletion,SNP,etc.)  It can represent some complex mutation or segment variation with the assist of CIGAR string.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("MolecularSequence.variant", IsBackboneType=true)]
    public partial class VariantComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "MolecularSequence.variant";

      /// <summary>
      /// Start position of the variant on the  reference sequence.
      /// </summary>
      [FhirElement("start", InSummary=true, Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.Integer? StartElement
      {
        get
        {
          if(_StartElement.InOverflow<Hl7.Fhir.Model.Integer>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Integer), Overflow["start"]);
          return _StartElement;
        }

        set
        {
          if (_StartElement.InOverflow<Hl7.Fhir.Model.Integer>())
            Overflow.Remove("start");
          _StartElement = value;
          OnPropertyChanged("StartElement");
        }

      }

      private Hl7.Fhir.Model.Integer? _StartElement;

      /// <summary>
      /// Start position of the variant on the  reference sequence
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? Start
      {
        get => StartElement?.Value;
        set
        {
          StartElement = value is null ? null! : new Hl7.Fhir.Model.Integer(value);
          OnPropertyChanged("Start");
        }
      }

      /// <summary>
      /// End position of the variant on the reference sequence.
      /// </summary>
      [FhirElement("end", InSummary=true, Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.Integer? EndElement
      {
        get
        {
          if(_EndElement.InOverflow<Hl7.Fhir.Model.Integer>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Integer), Overflow["end"]);
          return _EndElement;
        }

        set
        {
          if (_EndElement.InOverflow<Hl7.Fhir.Model.Integer>())
            Overflow.Remove("end");
          _EndElement = value;
          OnPropertyChanged("EndElement");
        }

      }

      private Hl7.Fhir.Model.Integer? _EndElement;

      /// <summary>
      /// End position of the variant on the reference sequence
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? End
      {
        get => EndElement?.Value;
        set
        {
          EndElement = value is null ? null! : new Hl7.Fhir.Model.Integer(value);
          OnPropertyChanged("End");
        }
      }

      /// <summary>
      /// Allele that was observed.
      /// </summary>
      [FhirElement("observedAllele", InSummary=true, Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString? ObservedAlleleElement
      {
        get
        {
          if(_ObservedAlleleElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirString), Overflow["observedAllele"]);
          return _ObservedAlleleElement;
        }

        set
        {
          if (_ObservedAlleleElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            Overflow.Remove("observedAllele");
          _ObservedAlleleElement = value;
          OnPropertyChanged("ObservedAlleleElement");
        }

      }

      private Hl7.Fhir.Model.FhirString? _ObservedAlleleElement;

      /// <summary>
      /// Allele that was observed
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? ObservedAllele
      {
        get => ObservedAlleleElement?.Value;
        set
        {
          ObservedAlleleElement = value is null ? null! : new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("ObservedAllele");
        }
      }

      /// <summary>
      /// Allele in the reference sequence.
      /// </summary>
      [FhirElement("referenceAllele", InSummary=true, Order=70)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString? ReferenceAlleleElement
      {
        get
        {
          if(_ReferenceAlleleElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirString), Overflow["referenceAllele"]);
          return _ReferenceAlleleElement;
        }

        set
        {
          if (_ReferenceAlleleElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            Overflow.Remove("referenceAllele");
          _ReferenceAlleleElement = value;
          OnPropertyChanged("ReferenceAlleleElement");
        }

      }

      private Hl7.Fhir.Model.FhirString? _ReferenceAlleleElement;

      /// <summary>
      /// Allele in the reference sequence
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? ReferenceAllele
      {
        get => ReferenceAlleleElement?.Value;
        set
        {
          ReferenceAlleleElement = value is null ? null! : new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("ReferenceAllele");
        }
      }

      /// <summary>
      /// Extended CIGAR string for aligning the sequence with reference bases.
      /// </summary>
      [FhirElement("cigar", InSummary=true, Order=80)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString? CigarElement
      {
        get
        {
          if(_CigarElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirString), Overflow["cigar"]);
          return _CigarElement;
        }

        set
        {
          if (_CigarElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            Overflow.Remove("cigar");
          _CigarElement = value;
          OnPropertyChanged("CigarElement");
        }

      }

      private Hl7.Fhir.Model.FhirString? _CigarElement;

      /// <summary>
      /// Extended CIGAR string for aligning the sequence with reference bases
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? Cigar
      {
        get => CigarElement?.Value;
        set
        {
          CigarElement = value is null ? null! : new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Cigar");
        }
      }

      /// <summary>
      /// Pointer to observed variant information.
      /// </summary>
      [FhirElement("variantPointer", InSummary=true, Order=90)]
      [CLSCompliant(false)]
      [References("Observation")]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference? VariantPointer
      {
        get
        {
          if(_VariantPointer.InOverflow<Hl7.Fhir.Model.ResourceReference>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.ResourceReference), Overflow["variantPointer"]);
          return _VariantPointer;
        }

        set
        {
          if (_VariantPointer.InOverflow<Hl7.Fhir.Model.ResourceReference>())
            Overflow.Remove("variantPointer");
          _VariantPointer = value;
          OnPropertyChanged("VariantPointer");
        }

      }

      private Hl7.Fhir.Model.ResourceReference? _VariantPointer;

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not VariantComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_StartElement is not null) dest.StartElement = (Hl7.Fhir.Model.Integer)_StartElement.DeepCopyInternal();
        if(_EndElement is not null) dest.EndElement = (Hl7.Fhir.Model.Integer)_EndElement.DeepCopyInternal();
        if(_ObservedAlleleElement is not null) dest.ObservedAlleleElement = (Hl7.Fhir.Model.FhirString)_ObservedAlleleElement.DeepCopyInternal();
        if(_ReferenceAlleleElement is not null) dest.ReferenceAlleleElement = (Hl7.Fhir.Model.FhirString)_ReferenceAlleleElement.DeepCopyInternal();
        if(_CigarElement is not null) dest.CigarElement = (Hl7.Fhir.Model.FhirString)_CigarElement.DeepCopyInternal();
        if(_VariantPointer is not null) dest.VariantPointer = (Hl7.Fhir.Model.ResourceReference)_VariantPointer.DeepCopyInternal();
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new VariantComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not VariantComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_StartElement, otherT._StartElement)) return false;
        if(!comparer.Equals(_EndElement, otherT._EndElement)) return false;
        if(!comparer.Equals(_ObservedAlleleElement, otherT._ObservedAlleleElement)) return false;
        if(!comparer.Equals(_ReferenceAlleleElement, otherT._ReferenceAlleleElement)) return false;
        if(!comparer.Equals(_CigarElement, otherT._CigarElement)) return false;
        if(!comparer.Equals(_VariantPointer, otherT._VariantPointer)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "start":
            if (_StartElement.InOverflow<Hl7.Fhir.Model.Integer>())
            {
              value = Overflow["start"];
              return true;
            }
            value = _StartElement;
            return (value as Hl7.Fhir.Model.Integer) is not null;
          case "end":
            if (_EndElement.InOverflow<Hl7.Fhir.Model.Integer>())
            {
              value = Overflow["end"];
              return true;
            }
            value = _EndElement;
            return (value as Hl7.Fhir.Model.Integer) is not null;
          case "observedAllele":
            if (_ObservedAlleleElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            {
              value = Overflow["observedAllele"];
              return true;
            }
            value = _ObservedAlleleElement;
            return (value as Hl7.Fhir.Model.FhirString) is not null;
          case "referenceAllele":
            if (_ReferenceAlleleElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            {
              value = Overflow["referenceAllele"];
              return true;
            }
            value = _ReferenceAlleleElement;
            return (value as Hl7.Fhir.Model.FhirString) is not null;
          case "cigar":
            if (_CigarElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            {
              value = Overflow["cigar"];
              return true;
            }
            value = _CigarElement;
            return (value as Hl7.Fhir.Model.FhirString) is not null;
          case "variantPointer":
            if (_VariantPointer.InOverflow<Hl7.Fhir.Model.ResourceReference>())
            {
              value = Overflow["variantPointer"];
              return true;
            }
            value = _VariantPointer;
            return (value as Hl7.Fhir.Model.ResourceReference) is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "start":
            if (value is not (Hl7.Fhir.Model.Integer or null))
            {
              StartElement = OverflowNull<Hl7.Fhir.Model.Integer>.INSTANCE;
              Overflow["start"] = value;
            }
            else StartElement = (Hl7.Fhir.Model.Integer?)value;
            return this;
          case "end":
            if (value is not (Hl7.Fhir.Model.Integer or null))
            {
              EndElement = OverflowNull<Hl7.Fhir.Model.Integer>.INSTANCE;
              Overflow["end"] = value;
            }
            else EndElement = (Hl7.Fhir.Model.Integer?)value;
            return this;
          case "observedAllele":
            if (value is not (Hl7.Fhir.Model.FhirString or null))
            {
              ObservedAlleleElement = OverflowNull<Hl7.Fhir.Model.FhirString>.INSTANCE;
              Overflow["observedAllele"] = value;
            }
            else ObservedAlleleElement = (Hl7.Fhir.Model.FhirString?)value;
            return this;
          case "referenceAllele":
            if (value is not (Hl7.Fhir.Model.FhirString or null))
            {
              ReferenceAlleleElement = OverflowNull<Hl7.Fhir.Model.FhirString>.INSTANCE;
              Overflow["referenceAllele"] = value;
            }
            else ReferenceAlleleElement = (Hl7.Fhir.Model.FhirString?)value;
            return this;
          case "cigar":
            if (value is not (Hl7.Fhir.Model.FhirString or null))
            {
              CigarElement = OverflowNull<Hl7.Fhir.Model.FhirString>.INSTANCE;
              Overflow["cigar"] = value;
            }
            else CigarElement = (Hl7.Fhir.Model.FhirString?)value;
            return this;
          case "variantPointer":
            if (value is not (Hl7.Fhir.Model.ResourceReference or null))
            {
              VariantPointer = OverflowNull<Hl7.Fhir.Model.ResourceReference>.INSTANCE;
              Overflow["variantPointer"] = value;
            }
            else VariantPointer = (Hl7.Fhir.Model.ResourceReference?)value;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_StartElement is not null && !_StartElement.InOverflow<Hl7.Fhir.Model.Integer>()) yield return new KeyValuePair<string,object>("start",_StartElement);
        if (_EndElement is not null && !_EndElement.InOverflow<Hl7.Fhir.Model.Integer>()) yield return new KeyValuePair<string,object>("end",_EndElement);
        if (_ObservedAlleleElement is not null && !_ObservedAlleleElement.InOverflow<Hl7.Fhir.Model.FhirString>()) yield return new KeyValuePair<string,object>("observedAllele",_ObservedAlleleElement);
        if (_ReferenceAlleleElement is not null && !_ReferenceAlleleElement.InOverflow<Hl7.Fhir.Model.FhirString>()) yield return new KeyValuePair<string,object>("referenceAllele",_ReferenceAlleleElement);
        if (_CigarElement is not null && !_CigarElement.InOverflow<Hl7.Fhir.Model.FhirString>()) yield return new KeyValuePair<string,object>("cigar",_CigarElement);
        if (_VariantPointer is not null && !_VariantPointer.InOverflow<Hl7.Fhir.Model.ResourceReference>()) yield return new KeyValuePair<string,object>("variantPointer",_VariantPointer);
      }

    }

    /// <summary>
    /// An set of value as quality of sequence
    /// </summary>
    /// <remarks>
    /// An experimental feature attribute that defines the quality of the feature in a quantitative way, such as a phred quality score ([SO:0001686](http://www.sequenceontology.org/browser/current_svn/term/SO:0001686)).
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("MolecularSequence.quality", IsBackboneType=true)]
    public partial class QualityComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "MolecularSequence.quality";

      /// <summary>
      /// indel | snp | unknown.
      /// </summary>
      [FhirElement("type", InSummary=true, Order=40)]
      [Binding("qualityType")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Code<Hl7.Fhir.Model.MolecularSequence.QualityType> TypeElement
      {
        get
        {
          if(_TypeElement.InOverflow<Code<Hl7.Fhir.Model.MolecularSequence.QualityType>>())
            throw CodedValidationException.FromTypes(typeof(Code<Hl7.Fhir.Model.MolecularSequence.QualityType>), Overflow["type"]);
          return _TypeElement!;
        }

        set
        {
          if (_TypeElement.InOverflow<Code<Hl7.Fhir.Model.MolecularSequence.QualityType>>())
            Overflow.Remove("type");
          _TypeElement = value;
          OnPropertyChanged("TypeElement");
        }

      }

      private Code<Hl7.Fhir.Model.MolecularSequence.QualityType>? _TypeElement;

      /// <summary>
      /// indel | snp | unknown
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public Hl7.Fhir.Model.MolecularSequence.QualityType? Type
      {
        get => TypeElement?.Value;
        set
        {
          TypeElement = value is null ? null! : new Code<Hl7.Fhir.Model.MolecularSequence.QualityType>(value);
          OnPropertyChanged("Type");
        }
      }

      /// <summary>
      /// Standard sequence for comparison.
      /// </summary>
      [FhirElement("standardSequence", InSummary=true, Order=50)]
      [Binding("qualityStandardSequence")]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept? StandardSequence
      {
        get
        {
          if(_StandardSequence.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.CodeableConcept), Overflow["standardSequence"]);
          return _StandardSequence;
        }

        set
        {
          if (_StandardSequence.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            Overflow.Remove("standardSequence");
          _StandardSequence = value;
          OnPropertyChanged("StandardSequence");
        }

      }

      private Hl7.Fhir.Model.CodeableConcept? _StandardSequence;

      /// <summary>
      /// Start position of the sequence.
      /// </summary>
      [FhirElement("start", InSummary=true, Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.Integer? StartElement
      {
        get
        {
          if(_StartElement.InOverflow<Hl7.Fhir.Model.Integer>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Integer), Overflow["start"]);
          return _StartElement;
        }

        set
        {
          if (_StartElement.InOverflow<Hl7.Fhir.Model.Integer>())
            Overflow.Remove("start");
          _StartElement = value;
          OnPropertyChanged("StartElement");
        }

      }

      private Hl7.Fhir.Model.Integer? _StartElement;

      /// <summary>
      /// Start position of the sequence
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? Start
      {
        get => StartElement?.Value;
        set
        {
          StartElement = value is null ? null! : new Hl7.Fhir.Model.Integer(value);
          OnPropertyChanged("Start");
        }
      }

      /// <summary>
      /// End position of the sequence.
      /// </summary>
      [FhirElement("end", InSummary=true, Order=70)]
      [DataMember]
      public Hl7.Fhir.Model.Integer? EndElement
      {
        get
        {
          if(_EndElement.InOverflow<Hl7.Fhir.Model.Integer>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Integer), Overflow["end"]);
          return _EndElement;
        }

        set
        {
          if (_EndElement.InOverflow<Hl7.Fhir.Model.Integer>())
            Overflow.Remove("end");
          _EndElement = value;
          OnPropertyChanged("EndElement");
        }

      }

      private Hl7.Fhir.Model.Integer? _EndElement;

      /// <summary>
      /// End position of the sequence
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? End
      {
        get => EndElement?.Value;
        set
        {
          EndElement = value is null ? null! : new Hl7.Fhir.Model.Integer(value);
          OnPropertyChanged("End");
        }
      }

      /// <summary>
      /// Quality score for the comparison.
      /// </summary>
      [FhirElement("score", InSummary=true, Order=80)]
      [DataMember]
      public Hl7.Fhir.Model.Quantity? Score
      {
        get
        {
          if(_Score.InOverflow<Hl7.Fhir.Model.Quantity>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Quantity), Overflow["score"]);
          return _Score;
        }

        set
        {
          if (_Score.InOverflow<Hl7.Fhir.Model.Quantity>())
            Overflow.Remove("score");
          _Score = value;
          OnPropertyChanged("Score");
        }

      }

      private Hl7.Fhir.Model.Quantity? _Score;

      /// <summary>
      /// Method to get quality.
      /// </summary>
      [FhirElement("method", InSummary=true, Order=90)]
      [Binding("qualityMethod")]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept? Method
      {
        get
        {
          if(_Method.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.CodeableConcept), Overflow["method"]);
          return _Method;
        }

        set
        {
          if (_Method.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            Overflow.Remove("method");
          _Method = value;
          OnPropertyChanged("Method");
        }

      }

      private Hl7.Fhir.Model.CodeableConcept? _Method;

      /// <summary>
      /// True positives from the perspective of the truth data.
      /// </summary>
      [FhirElement("truthTP", InSummary=true, Order=100)]
      [DataMember]
      public Hl7.Fhir.Model.FhirDecimal? TruthTPElement
      {
        get
        {
          if(_TruthTPElement.InOverflow<Hl7.Fhir.Model.FhirDecimal>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirDecimal), Overflow["truthTP"]);
          return _TruthTPElement;
        }

        set
        {
          if (_TruthTPElement.InOverflow<Hl7.Fhir.Model.FhirDecimal>())
            Overflow.Remove("truthTP");
          _TruthTPElement = value;
          OnPropertyChanged("TruthTPElement");
        }

      }

      private Hl7.Fhir.Model.FhirDecimal? _TruthTPElement;

      /// <summary>
      /// True positives from the perspective of the truth data
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public decimal? TruthTP
      {
        get => TruthTPElement?.Value;
        set
        {
          TruthTPElement = value is null ? null! : new Hl7.Fhir.Model.FhirDecimal(value);
          OnPropertyChanged("TruthTP");
        }
      }

      /// <summary>
      /// True positives from the perspective of the query data.
      /// </summary>
      [FhirElement("queryTP", InSummary=true, Order=110)]
      [DataMember]
      public Hl7.Fhir.Model.FhirDecimal? QueryTPElement
      {
        get
        {
          if(_QueryTPElement.InOverflow<Hl7.Fhir.Model.FhirDecimal>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirDecimal), Overflow["queryTP"]);
          return _QueryTPElement;
        }

        set
        {
          if (_QueryTPElement.InOverflow<Hl7.Fhir.Model.FhirDecimal>())
            Overflow.Remove("queryTP");
          _QueryTPElement = value;
          OnPropertyChanged("QueryTPElement");
        }

      }

      private Hl7.Fhir.Model.FhirDecimal? _QueryTPElement;

      /// <summary>
      /// True positives from the perspective of the query data
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public decimal? QueryTP
      {
        get => QueryTPElement?.Value;
        set
        {
          QueryTPElement = value is null ? null! : new Hl7.Fhir.Model.FhirDecimal(value);
          OnPropertyChanged("QueryTP");
        }
      }

      /// <summary>
      /// False negatives.
      /// </summary>
      [FhirElement("truthFN", InSummary=true, Order=120)]
      [DataMember]
      public Hl7.Fhir.Model.FhirDecimal? TruthFNElement
      {
        get
        {
          if(_TruthFNElement.InOverflow<Hl7.Fhir.Model.FhirDecimal>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirDecimal), Overflow["truthFN"]);
          return _TruthFNElement;
        }

        set
        {
          if (_TruthFNElement.InOverflow<Hl7.Fhir.Model.FhirDecimal>())
            Overflow.Remove("truthFN");
          _TruthFNElement = value;
          OnPropertyChanged("TruthFNElement");
        }

      }

      private Hl7.Fhir.Model.FhirDecimal? _TruthFNElement;

      /// <summary>
      /// False negatives
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public decimal? TruthFN
      {
        get => TruthFNElement?.Value;
        set
        {
          TruthFNElement = value is null ? null! : new Hl7.Fhir.Model.FhirDecimal(value);
          OnPropertyChanged("TruthFN");
        }
      }

      /// <summary>
      /// False positives.
      /// </summary>
      [FhirElement("queryFP", InSummary=true, Order=130)]
      [DataMember]
      public Hl7.Fhir.Model.FhirDecimal? QueryFPElement
      {
        get
        {
          if(_QueryFPElement.InOverflow<Hl7.Fhir.Model.FhirDecimal>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirDecimal), Overflow["queryFP"]);
          return _QueryFPElement;
        }

        set
        {
          if (_QueryFPElement.InOverflow<Hl7.Fhir.Model.FhirDecimal>())
            Overflow.Remove("queryFP");
          _QueryFPElement = value;
          OnPropertyChanged("QueryFPElement");
        }

      }

      private Hl7.Fhir.Model.FhirDecimal? _QueryFPElement;

      /// <summary>
      /// False positives
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public decimal? QueryFP
      {
        get => QueryFPElement?.Value;
        set
        {
          QueryFPElement = value is null ? null! : new Hl7.Fhir.Model.FhirDecimal(value);
          OnPropertyChanged("QueryFP");
        }
      }

      /// <summary>
      /// False positives where the non-REF alleles in the Truth and Query Call Sets match.
      /// </summary>
      [FhirElement("gtFP", InSummary=true, Order=140)]
      [DataMember]
      public Hl7.Fhir.Model.FhirDecimal? GtFPElement
      {
        get
        {
          if(_GtFPElement.InOverflow<Hl7.Fhir.Model.FhirDecimal>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirDecimal), Overflow["gtFP"]);
          return _GtFPElement;
        }

        set
        {
          if (_GtFPElement.InOverflow<Hl7.Fhir.Model.FhirDecimal>())
            Overflow.Remove("gtFP");
          _GtFPElement = value;
          OnPropertyChanged("GtFPElement");
        }

      }

      private Hl7.Fhir.Model.FhirDecimal? _GtFPElement;

      /// <summary>
      /// False positives where the non-REF alleles in the Truth and Query Call Sets match
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public decimal? GtFP
      {
        get => GtFPElement?.Value;
        set
        {
          GtFPElement = value is null ? null! : new Hl7.Fhir.Model.FhirDecimal(value);
          OnPropertyChanged("GtFP");
        }
      }

      /// <summary>
      /// Precision of comparison.
      /// </summary>
      [FhirElement("precision", InSummary=true, Order=150)]
      [DataMember]
      public Hl7.Fhir.Model.FhirDecimal? PrecisionElement
      {
        get
        {
          if(_PrecisionElement.InOverflow<Hl7.Fhir.Model.FhirDecimal>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirDecimal), Overflow["precision"]);
          return _PrecisionElement;
        }

        set
        {
          if (_PrecisionElement.InOverflow<Hl7.Fhir.Model.FhirDecimal>())
            Overflow.Remove("precision");
          _PrecisionElement = value;
          OnPropertyChanged("PrecisionElement");
        }

      }

      private Hl7.Fhir.Model.FhirDecimal? _PrecisionElement;

      /// <summary>
      /// Precision of comparison
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public decimal? Precision
      {
        get => PrecisionElement?.Value;
        set
        {
          PrecisionElement = value is null ? null! : new Hl7.Fhir.Model.FhirDecimal(value);
          OnPropertyChanged("Precision");
        }
      }

      /// <summary>
      /// Recall of comparison.
      /// </summary>
      [FhirElement("recall", InSummary=true, Order=160)]
      [DataMember]
      public Hl7.Fhir.Model.FhirDecimal? RecallElement
      {
        get
        {
          if(_RecallElement.InOverflow<Hl7.Fhir.Model.FhirDecimal>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirDecimal), Overflow["recall"]);
          return _RecallElement;
        }

        set
        {
          if (_RecallElement.InOverflow<Hl7.Fhir.Model.FhirDecimal>())
            Overflow.Remove("recall");
          _RecallElement = value;
          OnPropertyChanged("RecallElement");
        }

      }

      private Hl7.Fhir.Model.FhirDecimal? _RecallElement;

      /// <summary>
      /// Recall of comparison
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public decimal? Recall
      {
        get => RecallElement?.Value;
        set
        {
          RecallElement = value is null ? null! : new Hl7.Fhir.Model.FhirDecimal(value);
          OnPropertyChanged("Recall");
        }
      }

      /// <summary>
      /// F-score.
      /// </summary>
      [FhirElement("fScore", InSummary=true, Order=170)]
      [DataMember]
      public Hl7.Fhir.Model.FhirDecimal? FScoreElement
      {
        get
        {
          if(_FScoreElement.InOverflow<Hl7.Fhir.Model.FhirDecimal>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirDecimal), Overflow["fScore"]);
          return _FScoreElement;
        }

        set
        {
          if (_FScoreElement.InOverflow<Hl7.Fhir.Model.FhirDecimal>())
            Overflow.Remove("fScore");
          _FScoreElement = value;
          OnPropertyChanged("FScoreElement");
        }

      }

      private Hl7.Fhir.Model.FhirDecimal? _FScoreElement;

      /// <summary>
      /// F-score
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public decimal? FScore
      {
        get => FScoreElement?.Value;
        set
        {
          FScoreElement = value is null ? null! : new Hl7.Fhir.Model.FhirDecimal(value);
          OnPropertyChanged("FScore");
        }
      }

      /// <summary>
      /// Receiver Operator Characteristic (ROC) Curve.
      /// </summary>
      [FhirElement("roc", InSummary=true, Order=180)]
      [DataMember]
      public Hl7.Fhir.Model.MolecularSequence.RocComponent? Roc
      {
        get
        {
          if(_Roc.InOverflow<Hl7.Fhir.Model.MolecularSequence.RocComponent>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.MolecularSequence.RocComponent), Overflow["roc"]);
          return _Roc;
        }

        set
        {
          if (_Roc.InOverflow<Hl7.Fhir.Model.MolecularSequence.RocComponent>())
            Overflow.Remove("roc");
          _Roc = value;
          OnPropertyChanged("Roc");
        }

      }

      private Hl7.Fhir.Model.MolecularSequence.RocComponent? _Roc;

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not QualityComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_TypeElement is not null) dest.TypeElement = (Code<Hl7.Fhir.Model.MolecularSequence.QualityType>)_TypeElement.DeepCopyInternal();
        if(_StandardSequence is not null) dest.StandardSequence = (Hl7.Fhir.Model.CodeableConcept)_StandardSequence.DeepCopyInternal();
        if(_StartElement is not null) dest.StartElement = (Hl7.Fhir.Model.Integer)_StartElement.DeepCopyInternal();
        if(_EndElement is not null) dest.EndElement = (Hl7.Fhir.Model.Integer)_EndElement.DeepCopyInternal();
        if(_Score is not null) dest.Score = (Hl7.Fhir.Model.Quantity)_Score.DeepCopyInternal();
        if(_Method is not null) dest.Method = (Hl7.Fhir.Model.CodeableConcept)_Method.DeepCopyInternal();
        if(_TruthTPElement is not null) dest.TruthTPElement = (Hl7.Fhir.Model.FhirDecimal)_TruthTPElement.DeepCopyInternal();
        if(_QueryTPElement is not null) dest.QueryTPElement = (Hl7.Fhir.Model.FhirDecimal)_QueryTPElement.DeepCopyInternal();
        if(_TruthFNElement is not null) dest.TruthFNElement = (Hl7.Fhir.Model.FhirDecimal)_TruthFNElement.DeepCopyInternal();
        if(_QueryFPElement is not null) dest.QueryFPElement = (Hl7.Fhir.Model.FhirDecimal)_QueryFPElement.DeepCopyInternal();
        if(_GtFPElement is not null) dest.GtFPElement = (Hl7.Fhir.Model.FhirDecimal)_GtFPElement.DeepCopyInternal();
        if(_PrecisionElement is not null) dest.PrecisionElement = (Hl7.Fhir.Model.FhirDecimal)_PrecisionElement.DeepCopyInternal();
        if(_RecallElement is not null) dest.RecallElement = (Hl7.Fhir.Model.FhirDecimal)_RecallElement.DeepCopyInternal();
        if(_FScoreElement is not null) dest.FScoreElement = (Hl7.Fhir.Model.FhirDecimal)_FScoreElement.DeepCopyInternal();
        if(_Roc is not null) dest.Roc = (Hl7.Fhir.Model.MolecularSequence.RocComponent)_Roc.DeepCopyInternal();
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new QualityComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not QualityComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_TypeElement, otherT._TypeElement)) return false;
        if(!comparer.Equals(_StandardSequence, otherT._StandardSequence)) return false;
        if(!comparer.Equals(_StartElement, otherT._StartElement)) return false;
        if(!comparer.Equals(_EndElement, otherT._EndElement)) return false;
        if(!comparer.Equals(_Score, otherT._Score)) return false;
        if(!comparer.Equals(_Method, otherT._Method)) return false;
        if(!comparer.Equals(_TruthTPElement, otherT._TruthTPElement)) return false;
        if(!comparer.Equals(_QueryTPElement, otherT._QueryTPElement)) return false;
        if(!comparer.Equals(_TruthFNElement, otherT._TruthFNElement)) return false;
        if(!comparer.Equals(_QueryFPElement, otherT._QueryFPElement)) return false;
        if(!comparer.Equals(_GtFPElement, otherT._GtFPElement)) return false;
        if(!comparer.Equals(_PrecisionElement, otherT._PrecisionElement)) return false;
        if(!comparer.Equals(_RecallElement, otherT._RecallElement)) return false;
        if(!comparer.Equals(_FScoreElement, otherT._FScoreElement)) return false;
        if(!comparer.Equals(_Roc, otherT._Roc)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "type":
            if (_TypeElement.InOverflow<Code<Hl7.Fhir.Model.MolecularSequence.QualityType>>())
            {
              value = Overflow["type"];
              return true;
            }
            value = _TypeElement;
            return (value as Code<Hl7.Fhir.Model.MolecularSequence.QualityType>) is not null;
          case "standardSequence":
            if (_StandardSequence.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            {
              value = Overflow["standardSequence"];
              return true;
            }
            value = _StandardSequence;
            return (value as Hl7.Fhir.Model.CodeableConcept) is not null;
          case "start":
            if (_StartElement.InOverflow<Hl7.Fhir.Model.Integer>())
            {
              value = Overflow["start"];
              return true;
            }
            value = _StartElement;
            return (value as Hl7.Fhir.Model.Integer) is not null;
          case "end":
            if (_EndElement.InOverflow<Hl7.Fhir.Model.Integer>())
            {
              value = Overflow["end"];
              return true;
            }
            value = _EndElement;
            return (value as Hl7.Fhir.Model.Integer) is not null;
          case "score":
            if (_Score.InOverflow<Hl7.Fhir.Model.Quantity>())
            {
              value = Overflow["score"];
              return true;
            }
            value = _Score;
            return (value as Hl7.Fhir.Model.Quantity) is not null;
          case "method":
            if (_Method.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            {
              value = Overflow["method"];
              return true;
            }
            value = _Method;
            return (value as Hl7.Fhir.Model.CodeableConcept) is not null;
          case "truthTP":
            if (_TruthTPElement.InOverflow<Hl7.Fhir.Model.FhirDecimal>())
            {
              value = Overflow["truthTP"];
              return true;
            }
            value = _TruthTPElement;
            return (value as Hl7.Fhir.Model.FhirDecimal) is not null;
          case "queryTP":
            if (_QueryTPElement.InOverflow<Hl7.Fhir.Model.FhirDecimal>())
            {
              value = Overflow["queryTP"];
              return true;
            }
            value = _QueryTPElement;
            return (value as Hl7.Fhir.Model.FhirDecimal) is not null;
          case "truthFN":
            if (_TruthFNElement.InOverflow<Hl7.Fhir.Model.FhirDecimal>())
            {
              value = Overflow["truthFN"];
              return true;
            }
            value = _TruthFNElement;
            return (value as Hl7.Fhir.Model.FhirDecimal) is not null;
          case "queryFP":
            if (_QueryFPElement.InOverflow<Hl7.Fhir.Model.FhirDecimal>())
            {
              value = Overflow["queryFP"];
              return true;
            }
            value = _QueryFPElement;
            return (value as Hl7.Fhir.Model.FhirDecimal) is not null;
          case "gtFP":
            if (_GtFPElement.InOverflow<Hl7.Fhir.Model.FhirDecimal>())
            {
              value = Overflow["gtFP"];
              return true;
            }
            value = _GtFPElement;
            return (value as Hl7.Fhir.Model.FhirDecimal) is not null;
          case "precision":
            if (_PrecisionElement.InOverflow<Hl7.Fhir.Model.FhirDecimal>())
            {
              value = Overflow["precision"];
              return true;
            }
            value = _PrecisionElement;
            return (value as Hl7.Fhir.Model.FhirDecimal) is not null;
          case "recall":
            if (_RecallElement.InOverflow<Hl7.Fhir.Model.FhirDecimal>())
            {
              value = Overflow["recall"];
              return true;
            }
            value = _RecallElement;
            return (value as Hl7.Fhir.Model.FhirDecimal) is not null;
          case "fScore":
            if (_FScoreElement.InOverflow<Hl7.Fhir.Model.FhirDecimal>())
            {
              value = Overflow["fScore"];
              return true;
            }
            value = _FScoreElement;
            return (value as Hl7.Fhir.Model.FhirDecimal) is not null;
          case "roc":
            if (_Roc.InOverflow<Hl7.Fhir.Model.MolecularSequence.RocComponent>())
            {
              value = Overflow["roc"];
              return true;
            }
            value = _Roc;
            return (value as Hl7.Fhir.Model.MolecularSequence.RocComponent) is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "type":
            if (value is not (Code<Hl7.Fhir.Model.MolecularSequence.QualityType> or null))
            {
              TypeElement = OverflowNull<Code<Hl7.Fhir.Model.MolecularSequence.QualityType>>.INSTANCE;
              Overflow["type"] = value;
            }
            else TypeElement = (Code<Hl7.Fhir.Model.MolecularSequence.QualityType>?)value!;
            return this;
          case "standardSequence":
            if (value is not (Hl7.Fhir.Model.CodeableConcept or null))
            {
              StandardSequence = OverflowNull<Hl7.Fhir.Model.CodeableConcept>.INSTANCE;
              Overflow["standardSequence"] = value;
            }
            else StandardSequence = (Hl7.Fhir.Model.CodeableConcept?)value;
            return this;
          case "start":
            if (value is not (Hl7.Fhir.Model.Integer or null))
            {
              StartElement = OverflowNull<Hl7.Fhir.Model.Integer>.INSTANCE;
              Overflow["start"] = value;
            }
            else StartElement = (Hl7.Fhir.Model.Integer?)value;
            return this;
          case "end":
            if (value is not (Hl7.Fhir.Model.Integer or null))
            {
              EndElement = OverflowNull<Hl7.Fhir.Model.Integer>.INSTANCE;
              Overflow["end"] = value;
            }
            else EndElement = (Hl7.Fhir.Model.Integer?)value;
            return this;
          case "score":
            if (value is not (Hl7.Fhir.Model.Quantity or null))
            {
              Score = OverflowNull<Hl7.Fhir.Model.Quantity>.INSTANCE;
              Overflow["score"] = value;
            }
            else Score = (Hl7.Fhir.Model.Quantity?)value;
            return this;
          case "method":
            if (value is not (Hl7.Fhir.Model.CodeableConcept or null))
            {
              Method = OverflowNull<Hl7.Fhir.Model.CodeableConcept>.INSTANCE;
              Overflow["method"] = value;
            }
            else Method = (Hl7.Fhir.Model.CodeableConcept?)value;
            return this;
          case "truthTP":
            if (value is not (Hl7.Fhir.Model.FhirDecimal or null))
            {
              TruthTPElement = OverflowNull<Hl7.Fhir.Model.FhirDecimal>.INSTANCE;
              Overflow["truthTP"] = value;
            }
            else TruthTPElement = (Hl7.Fhir.Model.FhirDecimal?)value;
            return this;
          case "queryTP":
            if (value is not (Hl7.Fhir.Model.FhirDecimal or null))
            {
              QueryTPElement = OverflowNull<Hl7.Fhir.Model.FhirDecimal>.INSTANCE;
              Overflow["queryTP"] = value;
            }
            else QueryTPElement = (Hl7.Fhir.Model.FhirDecimal?)value;
            return this;
          case "truthFN":
            if (value is not (Hl7.Fhir.Model.FhirDecimal or null))
            {
              TruthFNElement = OverflowNull<Hl7.Fhir.Model.FhirDecimal>.INSTANCE;
              Overflow["truthFN"] = value;
            }
            else TruthFNElement = (Hl7.Fhir.Model.FhirDecimal?)value;
            return this;
          case "queryFP":
            if (value is not (Hl7.Fhir.Model.FhirDecimal or null))
            {
              QueryFPElement = OverflowNull<Hl7.Fhir.Model.FhirDecimal>.INSTANCE;
              Overflow["queryFP"] = value;
            }
            else QueryFPElement = (Hl7.Fhir.Model.FhirDecimal?)value;
            return this;
          case "gtFP":
            if (value is not (Hl7.Fhir.Model.FhirDecimal or null))
            {
              GtFPElement = OverflowNull<Hl7.Fhir.Model.FhirDecimal>.INSTANCE;
              Overflow["gtFP"] = value;
            }
            else GtFPElement = (Hl7.Fhir.Model.FhirDecimal?)value;
            return this;
          case "precision":
            if (value is not (Hl7.Fhir.Model.FhirDecimal or null))
            {
              PrecisionElement = OverflowNull<Hl7.Fhir.Model.FhirDecimal>.INSTANCE;
              Overflow["precision"] = value;
            }
            else PrecisionElement = (Hl7.Fhir.Model.FhirDecimal?)value;
            return this;
          case "recall":
            if (value is not (Hl7.Fhir.Model.FhirDecimal or null))
            {
              RecallElement = OverflowNull<Hl7.Fhir.Model.FhirDecimal>.INSTANCE;
              Overflow["recall"] = value;
            }
            else RecallElement = (Hl7.Fhir.Model.FhirDecimal?)value;
            return this;
          case "fScore":
            if (value is not (Hl7.Fhir.Model.FhirDecimal or null))
            {
              FScoreElement = OverflowNull<Hl7.Fhir.Model.FhirDecimal>.INSTANCE;
              Overflow["fScore"] = value;
            }
            else FScoreElement = (Hl7.Fhir.Model.FhirDecimal?)value;
            return this;
          case "roc":
            if (value is not (Hl7.Fhir.Model.MolecularSequence.RocComponent or null))
            {
              Roc = OverflowNull<Hl7.Fhir.Model.MolecularSequence.RocComponent>.INSTANCE;
              Overflow["roc"] = value;
            }
            else Roc = (Hl7.Fhir.Model.MolecularSequence.RocComponent?)value;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_TypeElement is not null && !_TypeElement.InOverflow<Code<Hl7.Fhir.Model.MolecularSequence.QualityType>>()) yield return new KeyValuePair<string,object>("type",_TypeElement);
        if (_StandardSequence is not null && !_StandardSequence.InOverflow<Hl7.Fhir.Model.CodeableConcept>()) yield return new KeyValuePair<string,object>("standardSequence",_StandardSequence);
        if (_StartElement is not null && !_StartElement.InOverflow<Hl7.Fhir.Model.Integer>()) yield return new KeyValuePair<string,object>("start",_StartElement);
        if (_EndElement is not null && !_EndElement.InOverflow<Hl7.Fhir.Model.Integer>()) yield return new KeyValuePair<string,object>("end",_EndElement);
        if (_Score is not null && !_Score.InOverflow<Hl7.Fhir.Model.Quantity>()) yield return new KeyValuePair<string,object>("score",_Score);
        if (_Method is not null && !_Method.InOverflow<Hl7.Fhir.Model.CodeableConcept>()) yield return new KeyValuePair<string,object>("method",_Method);
        if (_TruthTPElement is not null && !_TruthTPElement.InOverflow<Hl7.Fhir.Model.FhirDecimal>()) yield return new KeyValuePair<string,object>("truthTP",_TruthTPElement);
        if (_QueryTPElement is not null && !_QueryTPElement.InOverflow<Hl7.Fhir.Model.FhirDecimal>()) yield return new KeyValuePair<string,object>("queryTP",_QueryTPElement);
        if (_TruthFNElement is not null && !_TruthFNElement.InOverflow<Hl7.Fhir.Model.FhirDecimal>()) yield return new KeyValuePair<string,object>("truthFN",_TruthFNElement);
        if (_QueryFPElement is not null && !_QueryFPElement.InOverflow<Hl7.Fhir.Model.FhirDecimal>()) yield return new KeyValuePair<string,object>("queryFP",_QueryFPElement);
        if (_GtFPElement is not null && !_GtFPElement.InOverflow<Hl7.Fhir.Model.FhirDecimal>()) yield return new KeyValuePair<string,object>("gtFP",_GtFPElement);
        if (_PrecisionElement is not null && !_PrecisionElement.InOverflow<Hl7.Fhir.Model.FhirDecimal>()) yield return new KeyValuePair<string,object>("precision",_PrecisionElement);
        if (_RecallElement is not null && !_RecallElement.InOverflow<Hl7.Fhir.Model.FhirDecimal>()) yield return new KeyValuePair<string,object>("recall",_RecallElement);
        if (_FScoreElement is not null && !_FScoreElement.InOverflow<Hl7.Fhir.Model.FhirDecimal>()) yield return new KeyValuePair<string,object>("fScore",_FScoreElement);
        if (_Roc is not null && !_Roc.InOverflow<Hl7.Fhir.Model.MolecularSequence.RocComponent>()) yield return new KeyValuePair<string,object>("roc",_Roc);
      }

    }

    /// <summary>
    /// Receiver Operator Characteristic (ROC) Curve
    /// </summary>
    /// <remarks>
    /// Receiver Operator Characteristic (ROC) Curve  to give sensitivity/specificity tradeoff.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("MolecularSequence.quality.roc", IsBackboneType=true)]
    public partial class RocComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "MolecularSequence.quality.roc";

      /// <summary>
      /// Genotype quality score.
      /// </summary>
      [FhirElement("score", InSummary=true, Order=40)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.Integer> ScoreElement
      {
        get
        {
          if(_ScoreElement.InOverflow<List<Hl7.Fhir.Model.Integer>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.Integer>), Overflow["score"]);
          return _ScoreElement ??= [];
        }

        set
        {
          if (_ScoreElement.InOverflow<List<Hl7.Fhir.Model.Integer>>())
            Overflow.Remove("score");
          _ScoreElement = value;
          OnPropertyChanged("ScoreElement");
        }

      }

      private List<Hl7.Fhir.Model.Integer>? _ScoreElement;

      /// <summary>
      /// Genotype quality score
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public IEnumerable<int?> Score
      {
        get => _ScoreElement?.Select(elem => elem.Value) ?? [];
        set
        {
          if (value == null)
            ScoreElement = null!;
          else
            ScoreElement = new List<Hl7.Fhir.Model.Integer>(value.Select(elem=>new Hl7.Fhir.Model.Integer(elem)));
          OnPropertyChanged("Score");
        }
      }

      /// <summary>
      /// Roc score true positive numbers.
      /// </summary>
      [FhirElement("numTP", InSummary=true, Order=50)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.Integer> NumTPElement
      {
        get
        {
          if(_NumTPElement.InOverflow<List<Hl7.Fhir.Model.Integer>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.Integer>), Overflow["numTP"]);
          return _NumTPElement ??= [];
        }

        set
        {
          if (_NumTPElement.InOverflow<List<Hl7.Fhir.Model.Integer>>())
            Overflow.Remove("numTP");
          _NumTPElement = value;
          OnPropertyChanged("NumTPElement");
        }

      }

      private List<Hl7.Fhir.Model.Integer>? _NumTPElement;

      /// <summary>
      /// Roc score true positive numbers
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public IEnumerable<int?> NumTP
      {
        get => _NumTPElement?.Select(elem => elem.Value) ?? [];
        set
        {
          if (value == null)
            NumTPElement = null!;
          else
            NumTPElement = new List<Hl7.Fhir.Model.Integer>(value.Select(elem=>new Hl7.Fhir.Model.Integer(elem)));
          OnPropertyChanged("NumTP");
        }
      }

      /// <summary>
      /// Roc score false positive numbers.
      /// </summary>
      [FhirElement("numFP", InSummary=true, Order=60)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.Integer> NumFPElement
      {
        get
        {
          if(_NumFPElement.InOverflow<List<Hl7.Fhir.Model.Integer>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.Integer>), Overflow["numFP"]);
          return _NumFPElement ??= [];
        }

        set
        {
          if (_NumFPElement.InOverflow<List<Hl7.Fhir.Model.Integer>>())
            Overflow.Remove("numFP");
          _NumFPElement = value;
          OnPropertyChanged("NumFPElement");
        }

      }

      private List<Hl7.Fhir.Model.Integer>? _NumFPElement;

      /// <summary>
      /// Roc score false positive numbers
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public IEnumerable<int?> NumFP
      {
        get => _NumFPElement?.Select(elem => elem.Value) ?? [];
        set
        {
          if (value == null)
            NumFPElement = null!;
          else
            NumFPElement = new List<Hl7.Fhir.Model.Integer>(value.Select(elem=>new Hl7.Fhir.Model.Integer(elem)));
          OnPropertyChanged("NumFP");
        }
      }

      /// <summary>
      /// Roc score false negative numbers.
      /// </summary>
      [FhirElement("numFN", InSummary=true, Order=70)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.Integer> NumFNElement
      {
        get
        {
          if(_NumFNElement.InOverflow<List<Hl7.Fhir.Model.Integer>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.Integer>), Overflow["numFN"]);
          return _NumFNElement ??= [];
        }

        set
        {
          if (_NumFNElement.InOverflow<List<Hl7.Fhir.Model.Integer>>())
            Overflow.Remove("numFN");
          _NumFNElement = value;
          OnPropertyChanged("NumFNElement");
        }

      }

      private List<Hl7.Fhir.Model.Integer>? _NumFNElement;

      /// <summary>
      /// Roc score false negative numbers
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public IEnumerable<int?> NumFN
      {
        get => _NumFNElement?.Select(elem => elem.Value) ?? [];
        set
        {
          if (value == null)
            NumFNElement = null!;
          else
            NumFNElement = new List<Hl7.Fhir.Model.Integer>(value.Select(elem=>new Hl7.Fhir.Model.Integer(elem)));
          OnPropertyChanged("NumFN");
        }
      }

      /// <summary>
      /// Precision of the GQ score.
      /// </summary>
      [FhirElement("precision", InSummary=true, Order=80)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.FhirDecimal> PrecisionElement
      {
        get
        {
          if(_PrecisionElement.InOverflow<List<Hl7.Fhir.Model.FhirDecimal>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.FhirDecimal>), Overflow["precision"]);
          return _PrecisionElement ??= [];
        }

        set
        {
          if (_PrecisionElement.InOverflow<List<Hl7.Fhir.Model.FhirDecimal>>())
            Overflow.Remove("precision");
          _PrecisionElement = value;
          OnPropertyChanged("PrecisionElement");
        }

      }

      private List<Hl7.Fhir.Model.FhirDecimal>? _PrecisionElement;

      /// <summary>
      /// Precision of the GQ score
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public IEnumerable<decimal?> Precision
      {
        get => _PrecisionElement?.Select(elem => elem.Value) ?? [];
        set
        {
          if (value == null)
            PrecisionElement = null!;
          else
            PrecisionElement = new List<Hl7.Fhir.Model.FhirDecimal>(value.Select(elem=>new Hl7.Fhir.Model.FhirDecimal(elem)));
          OnPropertyChanged("Precision");
        }
      }

      /// <summary>
      /// Sensitivity of the GQ score.
      /// </summary>
      [FhirElement("sensitivity", InSummary=true, Order=90)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.FhirDecimal> SensitivityElement
      {
        get
        {
          if(_SensitivityElement.InOverflow<List<Hl7.Fhir.Model.FhirDecimal>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.FhirDecimal>), Overflow["sensitivity"]);
          return _SensitivityElement ??= [];
        }

        set
        {
          if (_SensitivityElement.InOverflow<List<Hl7.Fhir.Model.FhirDecimal>>())
            Overflow.Remove("sensitivity");
          _SensitivityElement = value;
          OnPropertyChanged("SensitivityElement");
        }

      }

      private List<Hl7.Fhir.Model.FhirDecimal>? _SensitivityElement;

      /// <summary>
      /// Sensitivity of the GQ score
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public IEnumerable<decimal?> Sensitivity
      {
        get => _SensitivityElement?.Select(elem => elem.Value) ?? [];
        set
        {
          if (value == null)
            SensitivityElement = null!;
          else
            SensitivityElement = new List<Hl7.Fhir.Model.FhirDecimal>(value.Select(elem=>new Hl7.Fhir.Model.FhirDecimal(elem)));
          OnPropertyChanged("Sensitivity");
        }
      }

      /// <summary>
      /// FScore of the GQ score.
      /// </summary>
      [FhirElement("fMeasure", InSummary=true, Order=100)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.FhirDecimal> FMeasureElement
      {
        get
        {
          if(_FMeasureElement.InOverflow<List<Hl7.Fhir.Model.FhirDecimal>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.FhirDecimal>), Overflow["fMeasure"]);
          return _FMeasureElement ??= [];
        }

        set
        {
          if (_FMeasureElement.InOverflow<List<Hl7.Fhir.Model.FhirDecimal>>())
            Overflow.Remove("fMeasure");
          _FMeasureElement = value;
          OnPropertyChanged("FMeasureElement");
        }

      }

      private List<Hl7.Fhir.Model.FhirDecimal>? _FMeasureElement;

      /// <summary>
      /// FScore of the GQ score
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public IEnumerable<decimal?> FMeasure
      {
        get => _FMeasureElement?.Select(elem => elem.Value) ?? [];
        set
        {
          if (value == null)
            FMeasureElement = null!;
          else
            FMeasureElement = new List<Hl7.Fhir.Model.FhirDecimal>(value.Select(elem=>new Hl7.Fhir.Model.FhirDecimal(elem)));
          OnPropertyChanged("FMeasure");
        }
      }

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not RocComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_ScoreElement is not null) dest.ScoreElement = new List<Hl7.Fhir.Model.Integer>(_ScoreElement.DeepCopyInternal());
        if(_NumTPElement is not null) dest.NumTPElement = new List<Hl7.Fhir.Model.Integer>(_NumTPElement.DeepCopyInternal());
        if(_NumFPElement is not null) dest.NumFPElement = new List<Hl7.Fhir.Model.Integer>(_NumFPElement.DeepCopyInternal());
        if(_NumFNElement is not null) dest.NumFNElement = new List<Hl7.Fhir.Model.Integer>(_NumFNElement.DeepCopyInternal());
        if(_PrecisionElement is not null) dest.PrecisionElement = new List<Hl7.Fhir.Model.FhirDecimal>(_PrecisionElement.DeepCopyInternal());
        if(_SensitivityElement is not null) dest.SensitivityElement = new List<Hl7.Fhir.Model.FhirDecimal>(_SensitivityElement.DeepCopyInternal());
        if(_FMeasureElement is not null) dest.FMeasureElement = new List<Hl7.Fhir.Model.FhirDecimal>(_FMeasureElement.DeepCopyInternal());
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new RocComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not RocComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.ListEquals(_ScoreElement, otherT._ScoreElement)) return false;
        if(!comparer.ListEquals(_NumTPElement, otherT._NumTPElement)) return false;
        if(!comparer.ListEquals(_NumFPElement, otherT._NumFPElement)) return false;
        if(!comparer.ListEquals(_NumFNElement, otherT._NumFNElement)) return false;
        if(!comparer.ListEquals(_PrecisionElement, otherT._PrecisionElement)) return false;
        if(!comparer.ListEquals(_SensitivityElement, otherT._SensitivityElement)) return false;
        if(!comparer.ListEquals(_FMeasureElement, otherT._FMeasureElement)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "score":
            if (_ScoreElement.InOverflow<List<Hl7.Fhir.Model.Integer>>())
            {
              value = Overflow["score"];
              return true;
            }
            value = _ScoreElement;
            return (value as List<Hl7.Fhir.Model.Integer>)?.Any() is true;
          case "numTP":
            if (_NumTPElement.InOverflow<List<Hl7.Fhir.Model.Integer>>())
            {
              value = Overflow["numTP"];
              return true;
            }
            value = _NumTPElement;
            return (value as List<Hl7.Fhir.Model.Integer>)?.Any() is true;
          case "numFP":
            if (_NumFPElement.InOverflow<List<Hl7.Fhir.Model.Integer>>())
            {
              value = Overflow["numFP"];
              return true;
            }
            value = _NumFPElement;
            return (value as List<Hl7.Fhir.Model.Integer>)?.Any() is true;
          case "numFN":
            if (_NumFNElement.InOverflow<List<Hl7.Fhir.Model.Integer>>())
            {
              value = Overflow["numFN"];
              return true;
            }
            value = _NumFNElement;
            return (value as List<Hl7.Fhir.Model.Integer>)?.Any() is true;
          case "precision":
            if (_PrecisionElement.InOverflow<List<Hl7.Fhir.Model.FhirDecimal>>())
            {
              value = Overflow["precision"];
              return true;
            }
            value = _PrecisionElement;
            return (value as List<Hl7.Fhir.Model.FhirDecimal>)?.Any() is true;
          case "sensitivity":
            if (_SensitivityElement.InOverflow<List<Hl7.Fhir.Model.FhirDecimal>>())
            {
              value = Overflow["sensitivity"];
              return true;
            }
            value = _SensitivityElement;
            return (value as List<Hl7.Fhir.Model.FhirDecimal>)?.Any() is true;
          case "fMeasure":
            if (_FMeasureElement.InOverflow<List<Hl7.Fhir.Model.FhirDecimal>>())
            {
              value = Overflow["fMeasure"];
              return true;
            }
            value = _FMeasureElement;
            return (value as List<Hl7.Fhir.Model.FhirDecimal>)?.Any() is true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "score":
            if (value is not (List<Hl7.Fhir.Model.Integer> or null))
            {
              ScoreElement = OverflowNull<List<Hl7.Fhir.Model.Integer>>.INSTANCE;
              Overflow["score"] = value;
            }
            else ScoreElement = (List<Hl7.Fhir.Model.Integer>?)value!;
            return this;
          case "numTP":
            if (value is not (List<Hl7.Fhir.Model.Integer> or null))
            {
              NumTPElement = OverflowNull<List<Hl7.Fhir.Model.Integer>>.INSTANCE;
              Overflow["numTP"] = value;
            }
            else NumTPElement = (List<Hl7.Fhir.Model.Integer>?)value!;
            return this;
          case "numFP":
            if (value is not (List<Hl7.Fhir.Model.Integer> or null))
            {
              NumFPElement = OverflowNull<List<Hl7.Fhir.Model.Integer>>.INSTANCE;
              Overflow["numFP"] = value;
            }
            else NumFPElement = (List<Hl7.Fhir.Model.Integer>?)value!;
            return this;
          case "numFN":
            if (value is not (List<Hl7.Fhir.Model.Integer> or null))
            {
              NumFNElement = OverflowNull<List<Hl7.Fhir.Model.Integer>>.INSTANCE;
              Overflow["numFN"] = value;
            }
            else NumFNElement = (List<Hl7.Fhir.Model.Integer>?)value!;
            return this;
          case "precision":
            if (value is not (List<Hl7.Fhir.Model.FhirDecimal> or null))
            {
              PrecisionElement = OverflowNull<List<Hl7.Fhir.Model.FhirDecimal>>.INSTANCE;
              Overflow["precision"] = value;
            }
            else PrecisionElement = (List<Hl7.Fhir.Model.FhirDecimal>?)value!;
            return this;
          case "sensitivity":
            if (value is not (List<Hl7.Fhir.Model.FhirDecimal> or null))
            {
              SensitivityElement = OverflowNull<List<Hl7.Fhir.Model.FhirDecimal>>.INSTANCE;
              Overflow["sensitivity"] = value;
            }
            else SensitivityElement = (List<Hl7.Fhir.Model.FhirDecimal>?)value!;
            return this;
          case "fMeasure":
            if (value is not (List<Hl7.Fhir.Model.FhirDecimal> or null))
            {
              FMeasureElement = OverflowNull<List<Hl7.Fhir.Model.FhirDecimal>>.INSTANCE;
              Overflow["fMeasure"] = value;
            }
            else FMeasureElement = (List<Hl7.Fhir.Model.FhirDecimal>?)value!;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_ScoreElement?.Any() is true && !_ScoreElement.InOverflow<List<Hl7.Fhir.Model.Integer>>()) yield return new KeyValuePair<string,object>("score",_ScoreElement);
        if (_NumTPElement?.Any() is true && !_NumTPElement.InOverflow<List<Hl7.Fhir.Model.Integer>>()) yield return new KeyValuePair<string,object>("numTP",_NumTPElement);
        if (_NumFPElement?.Any() is true && !_NumFPElement.InOverflow<List<Hl7.Fhir.Model.Integer>>()) yield return new KeyValuePair<string,object>("numFP",_NumFPElement);
        if (_NumFNElement?.Any() is true && !_NumFNElement.InOverflow<List<Hl7.Fhir.Model.Integer>>()) yield return new KeyValuePair<string,object>("numFN",_NumFNElement);
        if (_PrecisionElement?.Any() is true && !_PrecisionElement.InOverflow<List<Hl7.Fhir.Model.FhirDecimal>>()) yield return new KeyValuePair<string,object>("precision",_PrecisionElement);
        if (_SensitivityElement?.Any() is true && !_SensitivityElement.InOverflow<List<Hl7.Fhir.Model.FhirDecimal>>()) yield return new KeyValuePair<string,object>("sensitivity",_SensitivityElement);
        if (_FMeasureElement?.Any() is true && !_FMeasureElement.InOverflow<List<Hl7.Fhir.Model.FhirDecimal>>()) yield return new KeyValuePair<string,object>("fMeasure",_FMeasureElement);
      }

    }

    /// <summary>
    /// External repository which contains detailed report related with observedSeq in this resource
    /// </summary>
    /// <remarks>
    /// Configurations of the external repository. The repository shall store target's observedSeq or records related with target's observedSeq.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("MolecularSequence.repository", IsBackboneType=true)]
    public partial class RepositoryComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "MolecularSequence.repository";

      /// <summary>
      /// directlink | openapi | login | oauth | other.
      /// </summary>
      [FhirElement("type", InSummary=true, Order=40)]
      [Binding("repositoryType")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Code<Hl7.Fhir.Model.MolecularSequence.RepositoryType> TypeElement
      {
        get
        {
          if(_TypeElement.InOverflow<Code<Hl7.Fhir.Model.MolecularSequence.RepositoryType>>())
            throw CodedValidationException.FromTypes(typeof(Code<Hl7.Fhir.Model.MolecularSequence.RepositoryType>), Overflow["type"]);
          return _TypeElement!;
        }

        set
        {
          if (_TypeElement.InOverflow<Code<Hl7.Fhir.Model.MolecularSequence.RepositoryType>>())
            Overflow.Remove("type");
          _TypeElement = value;
          OnPropertyChanged("TypeElement");
        }

      }

      private Code<Hl7.Fhir.Model.MolecularSequence.RepositoryType>? _TypeElement;

      /// <summary>
      /// directlink | openapi | login | oauth | other
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public Hl7.Fhir.Model.MolecularSequence.RepositoryType? Type
      {
        get => TypeElement?.Value;
        set
        {
          TypeElement = value is null ? null! : new Code<Hl7.Fhir.Model.MolecularSequence.RepositoryType>(value);
          OnPropertyChanged("Type");
        }
      }

      /// <summary>
      /// URI of the repository.
      /// </summary>
      [FhirElement("url", InSummary=true, Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.FhirUri? UrlElement
      {
        get
        {
          if(_UrlElement.InOverflow<Hl7.Fhir.Model.FhirUri>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirUri), Overflow["url"]);
          return _UrlElement;
        }

        set
        {
          if (_UrlElement.InOverflow<Hl7.Fhir.Model.FhirUri>())
            Overflow.Remove("url");
          _UrlElement = value;
          OnPropertyChanged("UrlElement");
        }

      }

      private Hl7.Fhir.Model.FhirUri? _UrlElement;

      /// <summary>
      /// URI of the repository
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? Url
      {
        get => UrlElement?.Value;
        set
        {
          UrlElement = value is null ? null! : new Hl7.Fhir.Model.FhirUri(value);
          OnPropertyChanged("Url");
        }
      }

      /// <summary>
      /// Repository's name.
      /// </summary>
      [FhirElement("name", InSummary=true, Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString? NameElement
      {
        get
        {
          if(_NameElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirString), Overflow["name"]);
          return _NameElement;
        }

        set
        {
          if (_NameElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            Overflow.Remove("name");
          _NameElement = value;
          OnPropertyChanged("NameElement");
        }

      }

      private Hl7.Fhir.Model.FhirString? _NameElement;

      /// <summary>
      /// Repository's name
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? Name
      {
        get => NameElement?.Value;
        set
        {
          NameElement = value is null ? null! : new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Name");
        }
      }

      /// <summary>
      /// Id of the dataset that used to call for dataset in repository.
      /// </summary>
      [FhirElement("datasetId", InSummary=true, Order=70)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString? DatasetIdElement
      {
        get
        {
          if(_DatasetIdElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirString), Overflow["datasetId"]);
          return _DatasetIdElement;
        }

        set
        {
          if (_DatasetIdElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            Overflow.Remove("datasetId");
          _DatasetIdElement = value;
          OnPropertyChanged("DatasetIdElement");
        }

      }

      private Hl7.Fhir.Model.FhirString? _DatasetIdElement;

      /// <summary>
      /// Id of the dataset that used to call for dataset in repository
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? DatasetId
      {
        get => DatasetIdElement?.Value;
        set
        {
          DatasetIdElement = value is null ? null! : new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("DatasetId");
        }
      }

      /// <summary>
      /// Id of the variantset that used to call for variantset in repository.
      /// </summary>
      [FhirElement("variantsetId", InSummary=true, Order=80)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString? VariantsetIdElement
      {
        get
        {
          if(_VariantsetIdElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirString), Overflow["variantsetId"]);
          return _VariantsetIdElement;
        }

        set
        {
          if (_VariantsetIdElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            Overflow.Remove("variantsetId");
          _VariantsetIdElement = value;
          OnPropertyChanged("VariantsetIdElement");
        }

      }

      private Hl7.Fhir.Model.FhirString? _VariantsetIdElement;

      /// <summary>
      /// Id of the variantset that used to call for variantset in repository
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? VariantsetId
      {
        get => VariantsetIdElement?.Value;
        set
        {
          VariantsetIdElement = value is null ? null! : new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("VariantsetId");
        }
      }

      /// <summary>
      /// Id of the read.
      /// </summary>
      [FhirElement("readsetId", InSummary=true, Order=90)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString? ReadsetIdElement
      {
        get
        {
          if(_ReadsetIdElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirString), Overflow["readsetId"]);
          return _ReadsetIdElement;
        }

        set
        {
          if (_ReadsetIdElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            Overflow.Remove("readsetId");
          _ReadsetIdElement = value;
          OnPropertyChanged("ReadsetIdElement");
        }

      }

      private Hl7.Fhir.Model.FhirString? _ReadsetIdElement;

      /// <summary>
      /// Id of the read
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? ReadsetId
      {
        get => ReadsetIdElement?.Value;
        set
        {
          ReadsetIdElement = value is null ? null! : new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("ReadsetId");
        }
      }

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not RepositoryComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_TypeElement is not null) dest.TypeElement = (Code<Hl7.Fhir.Model.MolecularSequence.RepositoryType>)_TypeElement.DeepCopyInternal();
        if(_UrlElement is not null) dest.UrlElement = (Hl7.Fhir.Model.FhirUri)_UrlElement.DeepCopyInternal();
        if(_NameElement is not null) dest.NameElement = (Hl7.Fhir.Model.FhirString)_NameElement.DeepCopyInternal();
        if(_DatasetIdElement is not null) dest.DatasetIdElement = (Hl7.Fhir.Model.FhirString)_DatasetIdElement.DeepCopyInternal();
        if(_VariantsetIdElement is not null) dest.VariantsetIdElement = (Hl7.Fhir.Model.FhirString)_VariantsetIdElement.DeepCopyInternal();
        if(_ReadsetIdElement is not null) dest.ReadsetIdElement = (Hl7.Fhir.Model.FhirString)_ReadsetIdElement.DeepCopyInternal();
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new RepositoryComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not RepositoryComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_TypeElement, otherT._TypeElement)) return false;
        if(!comparer.Equals(_UrlElement, otherT._UrlElement)) return false;
        if(!comparer.Equals(_NameElement, otherT._NameElement)) return false;
        if(!comparer.Equals(_DatasetIdElement, otherT._DatasetIdElement)) return false;
        if(!comparer.Equals(_VariantsetIdElement, otherT._VariantsetIdElement)) return false;
        if(!comparer.Equals(_ReadsetIdElement, otherT._ReadsetIdElement)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "type":
            if (_TypeElement.InOverflow<Code<Hl7.Fhir.Model.MolecularSequence.RepositoryType>>())
            {
              value = Overflow["type"];
              return true;
            }
            value = _TypeElement;
            return (value as Code<Hl7.Fhir.Model.MolecularSequence.RepositoryType>) is not null;
          case "url":
            if (_UrlElement.InOverflow<Hl7.Fhir.Model.FhirUri>())
            {
              value = Overflow["url"];
              return true;
            }
            value = _UrlElement;
            return (value as Hl7.Fhir.Model.FhirUri) is not null;
          case "name":
            if (_NameElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            {
              value = Overflow["name"];
              return true;
            }
            value = _NameElement;
            return (value as Hl7.Fhir.Model.FhirString) is not null;
          case "datasetId":
            if (_DatasetIdElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            {
              value = Overflow["datasetId"];
              return true;
            }
            value = _DatasetIdElement;
            return (value as Hl7.Fhir.Model.FhirString) is not null;
          case "variantsetId":
            if (_VariantsetIdElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            {
              value = Overflow["variantsetId"];
              return true;
            }
            value = _VariantsetIdElement;
            return (value as Hl7.Fhir.Model.FhirString) is not null;
          case "readsetId":
            if (_ReadsetIdElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            {
              value = Overflow["readsetId"];
              return true;
            }
            value = _ReadsetIdElement;
            return (value as Hl7.Fhir.Model.FhirString) is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "type":
            if (value is not (Code<Hl7.Fhir.Model.MolecularSequence.RepositoryType> or null))
            {
              TypeElement = OverflowNull<Code<Hl7.Fhir.Model.MolecularSequence.RepositoryType>>.INSTANCE;
              Overflow["type"] = value;
            }
            else TypeElement = (Code<Hl7.Fhir.Model.MolecularSequence.RepositoryType>?)value!;
            return this;
          case "url":
            if (value is not (Hl7.Fhir.Model.FhirUri or null))
            {
              UrlElement = OverflowNull<Hl7.Fhir.Model.FhirUri>.INSTANCE;
              Overflow["url"] = value;
            }
            else UrlElement = (Hl7.Fhir.Model.FhirUri?)value;
            return this;
          case "name":
            if (value is not (Hl7.Fhir.Model.FhirString or null))
            {
              NameElement = OverflowNull<Hl7.Fhir.Model.FhirString>.INSTANCE;
              Overflow["name"] = value;
            }
            else NameElement = (Hl7.Fhir.Model.FhirString?)value;
            return this;
          case "datasetId":
            if (value is not (Hl7.Fhir.Model.FhirString or null))
            {
              DatasetIdElement = OverflowNull<Hl7.Fhir.Model.FhirString>.INSTANCE;
              Overflow["datasetId"] = value;
            }
            else DatasetIdElement = (Hl7.Fhir.Model.FhirString?)value;
            return this;
          case "variantsetId":
            if (value is not (Hl7.Fhir.Model.FhirString or null))
            {
              VariantsetIdElement = OverflowNull<Hl7.Fhir.Model.FhirString>.INSTANCE;
              Overflow["variantsetId"] = value;
            }
            else VariantsetIdElement = (Hl7.Fhir.Model.FhirString?)value;
            return this;
          case "readsetId":
            if (value is not (Hl7.Fhir.Model.FhirString or null))
            {
              ReadsetIdElement = OverflowNull<Hl7.Fhir.Model.FhirString>.INSTANCE;
              Overflow["readsetId"] = value;
            }
            else ReadsetIdElement = (Hl7.Fhir.Model.FhirString?)value;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_TypeElement is not null && !_TypeElement.InOverflow<Code<Hl7.Fhir.Model.MolecularSequence.RepositoryType>>()) yield return new KeyValuePair<string,object>("type",_TypeElement);
        if (_UrlElement is not null && !_UrlElement.InOverflow<Hl7.Fhir.Model.FhirUri>()) yield return new KeyValuePair<string,object>("url",_UrlElement);
        if (_NameElement is not null && !_NameElement.InOverflow<Hl7.Fhir.Model.FhirString>()) yield return new KeyValuePair<string,object>("name",_NameElement);
        if (_DatasetIdElement is not null && !_DatasetIdElement.InOverflow<Hl7.Fhir.Model.FhirString>()) yield return new KeyValuePair<string,object>("datasetId",_DatasetIdElement);
        if (_VariantsetIdElement is not null && !_VariantsetIdElement.InOverflow<Hl7.Fhir.Model.FhirString>()) yield return new KeyValuePair<string,object>("variantsetId",_VariantsetIdElement);
        if (_ReadsetIdElement is not null && !_ReadsetIdElement.InOverflow<Hl7.Fhir.Model.FhirString>()) yield return new KeyValuePair<string,object>("readsetId",_ReadsetIdElement);
      }

    }

    /// <summary>
    /// Structural variant
    /// </summary>
    /// <remarks>
    /// Information about chromosome structure variation.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("MolecularSequence.structureVariant", IsBackboneType=true)]
    public partial class StructureVariantComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "MolecularSequence.structureVariant";

      /// <summary>
      /// Structural variant change type.
      /// </summary>
      [FhirElement("variantType", InSummary=true, Order=40)]
      [Binding("LOINC LL379-9 answerlist")]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept? VariantType
      {
        get
        {
          if(_VariantType.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.CodeableConcept), Overflow["variantType"]);
          return _VariantType;
        }

        set
        {
          if (_VariantType.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            Overflow.Remove("variantType");
          _VariantType = value;
          OnPropertyChanged("VariantType");
        }

      }

      private Hl7.Fhir.Model.CodeableConcept? _VariantType;

      /// <summary>
      /// Does the structural variant have base pair resolution breakpoints?.
      /// </summary>
      [FhirElement("exact", InSummary=true, Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.FhirBoolean? ExactElement
      {
        get
        {
          if(_ExactElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirBoolean), Overflow["exact"]);
          return _ExactElement;
        }

        set
        {
          if (_ExactElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>())
            Overflow.Remove("exact");
          _ExactElement = value;
          OnPropertyChanged("ExactElement");
        }

      }

      private Hl7.Fhir.Model.FhirBoolean? _ExactElement;

      /// <summary>
      /// Does the structural variant have base pair resolution breakpoints?
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public bool? Exact
      {
        get => ExactElement?.Value;
        set
        {
          ExactElement = value is null ? null! : new Hl7.Fhir.Model.FhirBoolean(value);
          OnPropertyChanged("Exact");
        }
      }

      /// <summary>
      /// Structural variant length.
      /// </summary>
      [FhirElement("length", InSummary=true, Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.Integer? LengthElement
      {
        get
        {
          if(_LengthElement.InOverflow<Hl7.Fhir.Model.Integer>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Integer), Overflow["length"]);
          return _LengthElement;
        }

        set
        {
          if (_LengthElement.InOverflow<Hl7.Fhir.Model.Integer>())
            Overflow.Remove("length");
          _LengthElement = value;
          OnPropertyChanged("LengthElement");
        }

      }

      private Hl7.Fhir.Model.Integer? _LengthElement;

      /// <summary>
      /// Structural variant length
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? Length
      {
        get => LengthElement?.Value;
        set
        {
          LengthElement = value is null ? null! : new Hl7.Fhir.Model.Integer(value);
          OnPropertyChanged("Length");
        }
      }

      /// <summary>
      /// Structural variant outer.
      /// </summary>
      [FhirElement("outer", InSummary=true, Order=70)]
      [DataMember]
      public Hl7.Fhir.Model.MolecularSequence.OuterComponent? Outer
      {
        get
        {
          if(_Outer.InOverflow<Hl7.Fhir.Model.MolecularSequence.OuterComponent>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.MolecularSequence.OuterComponent), Overflow["outer"]);
          return _Outer;
        }

        set
        {
          if (_Outer.InOverflow<Hl7.Fhir.Model.MolecularSequence.OuterComponent>())
            Overflow.Remove("outer");
          _Outer = value;
          OnPropertyChanged("Outer");
        }

      }

      private Hl7.Fhir.Model.MolecularSequence.OuterComponent? _Outer;

      /// <summary>
      /// Structural variant inner.
      /// </summary>
      [FhirElement("inner", InSummary=true, Order=80)]
      [DataMember]
      public Hl7.Fhir.Model.MolecularSequence.InnerComponent? Inner
      {
        get
        {
          if(_Inner.InOverflow<Hl7.Fhir.Model.MolecularSequence.InnerComponent>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.MolecularSequence.InnerComponent), Overflow["inner"]);
          return _Inner;
        }

        set
        {
          if (_Inner.InOverflow<Hl7.Fhir.Model.MolecularSequence.InnerComponent>())
            Overflow.Remove("inner");
          _Inner = value;
          OnPropertyChanged("Inner");
        }

      }

      private Hl7.Fhir.Model.MolecularSequence.InnerComponent? _Inner;

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not StructureVariantComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_VariantType is not null) dest.VariantType = (Hl7.Fhir.Model.CodeableConcept)_VariantType.DeepCopyInternal();
        if(_ExactElement is not null) dest.ExactElement = (Hl7.Fhir.Model.FhirBoolean)_ExactElement.DeepCopyInternal();
        if(_LengthElement is not null) dest.LengthElement = (Hl7.Fhir.Model.Integer)_LengthElement.DeepCopyInternal();
        if(_Outer is not null) dest.Outer = (Hl7.Fhir.Model.MolecularSequence.OuterComponent)_Outer.DeepCopyInternal();
        if(_Inner is not null) dest.Inner = (Hl7.Fhir.Model.MolecularSequence.InnerComponent)_Inner.DeepCopyInternal();
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new StructureVariantComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not StructureVariantComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_VariantType, otherT._VariantType)) return false;
        if(!comparer.Equals(_ExactElement, otherT._ExactElement)) return false;
        if(!comparer.Equals(_LengthElement, otherT._LengthElement)) return false;
        if(!comparer.Equals(_Outer, otherT._Outer)) return false;
        if(!comparer.Equals(_Inner, otherT._Inner)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "variantType":
            if (_VariantType.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            {
              value = Overflow["variantType"];
              return true;
            }
            value = _VariantType;
            return (value as Hl7.Fhir.Model.CodeableConcept) is not null;
          case "exact":
            if (_ExactElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>())
            {
              value = Overflow["exact"];
              return true;
            }
            value = _ExactElement;
            return (value as Hl7.Fhir.Model.FhirBoolean) is not null;
          case "length":
            if (_LengthElement.InOverflow<Hl7.Fhir.Model.Integer>())
            {
              value = Overflow["length"];
              return true;
            }
            value = _LengthElement;
            return (value as Hl7.Fhir.Model.Integer) is not null;
          case "outer":
            if (_Outer.InOverflow<Hl7.Fhir.Model.MolecularSequence.OuterComponent>())
            {
              value = Overflow["outer"];
              return true;
            }
            value = _Outer;
            return (value as Hl7.Fhir.Model.MolecularSequence.OuterComponent) is not null;
          case "inner":
            if (_Inner.InOverflow<Hl7.Fhir.Model.MolecularSequence.InnerComponent>())
            {
              value = Overflow["inner"];
              return true;
            }
            value = _Inner;
            return (value as Hl7.Fhir.Model.MolecularSequence.InnerComponent) is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "variantType":
            if (value is not (Hl7.Fhir.Model.CodeableConcept or null))
            {
              VariantType = OverflowNull<Hl7.Fhir.Model.CodeableConcept>.INSTANCE;
              Overflow["variantType"] = value;
            }
            else VariantType = (Hl7.Fhir.Model.CodeableConcept?)value;
            return this;
          case "exact":
            if (value is not (Hl7.Fhir.Model.FhirBoolean or null))
            {
              ExactElement = OverflowNull<Hl7.Fhir.Model.FhirBoolean>.INSTANCE;
              Overflow["exact"] = value;
            }
            else ExactElement = (Hl7.Fhir.Model.FhirBoolean?)value;
            return this;
          case "length":
            if (value is not (Hl7.Fhir.Model.Integer or null))
            {
              LengthElement = OverflowNull<Hl7.Fhir.Model.Integer>.INSTANCE;
              Overflow["length"] = value;
            }
            else LengthElement = (Hl7.Fhir.Model.Integer?)value;
            return this;
          case "outer":
            if (value is not (Hl7.Fhir.Model.MolecularSequence.OuterComponent or null))
            {
              Outer = OverflowNull<Hl7.Fhir.Model.MolecularSequence.OuterComponent>.INSTANCE;
              Overflow["outer"] = value;
            }
            else Outer = (Hl7.Fhir.Model.MolecularSequence.OuterComponent?)value;
            return this;
          case "inner":
            if (value is not (Hl7.Fhir.Model.MolecularSequence.InnerComponent or null))
            {
              Inner = OverflowNull<Hl7.Fhir.Model.MolecularSequence.InnerComponent>.INSTANCE;
              Overflow["inner"] = value;
            }
            else Inner = (Hl7.Fhir.Model.MolecularSequence.InnerComponent?)value;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_VariantType is not null && !_VariantType.InOverflow<Hl7.Fhir.Model.CodeableConcept>()) yield return new KeyValuePair<string,object>("variantType",_VariantType);
        if (_ExactElement is not null && !_ExactElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>()) yield return new KeyValuePair<string,object>("exact",_ExactElement);
        if (_LengthElement is not null && !_LengthElement.InOverflow<Hl7.Fhir.Model.Integer>()) yield return new KeyValuePair<string,object>("length",_LengthElement);
        if (_Outer is not null && !_Outer.InOverflow<Hl7.Fhir.Model.MolecularSequence.OuterComponent>()) yield return new KeyValuePair<string,object>("outer",_Outer);
        if (_Inner is not null && !_Inner.InOverflow<Hl7.Fhir.Model.MolecularSequence.InnerComponent>()) yield return new KeyValuePair<string,object>("inner",_Inner);
      }

    }

    /// <summary>
    /// Structural variant outer
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("MolecularSequence.structureVariant.outer", IsBackboneType=true)]
    public partial class OuterComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "MolecularSequence.structureVariant.outer";

      /// <summary>
      /// Structural variant outer start.
      /// </summary>
      [FhirElement("start", InSummary=true, Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.Integer? StartElement
      {
        get
        {
          if(_StartElement.InOverflow<Hl7.Fhir.Model.Integer>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Integer), Overflow["start"]);
          return _StartElement;
        }

        set
        {
          if (_StartElement.InOverflow<Hl7.Fhir.Model.Integer>())
            Overflow.Remove("start");
          _StartElement = value;
          OnPropertyChanged("StartElement");
        }

      }

      private Hl7.Fhir.Model.Integer? _StartElement;

      /// <summary>
      /// Structural variant outer start
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? Start
      {
        get => StartElement?.Value;
        set
        {
          StartElement = value is null ? null! : new Hl7.Fhir.Model.Integer(value);
          OnPropertyChanged("Start");
        }
      }

      /// <summary>
      /// Structural variant outer end.
      /// </summary>
      [FhirElement("end", InSummary=true, Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.Integer? EndElement
      {
        get
        {
          if(_EndElement.InOverflow<Hl7.Fhir.Model.Integer>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Integer), Overflow["end"]);
          return _EndElement;
        }

        set
        {
          if (_EndElement.InOverflow<Hl7.Fhir.Model.Integer>())
            Overflow.Remove("end");
          _EndElement = value;
          OnPropertyChanged("EndElement");
        }

      }

      private Hl7.Fhir.Model.Integer? _EndElement;

      /// <summary>
      /// Structural variant outer end
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? End
      {
        get => EndElement?.Value;
        set
        {
          EndElement = value is null ? null! : new Hl7.Fhir.Model.Integer(value);
          OnPropertyChanged("End");
        }
      }

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not OuterComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_StartElement is not null) dest.StartElement = (Hl7.Fhir.Model.Integer)_StartElement.DeepCopyInternal();
        if(_EndElement is not null) dest.EndElement = (Hl7.Fhir.Model.Integer)_EndElement.DeepCopyInternal();
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new OuterComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not OuterComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_StartElement, otherT._StartElement)) return false;
        if(!comparer.Equals(_EndElement, otherT._EndElement)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "start":
            if (_StartElement.InOverflow<Hl7.Fhir.Model.Integer>())
            {
              value = Overflow["start"];
              return true;
            }
            value = _StartElement;
            return (value as Hl7.Fhir.Model.Integer) is not null;
          case "end":
            if (_EndElement.InOverflow<Hl7.Fhir.Model.Integer>())
            {
              value = Overflow["end"];
              return true;
            }
            value = _EndElement;
            return (value as Hl7.Fhir.Model.Integer) is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "start":
            if (value is not (Hl7.Fhir.Model.Integer or null))
            {
              StartElement = OverflowNull<Hl7.Fhir.Model.Integer>.INSTANCE;
              Overflow["start"] = value;
            }
            else StartElement = (Hl7.Fhir.Model.Integer?)value;
            return this;
          case "end":
            if (value is not (Hl7.Fhir.Model.Integer or null))
            {
              EndElement = OverflowNull<Hl7.Fhir.Model.Integer>.INSTANCE;
              Overflow["end"] = value;
            }
            else EndElement = (Hl7.Fhir.Model.Integer?)value;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_StartElement is not null && !_StartElement.InOverflow<Hl7.Fhir.Model.Integer>()) yield return new KeyValuePair<string,object>("start",_StartElement);
        if (_EndElement is not null && !_EndElement.InOverflow<Hl7.Fhir.Model.Integer>()) yield return new KeyValuePair<string,object>("end",_EndElement);
      }

    }

    /// <summary>
    /// Structural variant inner
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("MolecularSequence.structureVariant.inner", IsBackboneType=true)]
    public partial class InnerComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "MolecularSequence.structureVariant.inner";

      /// <summary>
      /// Structural variant inner start.
      /// </summary>
      [FhirElement("start", InSummary=true, Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.Integer? StartElement
      {
        get
        {
          if(_StartElement.InOverflow<Hl7.Fhir.Model.Integer>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Integer), Overflow["start"]);
          return _StartElement;
        }

        set
        {
          if (_StartElement.InOverflow<Hl7.Fhir.Model.Integer>())
            Overflow.Remove("start");
          _StartElement = value;
          OnPropertyChanged("StartElement");
        }

      }

      private Hl7.Fhir.Model.Integer? _StartElement;

      /// <summary>
      /// Structural variant inner start
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? Start
      {
        get => StartElement?.Value;
        set
        {
          StartElement = value is null ? null! : new Hl7.Fhir.Model.Integer(value);
          OnPropertyChanged("Start");
        }
      }

      /// <summary>
      /// Structural variant inner end.
      /// </summary>
      [FhirElement("end", InSummary=true, Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.Integer? EndElement
      {
        get
        {
          if(_EndElement.InOverflow<Hl7.Fhir.Model.Integer>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Integer), Overflow["end"]);
          return _EndElement;
        }

        set
        {
          if (_EndElement.InOverflow<Hl7.Fhir.Model.Integer>())
            Overflow.Remove("end");
          _EndElement = value;
          OnPropertyChanged("EndElement");
        }

      }

      private Hl7.Fhir.Model.Integer? _EndElement;

      /// <summary>
      /// Structural variant inner end
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? End
      {
        get => EndElement?.Value;
        set
        {
          EndElement = value is null ? null! : new Hl7.Fhir.Model.Integer(value);
          OnPropertyChanged("End");
        }
      }

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not InnerComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_StartElement is not null) dest.StartElement = (Hl7.Fhir.Model.Integer)_StartElement.DeepCopyInternal();
        if(_EndElement is not null) dest.EndElement = (Hl7.Fhir.Model.Integer)_EndElement.DeepCopyInternal();
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new InnerComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not InnerComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_StartElement, otherT._StartElement)) return false;
        if(!comparer.Equals(_EndElement, otherT._EndElement)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "start":
            if (_StartElement.InOverflow<Hl7.Fhir.Model.Integer>())
            {
              value = Overflow["start"];
              return true;
            }
            value = _StartElement;
            return (value as Hl7.Fhir.Model.Integer) is not null;
          case "end":
            if (_EndElement.InOverflow<Hl7.Fhir.Model.Integer>())
            {
              value = Overflow["end"];
              return true;
            }
            value = _EndElement;
            return (value as Hl7.Fhir.Model.Integer) is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "start":
            if (value is not (Hl7.Fhir.Model.Integer or null))
            {
              StartElement = OverflowNull<Hl7.Fhir.Model.Integer>.INSTANCE;
              Overflow["start"] = value;
            }
            else StartElement = (Hl7.Fhir.Model.Integer?)value;
            return this;
          case "end":
            if (value is not (Hl7.Fhir.Model.Integer or null))
            {
              EndElement = OverflowNull<Hl7.Fhir.Model.Integer>.INSTANCE;
              Overflow["end"] = value;
            }
            else EndElement = (Hl7.Fhir.Model.Integer?)value;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_StartElement is not null && !_StartElement.InOverflow<Hl7.Fhir.Model.Integer>()) yield return new KeyValuePair<string,object>("start",_StartElement);
        if (_EndElement is not null && !_EndElement.InOverflow<Hl7.Fhir.Model.Integer>()) yield return new KeyValuePair<string,object>("end",_EndElement);
      }

    }

    /// <summary>
    /// Unique ID for this particular sequence. This is a FHIR-defined id.
    /// </summary>
    [FhirElement("identifier", InSummary=true, Order=90, FiveWs="FiveWs.identifier")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Hl7.Fhir.Model.Identifier> Identifier
    {
      get
      {
        if(_Identifier.InOverflow<List<Hl7.Fhir.Model.Identifier>>())
          throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.Identifier>), Overflow["identifier"]);
        return _Identifier ??= [];
      }

      set
      {
        if (_Identifier.InOverflow<List<Hl7.Fhir.Model.Identifier>>())
          Overflow.Remove("identifier");
        _Identifier = value;
        OnPropertyChanged("Identifier");
      }

    }

    private List<Hl7.Fhir.Model.Identifier>? _Identifier;

    /// <summary>
    /// aa | dna | rna.
    /// </summary>
    [FhirElement("type", InSummary=true, Order=100)]
    [Binding("sequenceType")]
    [DataMember]
    public Code<Hl7.Fhir.Model.MolecularSequence.SequenceType>? TypeElement
    {
      get
      {
        if(_TypeElement.InOverflow<Code<Hl7.Fhir.Model.MolecularSequence.SequenceType>>())
          throw CodedValidationException.FromTypes(typeof(Code<Hl7.Fhir.Model.MolecularSequence.SequenceType>), Overflow["type"]);
        return _TypeElement;
      }

      set
      {
        if (_TypeElement.InOverflow<Code<Hl7.Fhir.Model.MolecularSequence.SequenceType>>())
          Overflow.Remove("type");
        _TypeElement = value;
        OnPropertyChanged("TypeElement");
      }

    }

    private Code<Hl7.Fhir.Model.MolecularSequence.SequenceType>? _TypeElement;

    /// <summary>
    /// aa | dna | rna
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public Hl7.Fhir.Model.MolecularSequence.SequenceType? Type
    {
      get => TypeElement?.Value;
      set
      {
        TypeElement = value is null ? null! : new Code<Hl7.Fhir.Model.MolecularSequence.SequenceType>(value);
        OnPropertyChanged("Type");
      }
    }

    /// <summary>
    /// Base number of coordinate system (0 for 0-based numbering or coordinates, inclusive start, exclusive end, 1 for 1-based numbering, inclusive start, inclusive end).
    /// </summary>
    [FhirElement("coordinateSystem", InSummary=true, Order=110)]
    [Cardinality(Min=1,Max=1)]
    [DataMember]
    public Hl7.Fhir.Model.Integer CoordinateSystemElement
    {
      get
      {
        if(_CoordinateSystemElement.InOverflow<Hl7.Fhir.Model.Integer>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Integer), Overflow["coordinateSystem"]);
        return _CoordinateSystemElement!;
      }

      set
      {
        if (_CoordinateSystemElement.InOverflow<Hl7.Fhir.Model.Integer>())
          Overflow.Remove("coordinateSystem");
        _CoordinateSystemElement = value;
        OnPropertyChanged("CoordinateSystemElement");
      }

    }

    private Hl7.Fhir.Model.Integer? _CoordinateSystemElement;

    /// <summary>
    /// Base number of coordinate system (0 for 0-based numbering or coordinates, inclusive start, exclusive end, 1 for 1-based numbering, inclusive start, inclusive end)
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public int? CoordinateSystem
    {
      get => CoordinateSystemElement?.Value;
      set
      {
        CoordinateSystemElement = value is null ? null! : new Hl7.Fhir.Model.Integer(value);
        OnPropertyChanged("CoordinateSystem");
      }
    }

    /// <summary>
    /// Who and/or what this is about.
    /// </summary>
    [FhirElement("patient", InSummary=true, Order=120)]
    [CLSCompliant(false)]
    [References("Patient")]
    [DataMember]
    public Hl7.Fhir.Model.ResourceReference? Patient
    {
      get
      {
        if(_Patient.InOverflow<Hl7.Fhir.Model.ResourceReference>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.ResourceReference), Overflow["patient"]);
        return _Patient;
      }

      set
      {
        if (_Patient.InOverflow<Hl7.Fhir.Model.ResourceReference>())
          Overflow.Remove("patient");
        _Patient = value;
        OnPropertyChanged("Patient");
      }

    }

    private Hl7.Fhir.Model.ResourceReference? _Patient;

    /// <summary>
    /// Specimen used for sequencing.
    /// </summary>
    [FhirElement("specimen", InSummary=true, Order=130)]
    [CLSCompliant(false)]
    [References("Specimen")]
    [DataMember]
    public Hl7.Fhir.Model.ResourceReference? Specimen
    {
      get
      {
        if(_Specimen.InOverflow<Hl7.Fhir.Model.ResourceReference>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.ResourceReference), Overflow["specimen"]);
        return _Specimen;
      }

      set
      {
        if (_Specimen.InOverflow<Hl7.Fhir.Model.ResourceReference>())
          Overflow.Remove("specimen");
        _Specimen = value;
        OnPropertyChanged("Specimen");
      }

    }

    private Hl7.Fhir.Model.ResourceReference? _Specimen;

    /// <summary>
    /// The method for sequencing.
    /// </summary>
    [FhirElement("device", InSummary=true, Order=140)]
    [CLSCompliant(false)]
    [References("Device")]
    [DataMember]
    public Hl7.Fhir.Model.ResourceReference? Device
    {
      get
      {
        if(_Device.InOverflow<Hl7.Fhir.Model.ResourceReference>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.ResourceReference), Overflow["device"]);
        return _Device;
      }

      set
      {
        if (_Device.InOverflow<Hl7.Fhir.Model.ResourceReference>())
          Overflow.Remove("device");
        _Device = value;
        OnPropertyChanged("Device");
      }

    }

    private Hl7.Fhir.Model.ResourceReference? _Device;

    /// <summary>
    /// Who should be responsible for test result.
    /// </summary>
    [FhirElement("performer", InSummary=true, Order=150)]
    [CLSCompliant(false)]
    [References("Organization")]
    [DataMember]
    public Hl7.Fhir.Model.ResourceReference? Performer
    {
      get
      {
        if(_Performer.InOverflow<Hl7.Fhir.Model.ResourceReference>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.ResourceReference), Overflow["performer"]);
        return _Performer;
      }

      set
      {
        if (_Performer.InOverflow<Hl7.Fhir.Model.ResourceReference>())
          Overflow.Remove("performer");
        _Performer = value;
        OnPropertyChanged("Performer");
      }

    }

    private Hl7.Fhir.Model.ResourceReference? _Performer;

    /// <summary>
    /// The number of copies of the sequence of interest.  (RNASeq).
    /// </summary>
    [FhirElement("quantity", InSummary=true, Order=160)]
    [DataMember]
    public Hl7.Fhir.Model.Quantity? Quantity
    {
      get
      {
        if(_Quantity.InOverflow<Hl7.Fhir.Model.Quantity>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Quantity), Overflow["quantity"]);
        return _Quantity;
      }

      set
      {
        if (_Quantity.InOverflow<Hl7.Fhir.Model.Quantity>())
          Overflow.Remove("quantity");
        _Quantity = value;
        OnPropertyChanged("Quantity");
      }

    }

    private Hl7.Fhir.Model.Quantity? _Quantity;

    /// <summary>
    /// A sequence used as reference.
    /// </summary>
    [FhirElement("referenceSeq", InSummary=true, Order=170)]
    [DataMember]
    public Hl7.Fhir.Model.MolecularSequence.ReferenceSeqComponent? ReferenceSeq
    {
      get
      {
        if(_ReferenceSeq.InOverflow<Hl7.Fhir.Model.MolecularSequence.ReferenceSeqComponent>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.MolecularSequence.ReferenceSeqComponent), Overflow["referenceSeq"]);
        return _ReferenceSeq;
      }

      set
      {
        if (_ReferenceSeq.InOverflow<Hl7.Fhir.Model.MolecularSequence.ReferenceSeqComponent>())
          Overflow.Remove("referenceSeq");
        _ReferenceSeq = value;
        OnPropertyChanged("ReferenceSeq");
      }

    }

    private Hl7.Fhir.Model.MolecularSequence.ReferenceSeqComponent? _ReferenceSeq;

    /// <summary>
    /// Variant in sequence.
    /// </summary>
    [FhirElement("variant", InSummary=true, Order=180)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Hl7.Fhir.Model.MolecularSequence.VariantComponent> Variant
    {
      get
      {
        if(_Variant.InOverflow<List<Hl7.Fhir.Model.MolecularSequence.VariantComponent>>())
          throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.MolecularSequence.VariantComponent>), Overflow["variant"]);
        return _Variant ??= [];
      }

      set
      {
        if (_Variant.InOverflow<List<Hl7.Fhir.Model.MolecularSequence.VariantComponent>>())
          Overflow.Remove("variant");
        _Variant = value;
        OnPropertyChanged("Variant");
      }

    }

    private List<Hl7.Fhir.Model.MolecularSequence.VariantComponent>? _Variant;

    /// <summary>
    /// Sequence that was observed.
    /// </summary>
    [FhirElement("observedSeq", InSummary=true, Order=190)]
    [DataMember]
    public Hl7.Fhir.Model.FhirString? ObservedSeqElement
    {
      get
      {
        if(_ObservedSeqElement.InOverflow<Hl7.Fhir.Model.FhirString>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirString), Overflow["observedSeq"]);
        return _ObservedSeqElement;
      }

      set
      {
        if (_ObservedSeqElement.InOverflow<Hl7.Fhir.Model.FhirString>())
          Overflow.Remove("observedSeq");
        _ObservedSeqElement = value;
        OnPropertyChanged("ObservedSeqElement");
      }

    }

    private Hl7.Fhir.Model.FhirString? _ObservedSeqElement;

    /// <summary>
    /// Sequence that was observed
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string? ObservedSeq
    {
      get => ObservedSeqElement?.Value;
      set
      {
        ObservedSeqElement = value is null ? null! : new Hl7.Fhir.Model.FhirString(value);
        OnPropertyChanged("ObservedSeq");
      }
    }

    /// <summary>
    /// An set of value as quality of sequence.
    /// </summary>
    [FhirElement("quality", InSummary=true, Order=200)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Hl7.Fhir.Model.MolecularSequence.QualityComponent> Quality
    {
      get
      {
        if(_Quality.InOverflow<List<Hl7.Fhir.Model.MolecularSequence.QualityComponent>>())
          throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.MolecularSequence.QualityComponent>), Overflow["quality"]);
        return _Quality ??= [];
      }

      set
      {
        if (_Quality.InOverflow<List<Hl7.Fhir.Model.MolecularSequence.QualityComponent>>())
          Overflow.Remove("quality");
        _Quality = value;
        OnPropertyChanged("Quality");
      }

    }

    private List<Hl7.Fhir.Model.MolecularSequence.QualityComponent>? _Quality;

    /// <summary>
    /// Average number of reads representing a given nucleotide in the reconstructed sequence.
    /// </summary>
    [FhirElement("readCoverage", InSummary=true, Order=210)]
    [DataMember]
    public Hl7.Fhir.Model.Integer? ReadCoverageElement
    {
      get
      {
        if(_ReadCoverageElement.InOverflow<Hl7.Fhir.Model.Integer>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Integer), Overflow["readCoverage"]);
        return _ReadCoverageElement;
      }

      set
      {
        if (_ReadCoverageElement.InOverflow<Hl7.Fhir.Model.Integer>())
          Overflow.Remove("readCoverage");
        _ReadCoverageElement = value;
        OnPropertyChanged("ReadCoverageElement");
      }

    }

    private Hl7.Fhir.Model.Integer? _ReadCoverageElement;

    /// <summary>
    /// Average number of reads representing a given nucleotide in the reconstructed sequence
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public int? ReadCoverage
    {
      get => ReadCoverageElement?.Value;
      set
      {
        ReadCoverageElement = value is null ? null! : new Hl7.Fhir.Model.Integer(value);
        OnPropertyChanged("ReadCoverage");
      }
    }

    /// <summary>
    /// External repository which contains detailed report related with observedSeq in this resource.
    /// </summary>
    [FhirElement("repository", InSummary=true, Order=220)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Hl7.Fhir.Model.MolecularSequence.RepositoryComponent> Repository
    {
      get
      {
        if(_Repository.InOverflow<List<Hl7.Fhir.Model.MolecularSequence.RepositoryComponent>>())
          throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.MolecularSequence.RepositoryComponent>), Overflow["repository"]);
        return _Repository ??= [];
      }

      set
      {
        if (_Repository.InOverflow<List<Hl7.Fhir.Model.MolecularSequence.RepositoryComponent>>())
          Overflow.Remove("repository");
        _Repository = value;
        OnPropertyChanged("Repository");
      }

    }

    private List<Hl7.Fhir.Model.MolecularSequence.RepositoryComponent>? _Repository;

    /// <summary>
    /// Pointer to next atomic sequence.
    /// </summary>
    [FhirElement("pointer", InSummary=true, Order=230)]
    [CLSCompliant(false)]
    [References("MolecularSequence")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Hl7.Fhir.Model.ResourceReference> Pointer
    {
      get
      {
        if(_Pointer.InOverflow<List<Hl7.Fhir.Model.ResourceReference>>())
          throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.ResourceReference>), Overflow["pointer"]);
        return _Pointer ??= [];
      }

      set
      {
        if (_Pointer.InOverflow<List<Hl7.Fhir.Model.ResourceReference>>())
          Overflow.Remove("pointer");
        _Pointer = value;
        OnPropertyChanged("Pointer");
      }

    }

    private List<Hl7.Fhir.Model.ResourceReference>? _Pointer;

    /// <summary>
    /// Structural variant.
    /// </summary>
    [FhirElement("structureVariant", InSummary=true, Order=240)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Hl7.Fhir.Model.MolecularSequence.StructureVariantComponent> StructureVariant
    {
      get
      {
        if(_StructureVariant.InOverflow<List<Hl7.Fhir.Model.MolecularSequence.StructureVariantComponent>>())
          throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.MolecularSequence.StructureVariantComponent>), Overflow["structureVariant"]);
        return _StructureVariant ??= [];
      }

      set
      {
        if (_StructureVariant.InOverflow<List<Hl7.Fhir.Model.MolecularSequence.StructureVariantComponent>>())
          Overflow.Remove("structureVariant");
        _StructureVariant = value;
        OnPropertyChanged("StructureVariant");
      }

    }

    private List<Hl7.Fhir.Model.MolecularSequence.StructureVariantComponent>? _StructureVariant;

    List<Identifier> IIdentifiable<List<Identifier>>.Identifier { get => Identifier; set => Identifier = value!; }

    protected internal override void CopyToInternal(Base other)
    {
      if(other is not MolecularSequence dest)
        throw new ArgumentException("Can only copy to an object of the same type", "other");

      base.CopyToInternal(dest);
      if(_Identifier is not null) dest.Identifier = new List<Hl7.Fhir.Model.Identifier>(_Identifier.DeepCopyInternal());
      if(_TypeElement is not null) dest.TypeElement = (Code<Hl7.Fhir.Model.MolecularSequence.SequenceType>)_TypeElement.DeepCopyInternal();
      if(_CoordinateSystemElement is not null) dest.CoordinateSystemElement = (Hl7.Fhir.Model.Integer)_CoordinateSystemElement.DeepCopyInternal();
      if(_Patient is not null) dest.Patient = (Hl7.Fhir.Model.ResourceReference)_Patient.DeepCopyInternal();
      if(_Specimen is not null) dest.Specimen = (Hl7.Fhir.Model.ResourceReference)_Specimen.DeepCopyInternal();
      if(_Device is not null) dest.Device = (Hl7.Fhir.Model.ResourceReference)_Device.DeepCopyInternal();
      if(_Performer is not null) dest.Performer = (Hl7.Fhir.Model.ResourceReference)_Performer.DeepCopyInternal();
      if(_Quantity is not null) dest.Quantity = (Hl7.Fhir.Model.Quantity)_Quantity.DeepCopyInternal();
      if(_ReferenceSeq is not null) dest.ReferenceSeq = (Hl7.Fhir.Model.MolecularSequence.ReferenceSeqComponent)_ReferenceSeq.DeepCopyInternal();
      if(_Variant is not null) dest.Variant = new List<Hl7.Fhir.Model.MolecularSequence.VariantComponent>(_Variant.DeepCopyInternal());
      if(_ObservedSeqElement is not null) dest.ObservedSeqElement = (Hl7.Fhir.Model.FhirString)_ObservedSeqElement.DeepCopyInternal();
      if(_Quality is not null) dest.Quality = new List<Hl7.Fhir.Model.MolecularSequence.QualityComponent>(_Quality.DeepCopyInternal());
      if(_ReadCoverageElement is not null) dest.ReadCoverageElement = (Hl7.Fhir.Model.Integer)_ReadCoverageElement.DeepCopyInternal();
      if(_Repository is not null) dest.Repository = new List<Hl7.Fhir.Model.MolecularSequence.RepositoryComponent>(_Repository.DeepCopyInternal());
      if(_Pointer is not null) dest.Pointer = new List<Hl7.Fhir.Model.ResourceReference>(_Pointer.DeepCopyInternal());
      if(_StructureVariant is not null) dest.StructureVariant = new List<Hl7.Fhir.Model.MolecularSequence.StructureVariantComponent>(_StructureVariant.DeepCopyInternal());
    }

    protected internal override Base DeepCopyInternal()
    {
      var instance = new MolecularSequence();
      CopyToInternal(instance);
      return instance;
    }

    public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
    {
      if(other is not MolecularSequence otherT) return false;

      if(!base.CompareChildren(otherT, comparer)) return false;
      #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
      if(!comparer.ListEquals(_Identifier, otherT._Identifier)) return false;
      if(!comparer.Equals(_TypeElement, otherT._TypeElement)) return false;
      if(!comparer.Equals(_CoordinateSystemElement, otherT._CoordinateSystemElement)) return false;
      if(!comparer.Equals(_Patient, otherT._Patient)) return false;
      if(!comparer.Equals(_Specimen, otherT._Specimen)) return false;
      if(!comparer.Equals(_Device, otherT._Device)) return false;
      if(!comparer.Equals(_Performer, otherT._Performer)) return false;
      if(!comparer.Equals(_Quantity, otherT._Quantity)) return false;
      if(!comparer.Equals(_ReferenceSeq, otherT._ReferenceSeq)) return false;
      if(!comparer.ListEquals(_Variant, otherT._Variant)) return false;
      if(!comparer.Equals(_ObservedSeqElement, otherT._ObservedSeqElement)) return false;
      if(!comparer.ListEquals(_Quality, otherT._Quality)) return false;
      if(!comparer.Equals(_ReadCoverageElement, otherT._ReadCoverageElement)) return false;
      if(!comparer.ListEquals(_Repository, otherT._Repository)) return false;
      if(!comparer.ListEquals(_Pointer, otherT._Pointer)) return false;
      if(!comparer.ListEquals(_StructureVariant, otherT._StructureVariant)) return false;
      #pragma warning restore CS8604 // Possible null reference argument.

      return true;
    }

    public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
    {
      switch (key)
      {
        case "identifier":
          if (_Identifier.InOverflow<List<Hl7.Fhir.Model.Identifier>>())
          {
            value = Overflow["identifier"];
            return true;
          }
          value = _Identifier;
          return (value as List<Hl7.Fhir.Model.Identifier>)?.Any() is true;
        case "type":
          if (_TypeElement.InOverflow<Code<Hl7.Fhir.Model.MolecularSequence.SequenceType>>())
          {
            value = Overflow["type"];
            return true;
          }
          value = _TypeElement;
          return (value as Code<Hl7.Fhir.Model.MolecularSequence.SequenceType>) is not null;
        case "coordinateSystem":
          if (_CoordinateSystemElement.InOverflow<Hl7.Fhir.Model.Integer>())
          {
            value = Overflow["coordinateSystem"];
            return true;
          }
          value = _CoordinateSystemElement;
          return (value as Hl7.Fhir.Model.Integer) is not null;
        case "patient":
          if (_Patient.InOverflow<Hl7.Fhir.Model.ResourceReference>())
          {
            value = Overflow["patient"];
            return true;
          }
          value = _Patient;
          return (value as Hl7.Fhir.Model.ResourceReference) is not null;
        case "specimen":
          if (_Specimen.InOverflow<Hl7.Fhir.Model.ResourceReference>())
          {
            value = Overflow["specimen"];
            return true;
          }
          value = _Specimen;
          return (value as Hl7.Fhir.Model.ResourceReference) is not null;
        case "device":
          if (_Device.InOverflow<Hl7.Fhir.Model.ResourceReference>())
          {
            value = Overflow["device"];
            return true;
          }
          value = _Device;
          return (value as Hl7.Fhir.Model.ResourceReference) is not null;
        case "performer":
          if (_Performer.InOverflow<Hl7.Fhir.Model.ResourceReference>())
          {
            value = Overflow["performer"];
            return true;
          }
          value = _Performer;
          return (value as Hl7.Fhir.Model.ResourceReference) is not null;
        case "quantity":
          if (_Quantity.InOverflow<Hl7.Fhir.Model.Quantity>())
          {
            value = Overflow["quantity"];
            return true;
          }
          value = _Quantity;
          return (value as Hl7.Fhir.Model.Quantity) is not null;
        case "referenceSeq":
          if (_ReferenceSeq.InOverflow<Hl7.Fhir.Model.MolecularSequence.ReferenceSeqComponent>())
          {
            value = Overflow["referenceSeq"];
            return true;
          }
          value = _ReferenceSeq;
          return (value as Hl7.Fhir.Model.MolecularSequence.ReferenceSeqComponent) is not null;
        case "variant":
          if (_Variant.InOverflow<List<Hl7.Fhir.Model.MolecularSequence.VariantComponent>>())
          {
            value = Overflow["variant"];
            return true;
          }
          value = _Variant;
          return (value as List<Hl7.Fhir.Model.MolecularSequence.VariantComponent>)?.Any() is true;
        case "observedSeq":
          if (_ObservedSeqElement.InOverflow<Hl7.Fhir.Model.FhirString>())
          {
            value = Overflow["observedSeq"];
            return true;
          }
          value = _ObservedSeqElement;
          return (value as Hl7.Fhir.Model.FhirString) is not null;
        case "quality":
          if (_Quality.InOverflow<List<Hl7.Fhir.Model.MolecularSequence.QualityComponent>>())
          {
            value = Overflow["quality"];
            return true;
          }
          value = _Quality;
          return (value as List<Hl7.Fhir.Model.MolecularSequence.QualityComponent>)?.Any() is true;
        case "readCoverage":
          if (_ReadCoverageElement.InOverflow<Hl7.Fhir.Model.Integer>())
          {
            value = Overflow["readCoverage"];
            return true;
          }
          value = _ReadCoverageElement;
          return (value as Hl7.Fhir.Model.Integer) is not null;
        case "repository":
          if (_Repository.InOverflow<List<Hl7.Fhir.Model.MolecularSequence.RepositoryComponent>>())
          {
            value = Overflow["repository"];
            return true;
          }
          value = _Repository;
          return (value as List<Hl7.Fhir.Model.MolecularSequence.RepositoryComponent>)?.Any() is true;
        case "pointer":
          if (_Pointer.InOverflow<List<Hl7.Fhir.Model.ResourceReference>>())
          {
            value = Overflow["pointer"];
            return true;
          }
          value = _Pointer;
          return (value as List<Hl7.Fhir.Model.ResourceReference>)?.Any() is true;
        case "structureVariant":
          if (_StructureVariant.InOverflow<List<Hl7.Fhir.Model.MolecularSequence.StructureVariantComponent>>())
          {
            value = Overflow["structureVariant"];
            return true;
          }
          value = _StructureVariant;
          return (value as List<Hl7.Fhir.Model.MolecularSequence.StructureVariantComponent>)?.Any() is true;
        default:
          return base.TryGetValue(key, out value);
      }

    }

    public override Base SetValue(string key, object? value)
    {
      if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
      switch (key)
      {
        case "identifier":
          if (value is not (List<Hl7.Fhir.Model.Identifier> or null))
          {
            Identifier = OverflowNull<List<Hl7.Fhir.Model.Identifier>>.INSTANCE;
            Overflow["identifier"] = value;
          }
          else Identifier = (List<Hl7.Fhir.Model.Identifier>?)value!;
          return this;
        case "type":
          if (value is not (Code<Hl7.Fhir.Model.MolecularSequence.SequenceType> or null))
          {
            TypeElement = OverflowNull<Code<Hl7.Fhir.Model.MolecularSequence.SequenceType>>.INSTANCE;
            Overflow["type"] = value;
          }
          else TypeElement = (Code<Hl7.Fhir.Model.MolecularSequence.SequenceType>?)value;
          return this;
        case "coordinateSystem":
          if (value is not (Hl7.Fhir.Model.Integer or null))
          {
            CoordinateSystemElement = OverflowNull<Hl7.Fhir.Model.Integer>.INSTANCE;
            Overflow["coordinateSystem"] = value;
          }
          else CoordinateSystemElement = (Hl7.Fhir.Model.Integer?)value!;
          return this;
        case "patient":
          if (value is not (Hl7.Fhir.Model.ResourceReference or null))
          {
            Patient = OverflowNull<Hl7.Fhir.Model.ResourceReference>.INSTANCE;
            Overflow["patient"] = value;
          }
          else Patient = (Hl7.Fhir.Model.ResourceReference?)value;
          return this;
        case "specimen":
          if (value is not (Hl7.Fhir.Model.ResourceReference or null))
          {
            Specimen = OverflowNull<Hl7.Fhir.Model.ResourceReference>.INSTANCE;
            Overflow["specimen"] = value;
          }
          else Specimen = (Hl7.Fhir.Model.ResourceReference?)value;
          return this;
        case "device":
          if (value is not (Hl7.Fhir.Model.ResourceReference or null))
          {
            Device = OverflowNull<Hl7.Fhir.Model.ResourceReference>.INSTANCE;
            Overflow["device"] = value;
          }
          else Device = (Hl7.Fhir.Model.ResourceReference?)value;
          return this;
        case "performer":
          if (value is not (Hl7.Fhir.Model.ResourceReference or null))
          {
            Performer = OverflowNull<Hl7.Fhir.Model.ResourceReference>.INSTANCE;
            Overflow["performer"] = value;
          }
          else Performer = (Hl7.Fhir.Model.ResourceReference?)value;
          return this;
        case "quantity":
          if (value is not (Hl7.Fhir.Model.Quantity or null))
          {
            Quantity = OverflowNull<Hl7.Fhir.Model.Quantity>.INSTANCE;
            Overflow["quantity"] = value;
          }
          else Quantity = (Hl7.Fhir.Model.Quantity?)value;
          return this;
        case "referenceSeq":
          if (value is not (Hl7.Fhir.Model.MolecularSequence.ReferenceSeqComponent or null))
          {
            ReferenceSeq = OverflowNull<Hl7.Fhir.Model.MolecularSequence.ReferenceSeqComponent>.INSTANCE;
            Overflow["referenceSeq"] = value;
          }
          else ReferenceSeq = (Hl7.Fhir.Model.MolecularSequence.ReferenceSeqComponent?)value;
          return this;
        case "variant":
          if (value is not (List<Hl7.Fhir.Model.MolecularSequence.VariantComponent> or null))
          {
            Variant = OverflowNull<List<Hl7.Fhir.Model.MolecularSequence.VariantComponent>>.INSTANCE;
            Overflow["variant"] = value;
          }
          else Variant = (List<Hl7.Fhir.Model.MolecularSequence.VariantComponent>?)value!;
          return this;
        case "observedSeq":
          if (value is not (Hl7.Fhir.Model.FhirString or null))
          {
            ObservedSeqElement = OverflowNull<Hl7.Fhir.Model.FhirString>.INSTANCE;
            Overflow["observedSeq"] = value;
          }
          else ObservedSeqElement = (Hl7.Fhir.Model.FhirString?)value;
          return this;
        case "quality":
          if (value is not (List<Hl7.Fhir.Model.MolecularSequence.QualityComponent> or null))
          {
            Quality = OverflowNull<List<Hl7.Fhir.Model.MolecularSequence.QualityComponent>>.INSTANCE;
            Overflow["quality"] = value;
          }
          else Quality = (List<Hl7.Fhir.Model.MolecularSequence.QualityComponent>?)value!;
          return this;
        case "readCoverage":
          if (value is not (Hl7.Fhir.Model.Integer or null))
          {
            ReadCoverageElement = OverflowNull<Hl7.Fhir.Model.Integer>.INSTANCE;
            Overflow["readCoverage"] = value;
          }
          else ReadCoverageElement = (Hl7.Fhir.Model.Integer?)value;
          return this;
        case "repository":
          if (value is not (List<Hl7.Fhir.Model.MolecularSequence.RepositoryComponent> or null))
          {
            Repository = OverflowNull<List<Hl7.Fhir.Model.MolecularSequence.RepositoryComponent>>.INSTANCE;
            Overflow["repository"] = value;
          }
          else Repository = (List<Hl7.Fhir.Model.MolecularSequence.RepositoryComponent>?)value!;
          return this;
        case "pointer":
          if (value is not (List<Hl7.Fhir.Model.ResourceReference> or null))
          {
            Pointer = OverflowNull<List<Hl7.Fhir.Model.ResourceReference>>.INSTANCE;
            Overflow["pointer"] = value;
          }
          else Pointer = (List<Hl7.Fhir.Model.ResourceReference>?)value!;
          return this;
        case "structureVariant":
          if (value is not (List<Hl7.Fhir.Model.MolecularSequence.StructureVariantComponent> or null))
          {
            StructureVariant = OverflowNull<List<Hl7.Fhir.Model.MolecularSequence.StructureVariantComponent>>.INSTANCE;
            Overflow["structureVariant"] = value;
          }
          else StructureVariant = (List<Hl7.Fhir.Model.MolecularSequence.StructureVariantComponent>?)value!;
          return this;
        default:
          return base.SetValue(key, value);
      }

    }

    public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
    {
      foreach (var kvp in base.EnumerateElements()) yield return kvp;
      if (_Identifier?.Any() is true && !_Identifier.InOverflow<List<Hl7.Fhir.Model.Identifier>>()) yield return new KeyValuePair<string,object>("identifier",_Identifier);
      if (_TypeElement is not null && !_TypeElement.InOverflow<Code<Hl7.Fhir.Model.MolecularSequence.SequenceType>>()) yield return new KeyValuePair<string,object>("type",_TypeElement);
      if (_CoordinateSystemElement is not null && !_CoordinateSystemElement.InOverflow<Hl7.Fhir.Model.Integer>()) yield return new KeyValuePair<string,object>("coordinateSystem",_CoordinateSystemElement);
      if (_Patient is not null && !_Patient.InOverflow<Hl7.Fhir.Model.ResourceReference>()) yield return new KeyValuePair<string,object>("patient",_Patient);
      if (_Specimen is not null && !_Specimen.InOverflow<Hl7.Fhir.Model.ResourceReference>()) yield return new KeyValuePair<string,object>("specimen",_Specimen);
      if (_Device is not null && !_Device.InOverflow<Hl7.Fhir.Model.ResourceReference>()) yield return new KeyValuePair<string,object>("device",_Device);
      if (_Performer is not null && !_Performer.InOverflow<Hl7.Fhir.Model.ResourceReference>()) yield return new KeyValuePair<string,object>("performer",_Performer);
      if (_Quantity is not null && !_Quantity.InOverflow<Hl7.Fhir.Model.Quantity>()) yield return new KeyValuePair<string,object>("quantity",_Quantity);
      if (_ReferenceSeq is not null && !_ReferenceSeq.InOverflow<Hl7.Fhir.Model.MolecularSequence.ReferenceSeqComponent>()) yield return new KeyValuePair<string,object>("referenceSeq",_ReferenceSeq);
      if (_Variant?.Any() is true && !_Variant.InOverflow<List<Hl7.Fhir.Model.MolecularSequence.VariantComponent>>()) yield return new KeyValuePair<string,object>("variant",_Variant);
      if (_ObservedSeqElement is not null && !_ObservedSeqElement.InOverflow<Hl7.Fhir.Model.FhirString>()) yield return new KeyValuePair<string,object>("observedSeq",_ObservedSeqElement);
      if (_Quality?.Any() is true && !_Quality.InOverflow<List<Hl7.Fhir.Model.MolecularSequence.QualityComponent>>()) yield return new KeyValuePair<string,object>("quality",_Quality);
      if (_ReadCoverageElement is not null && !_ReadCoverageElement.InOverflow<Hl7.Fhir.Model.Integer>()) yield return new KeyValuePair<string,object>("readCoverage",_ReadCoverageElement);
      if (_Repository?.Any() is true && !_Repository.InOverflow<List<Hl7.Fhir.Model.MolecularSequence.RepositoryComponent>>()) yield return new KeyValuePair<string,object>("repository",_Repository);
      if (_Pointer?.Any() is true && !_Pointer.InOverflow<List<Hl7.Fhir.Model.ResourceReference>>()) yield return new KeyValuePair<string,object>("pointer",_Pointer);
      if (_StructureVariant?.Any() is true && !_StructureVariant.InOverflow<List<Hl7.Fhir.Model.MolecularSequence.StructureVariantComponent>>()) yield return new KeyValuePair<string,object>("structureVariant",_StructureVariant);
    }

  }

}

// end of file
