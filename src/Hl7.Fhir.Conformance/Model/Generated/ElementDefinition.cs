// <auto-generated/>
// Contents of: hl7.fhir.r5.expansions@5.0.0, hl7.fhir.r5.core@5.0.0

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using Hl7.Fhir.Introspection;
using Hl7.Fhir.Serialization;
using Hl7.Fhir.Specification;
using Hl7.Fhir.Utility;
using Hl7.Fhir.Validation;
using System.Diagnostics.CodeAnalysis;
using SystemPrimitive = Hl7.Fhir.ElementModel.Types;

#nullable enable

/*
  Copyright (c) 2011+, HL7, Inc.
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
*/

namespace Hl7.Fhir.Model
{
  /// <summary>
  /// Definition of an element in a resource or extension
  /// </summary>
  /// <remarks>
  /// Captures constraints on each element within the resource, profile, or extension.
  /// </remarks>
  [Serializable]
  [DataContract]
  [FhirType("ElementDefinition","http://hl7.org/fhir/StructureDefinition/ElementDefinition")]
  public partial class ElementDefinition : Hl7.Fhir.Model.BackboneType
  {
    /// <summary>
    /// FHIR Type Name
    /// </summary>
    public override string TypeName => "ElementDefinition";

    /// <summary>
    /// How a property is represented when serialized.
    /// (url: http://hl7.org/fhir/ValueSet/property-representation)
    /// (system: http://hl7.org/fhir/property-representation)
    /// </summary>
    [FhirEnumeration("PropertyRepresentation", "http://hl7.org/fhir/ValueSet/property-representation", "http://hl7.org/fhir/property-representation")]
    public enum PropertyRepresentation
    {
      /// <summary>
      /// In XML, this property is represented as an attribute not an element.
      /// (system: http://hl7.org/fhir/property-representation)
      /// </summary>
      [EnumLiteral("xmlAttr"), Description("XML Attribute")]
      XmlAttr,
      /// <summary>
      /// This element is represented using the XML text attribute (primitives only).
      /// (system: http://hl7.org/fhir/property-representation)
      /// </summary>
      [EnumLiteral("xmlText"), Description("XML Text")]
      XmlText,
      /// <summary>
      /// The type of this element is indicated using xsi:type.
      /// (system: http://hl7.org/fhir/property-representation)
      /// </summary>
      [EnumLiteral("typeAttr"), Description("Type Attribute")]
      TypeAttr,
      /// <summary>
      /// Use CDA narrative instead of XHTML.
      /// (system: http://hl7.org/fhir/property-representation)
      /// </summary>
      [EnumLiteral("cdaText"), Description("CDA Text Format")]
      CdaText,
      /// <summary>
      /// The property is represented using XHTML.
      /// (system: http://hl7.org/fhir/property-representation)
      /// </summary>
      [EnumLiteral("xhtml"), Description("XHTML")]
      Xhtml,
    }

    /// <summary>
    /// How slices are interpreted when evaluating an instance.
    /// (url: http://hl7.org/fhir/ValueSet/resource-slicing-rules)
    /// (system: http://hl7.org/fhir/resource-slicing-rules)
    /// </summary>
    [FhirEnumeration("SlicingRules", "http://hl7.org/fhir/ValueSet/resource-slicing-rules", "http://hl7.org/fhir/resource-slicing-rules")]
    public enum SlicingRules
    {
      /// <summary>
      /// No additional content is allowed other than that described by the slices in this profile.
      /// (system: http://hl7.org/fhir/resource-slicing-rules)
      /// </summary>
      [EnumLiteral("closed"), Description("Closed")]
      Closed,
      /// <summary>
      /// Additional content is allowed anywhere in the list.
      /// (system: http://hl7.org/fhir/resource-slicing-rules)
      /// </summary>
      [EnumLiteral("open"), Description("Open")]
      Open,
      /// <summary>
      /// Additional content is allowed, but only at the end of the list. Note that using this requires that the slices be ordered, which makes it hard to share uses. This should only be done where absolutely required.
      /// (system: http://hl7.org/fhir/resource-slicing-rules)
      /// </summary>
      [EnumLiteral("openAtEnd"), Description("Open at End")]
      OpenAtEnd,
    }

    /// <summary>
    /// How an element value is interpreted when discrimination is evaluated.
    /// (url: http://hl7.org/fhir/ValueSet/discriminator-type)
    /// (system: http://hl7.org/fhir/discriminator-type)
    /// </summary>
    [FhirEnumeration("DiscriminatorType", "http://hl7.org/fhir/ValueSet/discriminator-type", "http://hl7.org/fhir/discriminator-type")]
    public enum DiscriminatorType
    {
      /// <summary>
      /// The slices have different values in the nominated element, as determined by the applicable fixed value, pattern, or required ValueSet binding.
      /// (system: http://hl7.org/fhir/discriminator-type)
      /// </summary>
      [EnumLiteral("value"), Description("Value")]
      Value,
      /// <summary>
      /// The slices are differentiated by the presence or absence of the nominated element. There SHALL be no more than two slices. The slices are differentiated by the fact that one must have a max of 0 and the other must have a min of 1 (or more).  The order in which the slices are declared doesn't matter.
      /// (system: http://hl7.org/fhir/discriminator-type)
      /// </summary>
      [EnumLiteral("exists"), Description("Exists")]
      Exists,
      /// <summary>
      /// The slices have different values in the nominated element, as determined by the applicable fixed value, pattern, or required ValueSet binding. This has the same meaning as 'value' and is deprecated.
      /// (system: http://hl7.org/fhir/discriminator-type)
      /// This enum is DEPRECATED.
      /// </summary>
      [EnumLiteral("pattern"), Description("Pattern")]
      Pattern,
      /// <summary>
      /// The slices are differentiated by type of the nominated element.
      /// (system: http://hl7.org/fhir/discriminator-type)
      /// </summary>
      [EnumLiteral("type"), Description("Type")]
      Type,
      /// <summary>
      /// The slices are differentiated by conformance of the nominated element to a specified profile. Note that if the path specifies .resolve() then the profile is the target profile on the reference. In this case, validation by the possible profiles is required to differentiate the slices.
      /// (system: http://hl7.org/fhir/discriminator-type)
      /// </summary>
      [EnumLiteral("profile"), Description("Profile")]
      Profile,
      /// <summary>
      /// The slices are differentiated by their index. This is only possible if all but the last slice have min=max cardinality, and the (optional) last slice contains other undifferentiated elements.
      /// (system: http://hl7.org/fhir/discriminator-type)
      /// </summary>
      [EnumLiteral("position"), Description("Position")]
      Position,
    }

    /// <summary>
    /// How resource references can be aggregated.
    /// (url: http://hl7.org/fhir/ValueSet/resource-aggregation-mode)
    /// (system: http://hl7.org/fhir/resource-aggregation-mode)
    /// </summary>
    [FhirEnumeration("AggregationMode", "http://hl7.org/fhir/ValueSet/resource-aggregation-mode", "http://hl7.org/fhir/resource-aggregation-mode")]
    public enum AggregationMode
    {
      /// <summary>
      /// The reference is a local reference to a contained resource.
      /// (system: http://hl7.org/fhir/resource-aggregation-mode)
      /// </summary>
      [EnumLiteral("contained"), Description("Contained")]
      Contained,
      /// <summary>
      /// The reference to a resource that has to be resolved externally to the resource that includes the reference.
      /// (system: http://hl7.org/fhir/resource-aggregation-mode)
      /// </summary>
      [EnumLiteral("referenced"), Description("Referenced")]
      Referenced,
      /// <summary>
      /// When the resource is in a Bundle, the resource the reference points to will be found in the same bundle as the resource that includes the reference.
      /// (system: http://hl7.org/fhir/resource-aggregation-mode)
      /// </summary>
      [EnumLiteral("bundled"), Description("Bundled")]
      Bundled,
    }

    /// <summary>
    /// Whether a reference needs to be version specific or version independent, or whether either can be used.
    /// (url: http://hl7.org/fhir/ValueSet/reference-version-rules)
    /// (system: http://hl7.org/fhir/reference-version-rules)
    /// </summary>
    [FhirEnumeration("ReferenceVersionRules", "http://hl7.org/fhir/ValueSet/reference-version-rules", "http://hl7.org/fhir/reference-version-rules")]
    public enum ReferenceVersionRules
    {
      /// <summary>
      /// The reference may be either version independent or version specific.
      /// (system: http://hl7.org/fhir/reference-version-rules)
      /// </summary>
      [EnumLiteral("either"), Description("Either Specific or independent")]
      Either,
      /// <summary>
      /// The reference must be version independent.
      /// (system: http://hl7.org/fhir/reference-version-rules)
      /// </summary>
      [EnumLiteral("independent"), Description("Version independent")]
      Independent,
      /// <summary>
      /// The reference must be version specific.
      /// (system: http://hl7.org/fhir/reference-version-rules)
      /// </summary>
      [EnumLiteral("specific"), Description("Version Specific")]
      Specific,
    }

    /// <summary>
    /// Additional Binding Purpose
    /// (url: http://hl7.org/fhir/ValueSet/additional-binding-purpose)
    /// (system: http://hl7.org/fhir/CodeSystem/additional-binding-purpose)
    /// </summary>
    [FhirEnumeration("AdditionalBindingPurposeVS", "http://hl7.org/fhir/ValueSet/additional-binding-purpose", "http://hl7.org/fhir/CodeSystem/additional-binding-purpose")]
    public enum AdditionalBindingPurposeVS
    {
      /// <summary>
      /// A required binding, for use when the binding strength is 'extensible' or 'preferred'
      /// (system: http://hl7.org/fhir/CodeSystem/additional-binding-purpose)
      /// </summary>
      [EnumLiteral("maximum"), Description("Maximum Binding")]
      Maximum,
      /// <summary>
      /// The minimum allowable value set - any conformant system SHALL support all these codes
      /// (system: http://hl7.org/fhir/CodeSystem/additional-binding-purpose)
      /// </summary>
      [EnumLiteral("minimum"), Description("Minimum Binding")]
      Minimum,
      /// <summary>
      /// This value set is used as a required binding (in addition to the base binding (not a replacement), usually in a particular usage context)
      /// (system: http://hl7.org/fhir/CodeSystem/additional-binding-purpose)
      /// </summary>
      [EnumLiteral("required"), Description("Required Binding")]
      Required,
      /// <summary>
      /// This value set is used as an extensible binding (in addition to the base binding (not a replacement), usually in a particular usage context)
      /// (system: http://hl7.org/fhir/CodeSystem/additional-binding-purpose)
      /// </summary>
      [EnumLiteral("extensible"), Description("Conformance Binding")]
      Extensible,
      /// <summary>
      /// This value set is a candidate to substitute for the overall conformance value set in some situations; usually these are defined in the documentation
      /// (system: http://hl7.org/fhir/CodeSystem/additional-binding-purpose)
      /// </summary>
      [EnumLiteral("candidate"), Description("Candidate Binding")]
      Candidate,
      /// <summary>
      /// New records are required to use this value set, but legacy records may use other codes. The definition of 'new record' is difficult, since systems often create new records based on pre-existing data. Usually 'current' bindings are mandated by an external authority that makes clear rules around this
      /// (system: http://hl7.org/fhir/CodeSystem/additional-binding-purpose)
      /// </summary>
      [EnumLiteral("current"), Description("Current Binding")]
      Current,
      /// <summary>
      /// This is the value set that is preferred in a given context (documentation should explain why)
      /// (system: http://hl7.org/fhir/CodeSystem/additional-binding-purpose)
      /// </summary>
      [EnumLiteral("preferred"), Description("Preferred Binding")]
      Preferred,
      /// <summary>
      /// This value set is provided for user look up in a given context. Typically, these valuesets only include a subset of codes relevant for input in a context
      /// (system: http://hl7.org/fhir/CodeSystem/additional-binding-purpose)
      /// </summary>
      [EnumLiteral("ui"), Description("UI Suggested Binding")]
      Ui,
      /// <summary>
      /// This value set is a good set of codes to start with when designing your system
      /// (system: http://hl7.org/fhir/CodeSystem/additional-binding-purpose)
      /// </summary>
      [EnumLiteral("starter"), Description("Starter Binding")]
      Starter,
      /// <summary>
      /// This value set is a component of the base value set. Usually this is called out so that documentation can be written about a portion of the value set
      /// (system: http://hl7.org/fhir/CodeSystem/additional-binding-purpose)
      /// </summary>
      [EnumLiteral("component"), Description("Component Binding")]
      Component,
    }

    /// <summary>
    /// This element is sliced - slices follow
    /// </summary>
    /// <remarks>
    /// Indicates that the element is sliced into a set of alternative definitions (i.e. in a structure definition, there are multiple different constraints on a single element in the base resource). Slicing can be used in any resource that has cardinality ..* on the base resource, or any resource with a choice of types. The set of slices is any elements that come after this in the element sequence that have the same path, until a shorter path occurs (the shorter path terminates the set).
    /// The first element in the sequence, the one that carries the slicing, is the definition that applies to all the slices. This is based on the unconstrained element, but can apply any constraints as appropriate. This may include the common constraints on the children of the element.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("ElementDefinition.slicing", IsBackboneType=true)]
    public partial class SlicingComponent : Hl7.Fhir.Model.Element
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "ElementDefinition.slicing";

      /// <summary>
      /// Element values that are used to distinguish the slices.
      /// </summary>
      [FhirElement("discriminator", InSummary=true, Order=30)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.ElementDefinition.DiscriminatorComponent> Discriminator
      {
        get
        {
          if(_Discriminator.InOverflow<List<Hl7.Fhir.Model.ElementDefinition.DiscriminatorComponent>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.ElementDefinition.DiscriminatorComponent>), Overflow["discriminator"]);
          return _Discriminator ??= [];
        }

        set
        {
          if (_Discriminator.InOverflow<List<Hl7.Fhir.Model.ElementDefinition.DiscriminatorComponent>>())
            Overflow.Remove("discriminator");
          _Discriminator = value;
          OnPropertyChanged("Discriminator");
        }

      }

      private List<Hl7.Fhir.Model.ElementDefinition.DiscriminatorComponent>? _Discriminator;

      /// <summary>
      /// Text description of how slicing works (or not).
      /// </summary>
      [FhirElement("description", InSummary=true, Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString? DescriptionElement
      {
        get
        {
          if(_DescriptionElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirString), Overflow["description"]);
          return _DescriptionElement;
        }

        set
        {
          if (_DescriptionElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            Overflow.Remove("description");
          _DescriptionElement = value;
          OnPropertyChanged("DescriptionElement");
        }

      }

      private Hl7.Fhir.Model.FhirString? _DescriptionElement;

      /// <summary>
      /// Text description of how slicing works (or not)
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? Description
      {
        get => DescriptionElement?.Value;
        set
        {
          DescriptionElement = value is null ? null! : new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Description");
        }
      }

      /// <summary>
      /// If elements must be in same order as slices.
      /// </summary>
      [FhirElement("ordered", InSummary=true, Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.FhirBoolean? OrderedElement
      {
        get
        {
          if(_OrderedElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirBoolean), Overflow["ordered"]);
          return _OrderedElement;
        }

        set
        {
          if (_OrderedElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>())
            Overflow.Remove("ordered");
          _OrderedElement = value;
          OnPropertyChanged("OrderedElement");
        }

      }

      private Hl7.Fhir.Model.FhirBoolean? _OrderedElement;

      /// <summary>
      /// If elements must be in same order as slices
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public bool? Ordered
      {
        get => OrderedElement?.Value;
        set
        {
          OrderedElement = value is null ? null! : new Hl7.Fhir.Model.FhirBoolean(value);
          OnPropertyChanged("Ordered");
        }
      }

      /// <summary>
      /// closed | open | openAtEnd.
      /// </summary>
      [FhirElement("rules", InSummary=true, Order=60)]
      [Binding("SlicingRules")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Code<Hl7.Fhir.Model.ElementDefinition.SlicingRules> RulesElement
      {
        get
        {
          if(_RulesElement.InOverflow<Code<Hl7.Fhir.Model.ElementDefinition.SlicingRules>>())
            throw CodedValidationException.FromTypes(typeof(Code<Hl7.Fhir.Model.ElementDefinition.SlicingRules>), Overflow["rules"]);
          return _RulesElement!;
        }

        set
        {
          if (_RulesElement.InOverflow<Code<Hl7.Fhir.Model.ElementDefinition.SlicingRules>>())
            Overflow.Remove("rules");
          _RulesElement = value;
          OnPropertyChanged("RulesElement");
        }

      }

      private Code<Hl7.Fhir.Model.ElementDefinition.SlicingRules>? _RulesElement;

      /// <summary>
      /// closed | open | openAtEnd
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public Hl7.Fhir.Model.ElementDefinition.SlicingRules? Rules
      {
        get => RulesElement?.Value;
        set
        {
          RulesElement = value is null ? null! : new Code<Hl7.Fhir.Model.ElementDefinition.SlicingRules>(value);
          OnPropertyChanged("Rules");
        }
      }

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not SlicingComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_Discriminator is not null) dest.Discriminator = new List<Hl7.Fhir.Model.ElementDefinition.DiscriminatorComponent>(_Discriminator.DeepCopyInternal());
        if(_DescriptionElement is not null) dest.DescriptionElement = (Hl7.Fhir.Model.FhirString)_DescriptionElement.DeepCopyInternal();
        if(_OrderedElement is not null) dest.OrderedElement = (Hl7.Fhir.Model.FhirBoolean)_OrderedElement.DeepCopyInternal();
        if(_RulesElement is not null) dest.RulesElement = (Code<Hl7.Fhir.Model.ElementDefinition.SlicingRules>)_RulesElement.DeepCopyInternal();
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new SlicingComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not SlicingComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.ListEquals(_Discriminator, otherT._Discriminator)) return false;
        if(!comparer.Equals(_DescriptionElement, otherT._DescriptionElement)) return false;
        if(!comparer.Equals(_OrderedElement, otherT._OrderedElement)) return false;
        if(!comparer.Equals(_RulesElement, otherT._RulesElement)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "discriminator":
            if (_Discriminator.InOverflow<List<Hl7.Fhir.Model.ElementDefinition.DiscriminatorComponent>>())
            {
              value = Overflow["discriminator"];
              return true;
            }
            value = _Discriminator;
            return (value as List<Hl7.Fhir.Model.ElementDefinition.DiscriminatorComponent>)?.Any() is true;
          case "description":
            if (_DescriptionElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            {
              value = Overflow["description"];
              return true;
            }
            value = _DescriptionElement;
            return (value as Hl7.Fhir.Model.FhirString) is not null;
          case "ordered":
            if (_OrderedElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>())
            {
              value = Overflow["ordered"];
              return true;
            }
            value = _OrderedElement;
            return (value as Hl7.Fhir.Model.FhirBoolean) is not null;
          case "rules":
            if (_RulesElement.InOverflow<Code<Hl7.Fhir.Model.ElementDefinition.SlicingRules>>())
            {
              value = Overflow["rules"];
              return true;
            }
            value = _RulesElement;
            return (value as Code<Hl7.Fhir.Model.ElementDefinition.SlicingRules>) is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "discriminator":
            if (value is not (List<Hl7.Fhir.Model.ElementDefinition.DiscriminatorComponent> or null))
            {
              Discriminator = OverflowNull<List<Hl7.Fhir.Model.ElementDefinition.DiscriminatorComponent>>.INSTANCE;
              Overflow["discriminator"] = value;
            }
            else Discriminator = (List<Hl7.Fhir.Model.ElementDefinition.DiscriminatorComponent>?)value!;
            return this;
          case "description":
            if (value is not (Hl7.Fhir.Model.FhirString or null))
            {
              DescriptionElement = OverflowNull<Hl7.Fhir.Model.FhirString>.INSTANCE;
              Overflow["description"] = value;
            }
            else DescriptionElement = (Hl7.Fhir.Model.FhirString?)value;
            return this;
          case "ordered":
            if (value is not (Hl7.Fhir.Model.FhirBoolean or null))
            {
              OrderedElement = OverflowNull<Hl7.Fhir.Model.FhirBoolean>.INSTANCE;
              Overflow["ordered"] = value;
            }
            else OrderedElement = (Hl7.Fhir.Model.FhirBoolean?)value;
            return this;
          case "rules":
            if (value is not (Code<Hl7.Fhir.Model.ElementDefinition.SlicingRules> or null))
            {
              RulesElement = OverflowNull<Code<Hl7.Fhir.Model.ElementDefinition.SlicingRules>>.INSTANCE;
              Overflow["rules"] = value;
            }
            else RulesElement = (Code<Hl7.Fhir.Model.ElementDefinition.SlicingRules>?)value!;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_Discriminator?.Any() is true && !_Discriminator.InOverflow<List<Hl7.Fhir.Model.ElementDefinition.DiscriminatorComponent>>()) yield return new KeyValuePair<string,object>("discriminator",_Discriminator);
        if (_DescriptionElement is not null && !_DescriptionElement.InOverflow<Hl7.Fhir.Model.FhirString>()) yield return new KeyValuePair<string,object>("description",_DescriptionElement);
        if (_OrderedElement is not null && !_OrderedElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>()) yield return new KeyValuePair<string,object>("ordered",_OrderedElement);
        if (_RulesElement is not null && !_RulesElement.InOverflow<Code<Hl7.Fhir.Model.ElementDefinition.SlicingRules>>()) yield return new KeyValuePair<string,object>("rules",_RulesElement);
      }

    }

    /// <summary>
    /// Element values that are used to distinguish the slices
    /// </summary>
    /// <remarks>
    /// Designates which child elements are used to discriminate between the slices when processing an instance. If one or more discriminators are provided, the value of the child elements in the instance data SHALL completely distinguish which slice the element in the resource matches based on the allowed values for those elements in each of the slices.
    /// If there is no discriminator, the content is hard to process, so this should be avoided.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("ElementDefinition.slicing.discriminator", IsBackboneType=true)]
    public partial class DiscriminatorComponent : Hl7.Fhir.Model.Element
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "ElementDefinition.slicing.discriminator";

      /// <summary>
      /// value | exists | type | profile | position.
      /// </summary>
      [FhirElement("type", InSummary=true, Order=30)]
      [Binding("DiscriminatorType")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Code<Hl7.Fhir.Model.ElementDefinition.DiscriminatorType> TypeElement
      {
        get
        {
          if(_TypeElement.InOverflow<Code<Hl7.Fhir.Model.ElementDefinition.DiscriminatorType>>())
            throw CodedValidationException.FromTypes(typeof(Code<Hl7.Fhir.Model.ElementDefinition.DiscriminatorType>), Overflow["type"]);
          return _TypeElement!;
        }

        set
        {
          if (_TypeElement.InOverflow<Code<Hl7.Fhir.Model.ElementDefinition.DiscriminatorType>>())
            Overflow.Remove("type");
          _TypeElement = value;
          OnPropertyChanged("TypeElement");
        }

      }

      private Code<Hl7.Fhir.Model.ElementDefinition.DiscriminatorType>? _TypeElement;

      /// <summary>
      /// value | exists | type | profile | position
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public Hl7.Fhir.Model.ElementDefinition.DiscriminatorType? Type
      {
        get => TypeElement?.Value;
        set
        {
          TypeElement = value is null ? null! : new Code<Hl7.Fhir.Model.ElementDefinition.DiscriminatorType>(value);
          OnPropertyChanged("Type");
        }
      }

      /// <summary>
      /// Path to element value.
      /// </summary>
      [FhirElement("path", InSummary=true, Order=40)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString PathElement
      {
        get
        {
          if(_PathElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirString), Overflow["path"]);
          return _PathElement!;
        }

        set
        {
          if (_PathElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            Overflow.Remove("path");
          _PathElement = value;
          OnPropertyChanged("PathElement");
        }

      }

      private Hl7.Fhir.Model.FhirString? _PathElement;

      /// <summary>
      /// Path to element value
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? Path
      {
        get => PathElement?.Value;
        set
        {
          PathElement = value is null ? null! : new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Path");
        }
      }

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not DiscriminatorComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_TypeElement is not null) dest.TypeElement = (Code<Hl7.Fhir.Model.ElementDefinition.DiscriminatorType>)_TypeElement.DeepCopyInternal();
        if(_PathElement is not null) dest.PathElement = (Hl7.Fhir.Model.FhirString)_PathElement.DeepCopyInternal();
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new DiscriminatorComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not DiscriminatorComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_TypeElement, otherT._TypeElement)) return false;
        if(!comparer.Equals(_PathElement, otherT._PathElement)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "type":
            if (_TypeElement.InOverflow<Code<Hl7.Fhir.Model.ElementDefinition.DiscriminatorType>>())
            {
              value = Overflow["type"];
              return true;
            }
            value = _TypeElement;
            return (value as Code<Hl7.Fhir.Model.ElementDefinition.DiscriminatorType>) is not null;
          case "path":
            if (_PathElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            {
              value = Overflow["path"];
              return true;
            }
            value = _PathElement;
            return (value as Hl7.Fhir.Model.FhirString) is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "type":
            if (value is not (Code<Hl7.Fhir.Model.ElementDefinition.DiscriminatorType> or null))
            {
              TypeElement = OverflowNull<Code<Hl7.Fhir.Model.ElementDefinition.DiscriminatorType>>.INSTANCE;
              Overflow["type"] = value;
            }
            else TypeElement = (Code<Hl7.Fhir.Model.ElementDefinition.DiscriminatorType>?)value!;
            return this;
          case "path":
            if (value is not (Hl7.Fhir.Model.FhirString or null))
            {
              PathElement = OverflowNull<Hl7.Fhir.Model.FhirString>.INSTANCE;
              Overflow["path"] = value;
            }
            else PathElement = (Hl7.Fhir.Model.FhirString?)value!;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_TypeElement is not null && !_TypeElement.InOverflow<Code<Hl7.Fhir.Model.ElementDefinition.DiscriminatorType>>()) yield return new KeyValuePair<string,object>("type",_TypeElement);
        if (_PathElement is not null && !_PathElement.InOverflow<Hl7.Fhir.Model.FhirString>()) yield return new KeyValuePair<string,object>("path",_PathElement);
      }

    }

    /// <summary>
    /// Base definition information for tools
    /// </summary>
    /// <remarks>
    /// Information about the base definition of the element, provided to make it unnecessary for tools to trace the deviation of the element through the derived and related profiles. When the element definition is not the original definition of an element - e.g. either in a constraint on another type, or for elements from a super type in a snap shot - then the information in provided in the element definition may be different to the base definition. On the original definition of the element, it will be same.
    /// The base information does not carry any information that could not be determined from the path and related profiles, but making this determination requires both that the related profiles are available, and that the algorithm to determine them be available. For tooling simplicity, the base information must always be populated in element definitions in snap shots, even if it is the same.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("ElementDefinition.base", IsBackboneType=true)]
    public partial class BaseComponent : Hl7.Fhir.Model.Element
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "ElementDefinition.base";

      /// <summary>
      /// Path that identifies the base element.
      /// </summary>
      [FhirElement("path", InSummary=true, Order=30)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString PathElement
      {
        get
        {
          if(_PathElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirString), Overflow["path"]);
          return _PathElement!;
        }

        set
        {
          if (_PathElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            Overflow.Remove("path");
          _PathElement = value;
          OnPropertyChanged("PathElement");
        }

      }

      private Hl7.Fhir.Model.FhirString? _PathElement;

      /// <summary>
      /// Path that identifies the base element
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? Path
      {
        get => PathElement?.Value;
        set
        {
          PathElement = value is null ? null! : new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Path");
        }
      }

      /// <summary>
      /// Min cardinality of the base element.
      /// </summary>
      [FhirElement("min", InSummary=true, Order=40)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.UnsignedInt MinElement
      {
        get
        {
          if(_MinElement.InOverflow<Hl7.Fhir.Model.UnsignedInt>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.UnsignedInt), Overflow["min"]);
          return _MinElement!;
        }

        set
        {
          if (_MinElement.InOverflow<Hl7.Fhir.Model.UnsignedInt>())
            Overflow.Remove("min");
          _MinElement = value;
          OnPropertyChanged("MinElement");
        }

      }

      private Hl7.Fhir.Model.UnsignedInt? _MinElement;

      /// <summary>
      /// Min cardinality of the base element
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? Min
      {
        get => MinElement?.Value;
        set
        {
          MinElement = value is null ? null! : new Hl7.Fhir.Model.UnsignedInt(value);
          OnPropertyChanged("Min");
        }
      }

      /// <summary>
      /// Max cardinality of the base element.
      /// </summary>
      [FhirElement("max", InSummary=true, Order=50)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString MaxElement
      {
        get
        {
          if(_MaxElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirString), Overflow["max"]);
          return _MaxElement!;
        }

        set
        {
          if (_MaxElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            Overflow.Remove("max");
          _MaxElement = value;
          OnPropertyChanged("MaxElement");
        }

      }

      private Hl7.Fhir.Model.FhirString? _MaxElement;

      /// <summary>
      /// Max cardinality of the base element
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? Max
      {
        get => MaxElement?.Value;
        set
        {
          MaxElement = value is null ? null! : new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Max");
        }
      }

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not BaseComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_PathElement is not null) dest.PathElement = (Hl7.Fhir.Model.FhirString)_PathElement.DeepCopyInternal();
        if(_MinElement is not null) dest.MinElement = (Hl7.Fhir.Model.UnsignedInt)_MinElement.DeepCopyInternal();
        if(_MaxElement is not null) dest.MaxElement = (Hl7.Fhir.Model.FhirString)_MaxElement.DeepCopyInternal();
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new BaseComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not BaseComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_PathElement, otherT._PathElement)) return false;
        if(!comparer.Equals(_MinElement, otherT._MinElement)) return false;
        if(!comparer.Equals(_MaxElement, otherT._MaxElement)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "path":
            if (_PathElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            {
              value = Overflow["path"];
              return true;
            }
            value = _PathElement;
            return (value as Hl7.Fhir.Model.FhirString) is not null;
          case "min":
            if (_MinElement.InOverflow<Hl7.Fhir.Model.UnsignedInt>())
            {
              value = Overflow["min"];
              return true;
            }
            value = _MinElement;
            return (value as Hl7.Fhir.Model.UnsignedInt) is not null;
          case "max":
            if (_MaxElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            {
              value = Overflow["max"];
              return true;
            }
            value = _MaxElement;
            return (value as Hl7.Fhir.Model.FhirString) is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "path":
            if (value is not (Hl7.Fhir.Model.FhirString or null))
            {
              PathElement = OverflowNull<Hl7.Fhir.Model.FhirString>.INSTANCE;
              Overflow["path"] = value;
            }
            else PathElement = (Hl7.Fhir.Model.FhirString?)value!;
            return this;
          case "min":
            if (value is not (Hl7.Fhir.Model.UnsignedInt or null))
            {
              MinElement = OverflowNull<Hl7.Fhir.Model.UnsignedInt>.INSTANCE;
              Overflow["min"] = value;
            }
            else MinElement = (Hl7.Fhir.Model.UnsignedInt?)value!;
            return this;
          case "max":
            if (value is not (Hl7.Fhir.Model.FhirString or null))
            {
              MaxElement = OverflowNull<Hl7.Fhir.Model.FhirString>.INSTANCE;
              Overflow["max"] = value;
            }
            else MaxElement = (Hl7.Fhir.Model.FhirString?)value!;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_PathElement is not null && !_PathElement.InOverflow<Hl7.Fhir.Model.FhirString>()) yield return new KeyValuePair<string,object>("path",_PathElement);
        if (_MinElement is not null && !_MinElement.InOverflow<Hl7.Fhir.Model.UnsignedInt>()) yield return new KeyValuePair<string,object>("min",_MinElement);
        if (_MaxElement is not null && !_MaxElement.InOverflow<Hl7.Fhir.Model.FhirString>()) yield return new KeyValuePair<string,object>("max",_MaxElement);
      }

    }

    /// <summary>
    /// Data type and Profile for this element
    /// </summary>
    /// <remarks>
    /// The data type or resource that the value of this element is permitted to be.
    /// The Type of the element can be left blank in a differential constraint, in which case the type is inherited from the resource. Abstract types are not permitted to appear as a type when multiple types are listed.  (I.e. Abstract types cannot be part of a choice).
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("ElementDefinition.type", IsBackboneType=true)]
    public partial class TypeRefComponent : Hl7.Fhir.Model.Element
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "ElementDefinition.type";

      /// <summary>
      /// Data type or Resource (reference to definition).
      /// </summary>
      [FhirElement("code", InSummary=true, Order=30)]
      [Binding("ElementDefinitionTypes")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.FhirUri CodeElement
      {
        get
        {
          if(_CodeElement.InOverflow<Hl7.Fhir.Model.FhirUri>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirUri), Overflow["code"]);
          return _CodeElement!;
        }

        set
        {
          if (_CodeElement.InOverflow<Hl7.Fhir.Model.FhirUri>())
            Overflow.Remove("code");
          _CodeElement = value;
          OnPropertyChanged("CodeElement");
        }

      }

      private Hl7.Fhir.Model.FhirUri? _CodeElement;

      /// <summary>
      /// Data type or Resource (reference to definition)
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? Code
      {
        get => CodeElement?.Value;
        set
        {
          CodeElement = value is null ? null! : new Hl7.Fhir.Model.FhirUri(value);
          OnPropertyChanged("Code");
        }
      }

      /// <summary>
      /// Profiles (StructureDefinition or IG) - one must apply.
      /// </summary>
      [FhirElement("profile", InSummary=true, Order=40)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.Canonical> ProfileElement
      {
        get
        {
          if(_ProfileElement.InOverflow<List<Hl7.Fhir.Model.Canonical>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.Canonical>), Overflow["profile"]);
          return _ProfileElement ??= [];
        }

        set
        {
          if (_ProfileElement.InOverflow<List<Hl7.Fhir.Model.Canonical>>())
            Overflow.Remove("profile");
          _ProfileElement = value;
          OnPropertyChanged("ProfileElement");
        }

      }

      private List<Hl7.Fhir.Model.Canonical>? _ProfileElement;

      /// <summary>
      /// Profiles (StructureDefinition or IG) - one must apply
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public IEnumerable<string?> Profile
      {
        get => _ProfileElement?.Select(elem => elem.Value) ?? [];
        set
        {
          if (value == null)
            ProfileElement = null!;
          else
            ProfileElement = new List<Hl7.Fhir.Model.Canonical>(value.Select(elem=>new Hl7.Fhir.Model.Canonical(elem)));
          OnPropertyChanged("Profile");
        }
      }

      /// <summary>
      /// Profile (StructureDefinition or IG) on the Reference/canonical target - one must apply.
      /// </summary>
      [FhirElement("targetProfile", InSummary=true, Order=50)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.Canonical> TargetProfileElement
      {
        get
        {
          if(_TargetProfileElement.InOverflow<List<Hl7.Fhir.Model.Canonical>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.Canonical>), Overflow["targetProfile"]);
          return _TargetProfileElement ??= [];
        }

        set
        {
          if (_TargetProfileElement.InOverflow<List<Hl7.Fhir.Model.Canonical>>())
            Overflow.Remove("targetProfile");
          _TargetProfileElement = value;
          OnPropertyChanged("TargetProfileElement");
        }

      }

      private List<Hl7.Fhir.Model.Canonical>? _TargetProfileElement;

      /// <summary>
      /// Profile (StructureDefinition or IG) on the Reference/canonical target - one must apply
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public IEnumerable<string?> TargetProfile
      {
        get => _TargetProfileElement?.Select(elem => elem.Value) ?? [];
        set
        {
          if (value == null)
            TargetProfileElement = null!;
          else
            TargetProfileElement = new List<Hl7.Fhir.Model.Canonical>(value.Select(elem=>new Hl7.Fhir.Model.Canonical(elem)));
          OnPropertyChanged("TargetProfile");
        }
      }

      /// <summary>
      /// contained | referenced | bundled - how aggregated.
      /// </summary>
      [FhirElement("aggregation", InSummary=true, Order=60)]
      [Binding("AggregationMode")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Code<Hl7.Fhir.Model.ElementDefinition.AggregationMode>> AggregationElement
      {
        get
        {
          if(_AggregationElement.InOverflow<List<Code<Hl7.Fhir.Model.ElementDefinition.AggregationMode>>>())
            throw CodedValidationException.FromTypes(typeof(List<Code<Hl7.Fhir.Model.ElementDefinition.AggregationMode>>), Overflow["aggregation"]);
          return _AggregationElement ??= [];
        }

        set
        {
          if (_AggregationElement.InOverflow<List<Code<Hl7.Fhir.Model.ElementDefinition.AggregationMode>>>())
            Overflow.Remove("aggregation");
          _AggregationElement = value;
          OnPropertyChanged("AggregationElement");
        }

      }

      private List<Code<Hl7.Fhir.Model.ElementDefinition.AggregationMode>>? _AggregationElement;

      /// <summary>
      /// contained | referenced | bundled - how aggregated
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public IEnumerable<Hl7.Fhir.Model.ElementDefinition.AggregationMode?> Aggregation
      {
        get => _AggregationElement?.Select(elem => elem.Value) ?? [];
        set
        {
          if (value == null)
            AggregationElement = null!;
          else
            AggregationElement = new List<Code<Hl7.Fhir.Model.ElementDefinition.AggregationMode>>(value.Select(elem=>new Code<Hl7.Fhir.Model.ElementDefinition.AggregationMode>(elem)));
          OnPropertyChanged("Aggregation");
        }
      }

      /// <summary>
      /// either | independent | specific.
      /// </summary>
      [FhirElement("versioning", InSummary=true, Order=70)]
      [Binding("ReferenceVersionRules")]
      [DataMember]
      public Code<Hl7.Fhir.Model.ElementDefinition.ReferenceVersionRules>? VersioningElement
      {
        get
        {
          if(_VersioningElement.InOverflow<Code<Hl7.Fhir.Model.ElementDefinition.ReferenceVersionRules>>())
            throw CodedValidationException.FromTypes(typeof(Code<Hl7.Fhir.Model.ElementDefinition.ReferenceVersionRules>), Overflow["versioning"]);
          return _VersioningElement;
        }

        set
        {
          if (_VersioningElement.InOverflow<Code<Hl7.Fhir.Model.ElementDefinition.ReferenceVersionRules>>())
            Overflow.Remove("versioning");
          _VersioningElement = value;
          OnPropertyChanged("VersioningElement");
        }

      }

      private Code<Hl7.Fhir.Model.ElementDefinition.ReferenceVersionRules>? _VersioningElement;

      /// <summary>
      /// either | independent | specific
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public Hl7.Fhir.Model.ElementDefinition.ReferenceVersionRules? Versioning
      {
        get => VersioningElement?.Value;
        set
        {
          VersioningElement = value is null ? null! : new Code<Hl7.Fhir.Model.ElementDefinition.ReferenceVersionRules>(value);
          OnPropertyChanged("Versioning");
        }
      }

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not TypeRefComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_CodeElement is not null) dest.CodeElement = (Hl7.Fhir.Model.FhirUri)_CodeElement.DeepCopyInternal();
        if(_ProfileElement is not null) dest.ProfileElement = new List<Hl7.Fhir.Model.Canonical>(_ProfileElement.DeepCopyInternal());
        if(_TargetProfileElement is not null) dest.TargetProfileElement = new List<Hl7.Fhir.Model.Canonical>(_TargetProfileElement.DeepCopyInternal());
        if(_AggregationElement is not null) dest.AggregationElement = new List<Code<Hl7.Fhir.Model.ElementDefinition.AggregationMode>>(_AggregationElement.DeepCopyInternal());
        if(_VersioningElement is not null) dest.VersioningElement = (Code<Hl7.Fhir.Model.ElementDefinition.ReferenceVersionRules>)_VersioningElement.DeepCopyInternal();
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new TypeRefComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not TypeRefComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_CodeElement, otherT._CodeElement)) return false;
        if(!comparer.ListEquals(_ProfileElement, otherT._ProfileElement)) return false;
        if(!comparer.ListEquals(_TargetProfileElement, otherT._TargetProfileElement)) return false;
        if(!comparer.ListEquals(_AggregationElement, otherT._AggregationElement)) return false;
        if(!comparer.Equals(_VersioningElement, otherT._VersioningElement)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "code":
            if (_CodeElement.InOverflow<Hl7.Fhir.Model.FhirUri>())
            {
              value = Overflow["code"];
              return true;
            }
            value = _CodeElement;
            return (value as Hl7.Fhir.Model.FhirUri) is not null;
          case "profile":
            if (_ProfileElement.InOverflow<List<Hl7.Fhir.Model.Canonical>>())
            {
              value = Overflow["profile"];
              return true;
            }
            value = _ProfileElement;
            return (value as List<Hl7.Fhir.Model.Canonical>)?.Any() is true;
          case "targetProfile":
            if (_TargetProfileElement.InOverflow<List<Hl7.Fhir.Model.Canonical>>())
            {
              value = Overflow["targetProfile"];
              return true;
            }
            value = _TargetProfileElement;
            return (value as List<Hl7.Fhir.Model.Canonical>)?.Any() is true;
          case "aggregation":
            if (_AggregationElement.InOverflow<List<Code<Hl7.Fhir.Model.ElementDefinition.AggregationMode>>>())
            {
              value = Overflow["aggregation"];
              return true;
            }
            value = _AggregationElement;
            return (value as List<Code<Hl7.Fhir.Model.ElementDefinition.AggregationMode>>)?.Any() is true;
          case "versioning":
            if (_VersioningElement.InOverflow<Code<Hl7.Fhir.Model.ElementDefinition.ReferenceVersionRules>>())
            {
              value = Overflow["versioning"];
              return true;
            }
            value = _VersioningElement;
            return (value as Code<Hl7.Fhir.Model.ElementDefinition.ReferenceVersionRules>) is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "code":
            if (value is not (Hl7.Fhir.Model.FhirUri or null))
            {
              CodeElement = OverflowNull<Hl7.Fhir.Model.FhirUri>.INSTANCE;
              Overflow["code"] = value;
            }
            else CodeElement = (Hl7.Fhir.Model.FhirUri?)value!;
            return this;
          case "profile":
            if (value is not (List<Hl7.Fhir.Model.Canonical> or null))
            {
              ProfileElement = OverflowNull<List<Hl7.Fhir.Model.Canonical>>.INSTANCE;
              Overflow["profile"] = value;
            }
            else ProfileElement = (List<Hl7.Fhir.Model.Canonical>?)value!;
            return this;
          case "targetProfile":
            if (value is not (List<Hl7.Fhir.Model.Canonical> or null))
            {
              TargetProfileElement = OverflowNull<List<Hl7.Fhir.Model.Canonical>>.INSTANCE;
              Overflow["targetProfile"] = value;
            }
            else TargetProfileElement = (List<Hl7.Fhir.Model.Canonical>?)value!;
            return this;
          case "aggregation":
            if (value is not (List<Code<Hl7.Fhir.Model.ElementDefinition.AggregationMode>> or null))
            {
              AggregationElement = OverflowNull<List<Code<Hl7.Fhir.Model.ElementDefinition.AggregationMode>>>.INSTANCE;
              Overflow["aggregation"] = value;
            }
            else AggregationElement = (List<Code<Hl7.Fhir.Model.ElementDefinition.AggregationMode>>?)value!;
            return this;
          case "versioning":
            if (value is not (Code<Hl7.Fhir.Model.ElementDefinition.ReferenceVersionRules> or null))
            {
              VersioningElement = OverflowNull<Code<Hl7.Fhir.Model.ElementDefinition.ReferenceVersionRules>>.INSTANCE;
              Overflow["versioning"] = value;
            }
            else VersioningElement = (Code<Hl7.Fhir.Model.ElementDefinition.ReferenceVersionRules>?)value;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_CodeElement is not null && !_CodeElement.InOverflow<Hl7.Fhir.Model.FhirUri>()) yield return new KeyValuePair<string,object>("code",_CodeElement);
        if (_ProfileElement?.Any() is true && !_ProfileElement.InOverflow<List<Hl7.Fhir.Model.Canonical>>()) yield return new KeyValuePair<string,object>("profile",_ProfileElement);
        if (_TargetProfileElement?.Any() is true && !_TargetProfileElement.InOverflow<List<Hl7.Fhir.Model.Canonical>>()) yield return new KeyValuePair<string,object>("targetProfile",_TargetProfileElement);
        if (_AggregationElement?.Any() is true && !_AggregationElement.InOverflow<List<Code<Hl7.Fhir.Model.ElementDefinition.AggregationMode>>>()) yield return new KeyValuePair<string,object>("aggregation",_AggregationElement);
        if (_VersioningElement is not null && !_VersioningElement.InOverflow<Code<Hl7.Fhir.Model.ElementDefinition.ReferenceVersionRules>>()) yield return new KeyValuePair<string,object>("versioning",_VersioningElement);
      }

    }

    /// <summary>
    /// Example value (as defined for type)
    /// </summary>
    /// <remarks>
    /// A sample value for this element demonstrating the type of information that would typically be found in the element.
    /// Examples will most commonly be present for data where it's not implicitly obvious from either the data type or value set what the values might be.  (I.e. Example values for dates or quantities would generally be unnecessary.)  If the example value is fully populated, the publication tool can generate an instance automatically.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("ElementDefinition.example", IsBackboneType=true)]
    public partial class ExampleComponent : Hl7.Fhir.Model.Element
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "ElementDefinition.example";

      /// <summary>
      /// Describes the purpose of this example.
      /// </summary>
      [FhirElement("label", InSummary=true, Order=30)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString LabelElement
      {
        get
        {
          if(_LabelElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirString), Overflow["label"]);
          return _LabelElement!;
        }

        set
        {
          if (_LabelElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            Overflow.Remove("label");
          _LabelElement = value;
          OnPropertyChanged("LabelElement");
        }

      }

      private Hl7.Fhir.Model.FhirString? _LabelElement;

      /// <summary>
      /// Describes the purpose of this example
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? Label
      {
        get => LabelElement?.Value;
        set
        {
          LabelElement = value is null ? null! : new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Label");
        }
      }

      /// <summary>
      /// Value of Example (one of allowed types).
      /// </summary>
      [FhirElement("value", InSummary=true, Order=40, Choice=ChoiceType.DatatypeChoice)]
      [CLSCompliant(false)]
      [AllowedTypes(OpenChoice = true)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.DataType Value
      {
        get
        {
          if(_Value.InOverflow<DynamicDataType>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.DataType), Overflow["value"]);
          return _Value!;
        }

        set
        {
          if (_Value.InOverflow<DynamicDataType>())
            Overflow.Remove("value");
          _Value = value;
          OnPropertyChanged("Value");
        }

      }

      private Hl7.Fhir.Model.DataType? _Value;

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not ExampleComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_LabelElement is not null) dest.LabelElement = (Hl7.Fhir.Model.FhirString)_LabelElement.DeepCopyInternal();
        if(_Value is not null) dest.Value = (Hl7.Fhir.Model.DataType)_Value.DeepCopyInternal();
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new ExampleComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not ExampleComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_LabelElement, otherT._LabelElement)) return false;
        if(!comparer.Equals(_Value, otherT._Value)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "label":
            if (_LabelElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            {
              value = Overflow["label"];
              return true;
            }
            value = _LabelElement;
            return (value as Hl7.Fhir.Model.FhirString) is not null;
          case "value":
            if (_Value.InOverflow<DynamicDataType>())
            {
              value = Overflow["value"];
              return true;
            }
            value = _Value;
            return (value as Hl7.Fhir.Model.DataType) is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "label":
            if (value is not (Hl7.Fhir.Model.FhirString or null))
            {
              LabelElement = OverflowNull<Hl7.Fhir.Model.FhirString>.INSTANCE;
              Overflow["label"] = value;
            }
            else LabelElement = (Hl7.Fhir.Model.FhirString?)value!;
            return this;
          case "value":
            if (value is not (Hl7.Fhir.Model.DataType or null))
            {
              Value = OverflowNull<DynamicDataType>.INSTANCE;
              Overflow["value"] = value;
            }
            else Value = (Hl7.Fhir.Model.DataType?)value!;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_LabelElement is not null && !_LabelElement.InOverflow<Hl7.Fhir.Model.FhirString>()) yield return new KeyValuePair<string,object>("label",_LabelElement);
        if (_Value is not null && !_Value.InOverflow<DynamicDataType>()) yield return new KeyValuePair<string,object>("value",_Value);
      }

    }

    /// <summary>
    /// Condition that must evaluate to true
    /// </summary>
    /// <remarks>
    /// Formal constraints such as co-occurrence and other constraints that can be computationally evaluated within the context of the instance.
    /// Constraints should be declared on the "context" element - the lowest element in the hierarchy that is common to all nodes referenced by the constraint.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("ElementDefinition.constraint", IsBackboneType=true)]
    public partial class ConstraintComponent : Hl7.Fhir.Model.Element
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "ElementDefinition.constraint";

      /// <summary>
      /// Target of 'condition' reference above.
      /// </summary>
      [FhirElement("key", InSummary=true, Order=30)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.Id KeyElement
      {
        get
        {
          if(_KeyElement.InOverflow<Hl7.Fhir.Model.Id>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Id), Overflow["key"]);
          return _KeyElement!;
        }

        set
        {
          if (_KeyElement.InOverflow<Hl7.Fhir.Model.Id>())
            Overflow.Remove("key");
          _KeyElement = value;
          OnPropertyChanged("KeyElement");
        }

      }

      private Hl7.Fhir.Model.Id? _KeyElement;

      /// <summary>
      /// Target of 'condition' reference above
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? Key
      {
        get => KeyElement?.Value;
        set
        {
          KeyElement = value is null ? null! : new Hl7.Fhir.Model.Id(value);
          OnPropertyChanged("Key");
        }
      }

      /// <summary>
      /// Why this constraint is necessary or appropriate.
      /// </summary>
      /// <remarks>
      /// The type of this element has changed over time. Make sure to use Hl7.Fhir.Model.FhirString in STU3, R4 and R4B, Hl7.Fhir.Model.Markdown starting from R5.
      /// </remarks>
      [FhirElement("requirements", InSummary=true, Order=40)]
      [AllowedTypes(typeof(Hl7.Fhir.Model.FhirString), Since = FhirRelease.STU3)]
      [AllowedTypes(typeof(Hl7.Fhir.Model.Markdown), Since = FhirRelease.R5)]
      [DataMember]
      public Hl7.Fhir.Model.PrimitiveType? RequirementsElement
      {
        get
        {
          if(_RequirementsElement.InOverflow<DynamicPrimitive>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.PrimitiveType), Overflow["requirements"]);
          return _RequirementsElement;
        }

        set
        {
          if (_RequirementsElement.InOverflow<DynamicPrimitive>())
            Overflow.Remove("requirements");
          _RequirementsElement = value;
          OnPropertyChanged("RequirementsElement");
        }

      }

      private Hl7.Fhir.Model.PrimitiveType? _RequirementsElement;

      /// <summary>
      /// Why this constraint is necessary or appropriate. Use this property in STU3, R4 and R4B.
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? RequirementsString
      {
        get => ((IValue<string>?)RequirementsElement)?.Value;
        set
        {
          RequirementsElement = value is null ? null! : new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("RequirementsString");
        }
      }

      /// <summary>
      /// Why this constraint is necessary or appropriate. Use this property starting from R5.
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? Requirements
      {
        get => ((IValue<string>?)RequirementsElement)?.Value;
        set
        {
          RequirementsElement = value is null ? null! : new Hl7.Fhir.Model.Markdown(value);
          OnPropertyChanged("Requirements");
        }
      }

      /// <summary>
      /// error | warning.
      /// </summary>
      [FhirElement("severity", InSummary=true, Order=50)]
      [Binding("ConstraintSeverity")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Code<Hl7.Fhir.Model.ConstraintSeverity> SeverityElement
      {
        get
        {
          if(_SeverityElement.InOverflow<Code<Hl7.Fhir.Model.ConstraintSeverity>>())
            throw CodedValidationException.FromTypes(typeof(Code<Hl7.Fhir.Model.ConstraintSeverity>), Overflow["severity"]);
          return _SeverityElement!;
        }

        set
        {
          if (_SeverityElement.InOverflow<Code<Hl7.Fhir.Model.ConstraintSeverity>>())
            Overflow.Remove("severity");
          _SeverityElement = value;
          OnPropertyChanged("SeverityElement");
        }

      }

      private Code<Hl7.Fhir.Model.ConstraintSeverity>? _SeverityElement;

      /// <summary>
      /// error | warning
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public Hl7.Fhir.Model.ConstraintSeverity? Severity
      {
        get => SeverityElement?.Value;
        set
        {
          SeverityElement = value is null ? null! : new Code<Hl7.Fhir.Model.ConstraintSeverity>(value);
          OnPropertyChanged("Severity");
        }
      }

      /// <summary>
      /// Suppress warning or hint in profile.
      /// </summary>
      /// <remarks>
      /// Element was introduced in R5, do not use when working with older releases.
      /// </remarks>
      [FhirElement("suppress", InSummary=true, Order=60, Since=FhirRelease.R5)]
      [DataMember]
      public Hl7.Fhir.Model.FhirBoolean? SuppressElement
      {
        get
        {
          if(_SuppressElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirBoolean), Overflow["suppress"]);
          return _SuppressElement;
        }

        set
        {
          if (_SuppressElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>())
            Overflow.Remove("suppress");
          _SuppressElement = value;
          OnPropertyChanged("SuppressElement");
        }

      }

      private Hl7.Fhir.Model.FhirBoolean? _SuppressElement;

      /// <summary>
      /// Suppress warning or hint in profile
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public bool? Suppress
      {
        get => SuppressElement?.Value;
        set
        {
          SuppressElement = value is null ? null! : new Hl7.Fhir.Model.FhirBoolean(value);
          OnPropertyChanged("Suppress");
        }
      }

      /// <summary>
      /// Human description of constraint.
      /// </summary>
      [FhirElement("human", InSummary=true, Order=70)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString HumanElement
      {
        get
        {
          if(_HumanElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirString), Overflow["human"]);
          return _HumanElement!;
        }

        set
        {
          if (_HumanElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            Overflow.Remove("human");
          _HumanElement = value;
          OnPropertyChanged("HumanElement");
        }

      }

      private Hl7.Fhir.Model.FhirString? _HumanElement;

      /// <summary>
      /// Human description of constraint
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? Human
      {
        get => HumanElement?.Value;
        set
        {
          HumanElement = value is null ? null! : new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Human");
        }
      }

      /// <summary>
      /// FHIRPath expression of constraint.
      /// </summary>
      [FhirElement("expression", InSummary=true, Order=80)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString? ExpressionElement
      {
        get
        {
          if(_ExpressionElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirString), Overflow["expression"]);
          return _ExpressionElement;
        }

        set
        {
          if (_ExpressionElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            Overflow.Remove("expression");
          _ExpressionElement = value;
          OnPropertyChanged("ExpressionElement");
        }

      }

      private Hl7.Fhir.Model.FhirString? _ExpressionElement;

      /// <summary>
      /// FHIRPath expression of constraint
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? Expression
      {
        get => ExpressionElement?.Value;
        set
        {
          ExpressionElement = value is null ? null! : new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Expression");
        }
      }

      /// <summary>
      /// XPath expression of constraint.
      /// </summary>
      /// <remarks>
      /// Element is deprecated since R5, do not use with R5 and newer releases.
      /// </remarks>
      [FhirElement("xpath", InSummary=true, Order=90)]
      [NotMapped(Since=FhirRelease.R5)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString? XpathElement
      {
        get
        {
          if(_XpathElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirString), Overflow["xpath"]);
          return _XpathElement;
        }

        set
        {
          if (_XpathElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            Overflow.Remove("xpath");
          _XpathElement = value;
          OnPropertyChanged("XpathElement");
        }

      }

      private Hl7.Fhir.Model.FhirString? _XpathElement;

      /// <summary>
      /// XPath expression of constraint
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? Xpath
      {
        get => XpathElement?.Value;
        set
        {
          XpathElement = value is null ? null! : new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Xpath");
        }
      }

      /// <summary>
      /// Reference to original source of constraint.
      /// </summary>
      [FhirElement("source", InSummary=true, Order=100)]
      [DataMember]
      public Hl7.Fhir.Model.Canonical? SourceElement
      {
        get
        {
          if(_SourceElement.InOverflow<Hl7.Fhir.Model.Canonical>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Canonical), Overflow["source"]);
          return _SourceElement;
        }

        set
        {
          if (_SourceElement.InOverflow<Hl7.Fhir.Model.Canonical>())
            Overflow.Remove("source");
          _SourceElement = value;
          OnPropertyChanged("SourceElement");
        }

      }

      private Hl7.Fhir.Model.Canonical? _SourceElement;

      /// <summary>
      /// Reference to original source of constraint
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? Source
      {
        get => SourceElement?.Value;
        set
        {
          SourceElement = value is null ? null! : new Hl7.Fhir.Model.Canonical(value);
          OnPropertyChanged("Source");
        }
      }

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not ConstraintComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_KeyElement is not null) dest.KeyElement = (Hl7.Fhir.Model.Id)_KeyElement.DeepCopyInternal();
        if(_RequirementsElement is not null) dest.RequirementsElement = (Hl7.Fhir.Model.PrimitiveType)_RequirementsElement.DeepCopyInternal();
        if(_SeverityElement is not null) dest.SeverityElement = (Code<Hl7.Fhir.Model.ConstraintSeverity>)_SeverityElement.DeepCopyInternal();
        if(_SuppressElement is not null) dest.SuppressElement = (Hl7.Fhir.Model.FhirBoolean)_SuppressElement.DeepCopyInternal();
        if(_HumanElement is not null) dest.HumanElement = (Hl7.Fhir.Model.FhirString)_HumanElement.DeepCopyInternal();
        if(_ExpressionElement is not null) dest.ExpressionElement = (Hl7.Fhir.Model.FhirString)_ExpressionElement.DeepCopyInternal();
        if(_XpathElement is not null) dest.XpathElement = (Hl7.Fhir.Model.FhirString)_XpathElement.DeepCopyInternal();
        if(_SourceElement is not null) dest.SourceElement = (Hl7.Fhir.Model.Canonical)_SourceElement.DeepCopyInternal();
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new ConstraintComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not ConstraintComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_KeyElement, otherT._KeyElement)) return false;
        if(!comparer.Equals(_RequirementsElement, otherT._RequirementsElement)) return false;
        if(!comparer.Equals(_SeverityElement, otherT._SeverityElement)) return false;
        if(!comparer.Equals(_SuppressElement, otherT._SuppressElement)) return false;
        if(!comparer.Equals(_HumanElement, otherT._HumanElement)) return false;
        if(!comparer.Equals(_ExpressionElement, otherT._ExpressionElement)) return false;
        if(!comparer.Equals(_XpathElement, otherT._XpathElement)) return false;
        if(!comparer.Equals(_SourceElement, otherT._SourceElement)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "key":
            if (_KeyElement.InOverflow<Hl7.Fhir.Model.Id>())
            {
              value = Overflow["key"];
              return true;
            }
            value = _KeyElement;
            return (value as Hl7.Fhir.Model.Id) is not null;
          case "requirements":
            if (_RequirementsElement.InOverflow<DynamicPrimitive>())
            {
              value = Overflow["requirements"];
              return true;
            }
            value = _RequirementsElement;
            return (value as Hl7.Fhir.Model.PrimitiveType) is not null;
          case "severity":
            if (_SeverityElement.InOverflow<Code<Hl7.Fhir.Model.ConstraintSeverity>>())
            {
              value = Overflow["severity"];
              return true;
            }
            value = _SeverityElement;
            return (value as Code<Hl7.Fhir.Model.ConstraintSeverity>) is not null;
          case "suppress":
            if (_SuppressElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>())
            {
              value = Overflow["suppress"];
              return true;
            }
            value = _SuppressElement;
            return (value as Hl7.Fhir.Model.FhirBoolean) is not null;
          case "human":
            if (_HumanElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            {
              value = Overflow["human"];
              return true;
            }
            value = _HumanElement;
            return (value as Hl7.Fhir.Model.FhirString) is not null;
          case "expression":
            if (_ExpressionElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            {
              value = Overflow["expression"];
              return true;
            }
            value = _ExpressionElement;
            return (value as Hl7.Fhir.Model.FhirString) is not null;
          case "xpath":
            if (_XpathElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            {
              value = Overflow["xpath"];
              return true;
            }
            value = _XpathElement;
            return (value as Hl7.Fhir.Model.FhirString) is not null;
          case "source":
            if (_SourceElement.InOverflow<Hl7.Fhir.Model.Canonical>())
            {
              value = Overflow["source"];
              return true;
            }
            value = _SourceElement;
            return (value as Hl7.Fhir.Model.Canonical) is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "key":
            if (value is not (Hl7.Fhir.Model.Id or null))
            {
              KeyElement = OverflowNull<Hl7.Fhir.Model.Id>.INSTANCE;
              Overflow["key"] = value;
            }
            else KeyElement = (Hl7.Fhir.Model.Id?)value!;
            return this;
          case "requirements":
            if (value is not (Hl7.Fhir.Model.PrimitiveType or null))
            {
              RequirementsElement = OverflowNull<DynamicPrimitive>.INSTANCE;
              Overflow["requirements"] = value;
            }
            else RequirementsElement = (Hl7.Fhir.Model.PrimitiveType?)value;
            return this;
          case "severity":
            if (value is not (Code<Hl7.Fhir.Model.ConstraintSeverity> or null))
            {
              SeverityElement = OverflowNull<Code<Hl7.Fhir.Model.ConstraintSeverity>>.INSTANCE;
              Overflow["severity"] = value;
            }
            else SeverityElement = (Code<Hl7.Fhir.Model.ConstraintSeverity>?)value!;
            return this;
          case "suppress":
            if (value is not (Hl7.Fhir.Model.FhirBoolean or null))
            {
              SuppressElement = OverflowNull<Hl7.Fhir.Model.FhirBoolean>.INSTANCE;
              Overflow["suppress"] = value;
            }
            else SuppressElement = (Hl7.Fhir.Model.FhirBoolean?)value;
            return this;
          case "human":
            if (value is not (Hl7.Fhir.Model.FhirString or null))
            {
              HumanElement = OverflowNull<Hl7.Fhir.Model.FhirString>.INSTANCE;
              Overflow["human"] = value;
            }
            else HumanElement = (Hl7.Fhir.Model.FhirString?)value!;
            return this;
          case "expression":
            if (value is not (Hl7.Fhir.Model.FhirString or null))
            {
              ExpressionElement = OverflowNull<Hl7.Fhir.Model.FhirString>.INSTANCE;
              Overflow["expression"] = value;
            }
            else ExpressionElement = (Hl7.Fhir.Model.FhirString?)value;
            return this;
          case "xpath":
            if (value is not (Hl7.Fhir.Model.FhirString or null))
            {
              XpathElement = OverflowNull<Hl7.Fhir.Model.FhirString>.INSTANCE;
              Overflow["xpath"] = value;
            }
            else XpathElement = (Hl7.Fhir.Model.FhirString?)value;
            return this;
          case "source":
            if (value is not (Hl7.Fhir.Model.Canonical or null))
            {
              SourceElement = OverflowNull<Hl7.Fhir.Model.Canonical>.INSTANCE;
              Overflow["source"] = value;
            }
            else SourceElement = (Hl7.Fhir.Model.Canonical?)value;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_KeyElement is not null && !_KeyElement.InOverflow<Hl7.Fhir.Model.Id>()) yield return new KeyValuePair<string,object>("key",_KeyElement);
        if (_RequirementsElement is not null && !_RequirementsElement.InOverflow<DynamicPrimitive>()) yield return new KeyValuePair<string,object>("requirements",_RequirementsElement);
        if (_SeverityElement is not null && !_SeverityElement.InOverflow<Code<Hl7.Fhir.Model.ConstraintSeverity>>()) yield return new KeyValuePair<string,object>("severity",_SeverityElement);
        if (_SuppressElement is not null && !_SuppressElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>()) yield return new KeyValuePair<string,object>("suppress",_SuppressElement);
        if (_HumanElement is not null && !_HumanElement.InOverflow<Hl7.Fhir.Model.FhirString>()) yield return new KeyValuePair<string,object>("human",_HumanElement);
        if (_ExpressionElement is not null && !_ExpressionElement.InOverflow<Hl7.Fhir.Model.FhirString>()) yield return new KeyValuePair<string,object>("expression",_ExpressionElement);
        if (_XpathElement is not null && !_XpathElement.InOverflow<Hl7.Fhir.Model.FhirString>()) yield return new KeyValuePair<string,object>("xpath",_XpathElement);
        if (_SourceElement is not null && !_SourceElement.InOverflow<Hl7.Fhir.Model.Canonical>()) yield return new KeyValuePair<string,object>("source",_SourceElement);
      }

    }

    /// <summary>
    /// ValueSet details if this is coded
    /// </summary>
    /// <remarks>
    /// Binds to a value set if this element is coded (code, Coding, CodeableConcept, Quantity), or the data types (string, uri).
    /// For a CodeableConcept, when no codes are allowed - only text, use a binding of strength "required" with a description explaining that no coded values are allowed and what sort of information to put in the "text" element.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("ElementDefinition.binding", IsBackboneType=true)]
    public partial class ElementDefinitionBindingComponent : Hl7.Fhir.Model.Element
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "ElementDefinition.binding";

      /// <summary>
      /// required | extensible | preferred | example.
      /// </summary>
      [FhirElement("strength", InSummary=true, Order=30)]
      [Binding("BindingStrength")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Code<Hl7.Fhir.Model.BindingStrength> StrengthElement
      {
        get
        {
          if(_StrengthElement.InOverflow<Code<Hl7.Fhir.Model.BindingStrength>>())
            throw CodedValidationException.FromTypes(typeof(Code<Hl7.Fhir.Model.BindingStrength>), Overflow["strength"]);
          return _StrengthElement!;
        }

        set
        {
          if (_StrengthElement.InOverflow<Code<Hl7.Fhir.Model.BindingStrength>>())
            Overflow.Remove("strength");
          _StrengthElement = value;
          OnPropertyChanged("StrengthElement");
        }

      }

      private Code<Hl7.Fhir.Model.BindingStrength>? _StrengthElement;

      /// <summary>
      /// required | extensible | preferred | example
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public Hl7.Fhir.Model.BindingStrength? Strength
      {
        get => StrengthElement?.Value;
        set
        {
          StrengthElement = value is null ? null! : new Code<Hl7.Fhir.Model.BindingStrength>(value);
          OnPropertyChanged("Strength");
        }
      }

      /// <summary>
      /// Intended use of codes in the bound value set.
      /// </summary>
      /// <remarks>
      /// The type of this element has changed over time. Make sure to use Hl7.Fhir.Model.FhirString in STU3, R4 and R4B, Hl7.Fhir.Model.Markdown starting from R5.
      /// </remarks>
      [FhirElement("description", InSummary=true, Order=40)]
      [AllowedTypes(typeof(Hl7.Fhir.Model.FhirString), Since = FhirRelease.STU3)]
      [AllowedTypes(typeof(Hl7.Fhir.Model.Markdown), Since = FhirRelease.R5)]
      [DataMember]
      public Hl7.Fhir.Model.PrimitiveType? DescriptionElement
      {
        get
        {
          if(_DescriptionElement.InOverflow<DynamicPrimitive>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.PrimitiveType), Overflow["description"]);
          return _DescriptionElement;
        }

        set
        {
          if (_DescriptionElement.InOverflow<DynamicPrimitive>())
            Overflow.Remove("description");
          _DescriptionElement = value;
          OnPropertyChanged("DescriptionElement");
        }

      }

      private Hl7.Fhir.Model.PrimitiveType? _DescriptionElement;

      /// <summary>
      /// Intended use of codes in the bound value set. Use this property in STU3, R4 and R4B.
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? DescriptionString
      {
        get => ((IValue<string>?)DescriptionElement)?.Value;
        set
        {
          DescriptionElement = value is null ? null! : new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("DescriptionString");
        }
      }

      /// <summary>
      /// Intended use of codes in the bound value set. Use this property starting from R5.
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? Description
      {
        get => ((IValue<string>?)DescriptionElement)?.Value;
        set
        {
          DescriptionElement = value is null ? null! : new Hl7.Fhir.Model.Markdown(value);
          OnPropertyChanged("Description");
        }
      }

      /// <summary>
      /// Source of value set.
      /// </summary>
      [FhirElement("valueSet", InSummary=true, Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.Canonical? ValueSetElement
      {
        get
        {
          if(_ValueSetElement.InOverflow<Hl7.Fhir.Model.Canonical>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Canonical), Overflow["valueSet"]);
          return _ValueSetElement;
        }

        set
        {
          if (_ValueSetElement.InOverflow<Hl7.Fhir.Model.Canonical>())
            Overflow.Remove("valueSet");
          _ValueSetElement = value;
          OnPropertyChanged("ValueSetElement");
        }

      }

      private Hl7.Fhir.Model.Canonical? _ValueSetElement;

      /// <summary>
      /// Source of value set
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? ValueSet
      {
        get => ValueSetElement?.Value;
        set
        {
          ValueSetElement = value is null ? null! : new Hl7.Fhir.Model.Canonical(value);
          OnPropertyChanged("ValueSet");
        }
      }

      /// <summary>
      /// Additional Bindings - more rules about the binding.
      /// </summary>
      /// <remarks>
      /// Element was introduced in R5, do not use when working with older releases.
      /// </remarks>
      [FhirElement("additional", InSummary=true, Order=60, Since=FhirRelease.R5)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.ElementDefinition.AdditionalComponent> Additional
      {
        get
        {
          if(_Additional.InOverflow<List<Hl7.Fhir.Model.ElementDefinition.AdditionalComponent>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.ElementDefinition.AdditionalComponent>), Overflow["additional"]);
          return _Additional ??= [];
        }

        set
        {
          if (_Additional.InOverflow<List<Hl7.Fhir.Model.ElementDefinition.AdditionalComponent>>())
            Overflow.Remove("additional");
          _Additional = value;
          OnPropertyChanged("Additional");
        }

      }

      private List<Hl7.Fhir.Model.ElementDefinition.AdditionalComponent>? _Additional;

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not ElementDefinitionBindingComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_StrengthElement is not null) dest.StrengthElement = (Code<Hl7.Fhir.Model.BindingStrength>)_StrengthElement.DeepCopyInternal();
        if(_DescriptionElement is not null) dest.DescriptionElement = (Hl7.Fhir.Model.PrimitiveType)_DescriptionElement.DeepCopyInternal();
        if(_ValueSetElement is not null) dest.ValueSetElement = (Hl7.Fhir.Model.Canonical)_ValueSetElement.DeepCopyInternal();
        if(_Additional is not null) dest.Additional = new List<Hl7.Fhir.Model.ElementDefinition.AdditionalComponent>(_Additional.DeepCopyInternal());
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new ElementDefinitionBindingComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not ElementDefinitionBindingComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_StrengthElement, otherT._StrengthElement)) return false;
        if(!comparer.Equals(_DescriptionElement, otherT._DescriptionElement)) return false;
        if(!comparer.Equals(_ValueSetElement, otherT._ValueSetElement)) return false;
        if(!comparer.ListEquals(_Additional, otherT._Additional)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "strength":
            if (_StrengthElement.InOverflow<Code<Hl7.Fhir.Model.BindingStrength>>())
            {
              value = Overflow["strength"];
              return true;
            }
            value = _StrengthElement;
            return (value as Code<Hl7.Fhir.Model.BindingStrength>) is not null;
          case "description":
            if (_DescriptionElement.InOverflow<DynamicPrimitive>())
            {
              value = Overflow["description"];
              return true;
            }
            value = _DescriptionElement;
            return (value as Hl7.Fhir.Model.PrimitiveType) is not null;
          case "valueSet":
            if (_ValueSetElement.InOverflow<Hl7.Fhir.Model.Canonical>())
            {
              value = Overflow["valueSet"];
              return true;
            }
            value = _ValueSetElement;
            return (value as Hl7.Fhir.Model.Canonical) is not null;
          case "additional":
            if (_Additional.InOverflow<List<Hl7.Fhir.Model.ElementDefinition.AdditionalComponent>>())
            {
              value = Overflow["additional"];
              return true;
            }
            value = _Additional;
            return (value as List<Hl7.Fhir.Model.ElementDefinition.AdditionalComponent>)?.Any() is true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "strength":
            if (value is not (Code<Hl7.Fhir.Model.BindingStrength> or null))
            {
              StrengthElement = OverflowNull<Code<Hl7.Fhir.Model.BindingStrength>>.INSTANCE;
              Overflow["strength"] = value;
            }
            else StrengthElement = (Code<Hl7.Fhir.Model.BindingStrength>?)value!;
            return this;
          case "description":
            if (value is not (Hl7.Fhir.Model.PrimitiveType or null))
            {
              DescriptionElement = OverflowNull<DynamicPrimitive>.INSTANCE;
              Overflow["description"] = value;
            }
            else DescriptionElement = (Hl7.Fhir.Model.PrimitiveType?)value;
            return this;
          case "valueSet":
            if (value is not (Hl7.Fhir.Model.Canonical or null))
            {
              ValueSetElement = OverflowNull<Hl7.Fhir.Model.Canonical>.INSTANCE;
              Overflow["valueSet"] = value;
            }
            else ValueSetElement = (Hl7.Fhir.Model.Canonical?)value;
            return this;
          case "additional":
            if (value is not (List<Hl7.Fhir.Model.ElementDefinition.AdditionalComponent> or null))
            {
              Additional = OverflowNull<List<Hl7.Fhir.Model.ElementDefinition.AdditionalComponent>>.INSTANCE;
              Overflow["additional"] = value;
            }
            else Additional = (List<Hl7.Fhir.Model.ElementDefinition.AdditionalComponent>?)value!;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_StrengthElement is not null && !_StrengthElement.InOverflow<Code<Hl7.Fhir.Model.BindingStrength>>()) yield return new KeyValuePair<string,object>("strength",_StrengthElement);
        if (_DescriptionElement is not null && !_DescriptionElement.InOverflow<DynamicPrimitive>()) yield return new KeyValuePair<string,object>("description",_DescriptionElement);
        if (_ValueSetElement is not null && !_ValueSetElement.InOverflow<Hl7.Fhir.Model.Canonical>()) yield return new KeyValuePair<string,object>("valueSet",_ValueSetElement);
        if (_Additional?.Any() is true && !_Additional.InOverflow<List<Hl7.Fhir.Model.ElementDefinition.AdditionalComponent>>()) yield return new KeyValuePair<string,object>("additional",_Additional);
      }

    }

    /// <summary>
    /// Additional Bindings - more rules about the binding
    /// </summary>
    /// <remarks>
    /// Additional bindings that help applications implementing this element. Additional bindings do not replace the main binding but provide more information and/or context.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("ElementDefinition.binding.additional", IsBackboneType=true)]
    public partial class AdditionalComponent : Hl7.Fhir.Model.Element
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "ElementDefinition.binding.additional";

      /// <summary>
      /// maximum | minimum | required | extensible | candidate | current | preferred | ui | starter | component.
      /// </summary>
      /// <remarks>
      /// Element was introduced in R5, do not use when working with older releases.
      /// </remarks>
      [FhirElement("purpose", InSummary=true, Order=30, Since=FhirRelease.R5)]
      [Binding("AdditionalBindingPurpose")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Code<Hl7.Fhir.Model.ElementDefinition.AdditionalBindingPurposeVS> PurposeElement
      {
        get
        {
          if(_PurposeElement.InOverflow<Code<Hl7.Fhir.Model.ElementDefinition.AdditionalBindingPurposeVS>>())
            throw CodedValidationException.FromTypes(typeof(Code<Hl7.Fhir.Model.ElementDefinition.AdditionalBindingPurposeVS>), Overflow["purpose"]);
          return _PurposeElement!;
        }

        set
        {
          if (_PurposeElement.InOverflow<Code<Hl7.Fhir.Model.ElementDefinition.AdditionalBindingPurposeVS>>())
            Overflow.Remove("purpose");
          _PurposeElement = value;
          OnPropertyChanged("PurposeElement");
        }

      }

      private Code<Hl7.Fhir.Model.ElementDefinition.AdditionalBindingPurposeVS>? _PurposeElement;

      /// <summary>
      /// maximum | minimum | required | extensible | candidate | current | preferred | ui | starter | component
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public Hl7.Fhir.Model.ElementDefinition.AdditionalBindingPurposeVS? Purpose
      {
        get => PurposeElement?.Value;
        set
        {
          PurposeElement = value is null ? null! : new Code<Hl7.Fhir.Model.ElementDefinition.AdditionalBindingPurposeVS>(value);
          OnPropertyChanged("Purpose");
        }
      }

      /// <summary>
      /// The value set for the additional binding.
      /// </summary>
      /// <remarks>
      /// Element was introduced in R5, do not use when working with older releases.
      /// </remarks>
      [FhirElement("valueSet", InSummary=true, Order=40, Since=FhirRelease.R5)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.Canonical ValueSetElement
      {
        get
        {
          if(_ValueSetElement.InOverflow<Hl7.Fhir.Model.Canonical>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Canonical), Overflow["valueSet"]);
          return _ValueSetElement!;
        }

        set
        {
          if (_ValueSetElement.InOverflow<Hl7.Fhir.Model.Canonical>())
            Overflow.Remove("valueSet");
          _ValueSetElement = value;
          OnPropertyChanged("ValueSetElement");
        }

      }

      private Hl7.Fhir.Model.Canonical? _ValueSetElement;

      /// <summary>
      /// The value set for the additional binding
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? ValueSet
      {
        get => ValueSetElement?.Value;
        set
        {
          ValueSetElement = value is null ? null! : new Hl7.Fhir.Model.Canonical(value);
          OnPropertyChanged("ValueSet");
        }
      }

      /// <summary>
      /// Documentation of the purpose of use of the binding.
      /// </summary>
      /// <remarks>
      /// Element was introduced in R5, do not use when working with older releases.
      /// </remarks>
      [FhirElement("documentation", InSummary=true, Order=50, Since=FhirRelease.R5)]
      [DataMember]
      public Hl7.Fhir.Model.Markdown? DocumentationElement
      {
        get
        {
          if(_DocumentationElement.InOverflow<Hl7.Fhir.Model.Markdown>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Markdown), Overflow["documentation"]);
          return _DocumentationElement;
        }

        set
        {
          if (_DocumentationElement.InOverflow<Hl7.Fhir.Model.Markdown>())
            Overflow.Remove("documentation");
          _DocumentationElement = value;
          OnPropertyChanged("DocumentationElement");
        }

      }

      private Hl7.Fhir.Model.Markdown? _DocumentationElement;

      /// <summary>
      /// Documentation of the purpose of use of the binding
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? Documentation
      {
        get => DocumentationElement?.Value;
        set
        {
          DocumentationElement = value is null ? null! : new Hl7.Fhir.Model.Markdown(value);
          OnPropertyChanged("Documentation");
        }
      }

      /// <summary>
      /// Concise documentation - for summary tables.
      /// </summary>
      /// <remarks>
      /// Element was introduced in R5, do not use when working with older releases.
      /// </remarks>
      [FhirElement("shortDoco", InSummary=true, Order=60, Since=FhirRelease.R5)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString? ShortDocoElement
      {
        get
        {
          if(_ShortDocoElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirString), Overflow["shortDoco"]);
          return _ShortDocoElement;
        }

        set
        {
          if (_ShortDocoElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            Overflow.Remove("shortDoco");
          _ShortDocoElement = value;
          OnPropertyChanged("ShortDocoElement");
        }

      }

      private Hl7.Fhir.Model.FhirString? _ShortDocoElement;

      /// <summary>
      /// Concise documentation - for summary tables
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? ShortDoco
      {
        get => ShortDocoElement?.Value;
        set
        {
          ShortDocoElement = value is null ? null! : new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("ShortDoco");
        }
      }

      /// <summary>
      /// Qualifies the usage - jurisdiction, gender, workflow status etc.
      /// </summary>
      /// <remarks>
      /// Element was introduced in R5, do not use when working with older releases.
      /// </remarks>
      [FhirElement("usage", InSummary=true, Order=70, Since=FhirRelease.R5)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.UsageContext> Usage
      {
        get
        {
          if(_Usage.InOverflow<List<Hl7.Fhir.Model.UsageContext>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.UsageContext>), Overflow["usage"]);
          return _Usage ??= [];
        }

        set
        {
          if (_Usage.InOverflow<List<Hl7.Fhir.Model.UsageContext>>())
            Overflow.Remove("usage");
          _Usage = value;
          OnPropertyChanged("Usage");
        }

      }

      private List<Hl7.Fhir.Model.UsageContext>? _Usage;

      /// <summary>
      /// Whether binding can applies to all repeats, or just one.
      /// </summary>
      /// <remarks>
      /// Element was introduced in R5, do not use when working with older releases.
      /// </remarks>
      [FhirElement("any", InSummary=true, Order=80, Since=FhirRelease.R5)]
      [DataMember]
      public Hl7.Fhir.Model.FhirBoolean? AnyElement
      {
        get
        {
          if(_AnyElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirBoolean), Overflow["any"]);
          return _AnyElement;
        }

        set
        {
          if (_AnyElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>())
            Overflow.Remove("any");
          _AnyElement = value;
          OnPropertyChanged("AnyElement");
        }

      }

      private Hl7.Fhir.Model.FhirBoolean? _AnyElement;

      /// <summary>
      /// Whether binding can applies to all repeats, or just one
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public bool? Any
      {
        get => AnyElement?.Value;
        set
        {
          AnyElement = value is null ? null! : new Hl7.Fhir.Model.FhirBoolean(value);
          OnPropertyChanged("Any");
        }
      }

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not AdditionalComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_PurposeElement is not null) dest.PurposeElement = (Code<Hl7.Fhir.Model.ElementDefinition.AdditionalBindingPurposeVS>)_PurposeElement.DeepCopyInternal();
        if(_ValueSetElement is not null) dest.ValueSetElement = (Hl7.Fhir.Model.Canonical)_ValueSetElement.DeepCopyInternal();
        if(_DocumentationElement is not null) dest.DocumentationElement = (Hl7.Fhir.Model.Markdown)_DocumentationElement.DeepCopyInternal();
        if(_ShortDocoElement is not null) dest.ShortDocoElement = (Hl7.Fhir.Model.FhirString)_ShortDocoElement.DeepCopyInternal();
        if(_Usage is not null) dest.Usage = new List<Hl7.Fhir.Model.UsageContext>(_Usage.DeepCopyInternal());
        if(_AnyElement is not null) dest.AnyElement = (Hl7.Fhir.Model.FhirBoolean)_AnyElement.DeepCopyInternal();
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new AdditionalComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not AdditionalComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_PurposeElement, otherT._PurposeElement)) return false;
        if(!comparer.Equals(_ValueSetElement, otherT._ValueSetElement)) return false;
        if(!comparer.Equals(_DocumentationElement, otherT._DocumentationElement)) return false;
        if(!comparer.Equals(_ShortDocoElement, otherT._ShortDocoElement)) return false;
        if(!comparer.ListEquals(_Usage, otherT._Usage)) return false;
        if(!comparer.Equals(_AnyElement, otherT._AnyElement)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "purpose":
            if (_PurposeElement.InOverflow<Code<Hl7.Fhir.Model.ElementDefinition.AdditionalBindingPurposeVS>>())
            {
              value = Overflow["purpose"];
              return true;
            }
            value = _PurposeElement;
            return (value as Code<Hl7.Fhir.Model.ElementDefinition.AdditionalBindingPurposeVS>) is not null;
          case "valueSet":
            if (_ValueSetElement.InOverflow<Hl7.Fhir.Model.Canonical>())
            {
              value = Overflow["valueSet"];
              return true;
            }
            value = _ValueSetElement;
            return (value as Hl7.Fhir.Model.Canonical) is not null;
          case "documentation":
            if (_DocumentationElement.InOverflow<Hl7.Fhir.Model.Markdown>())
            {
              value = Overflow["documentation"];
              return true;
            }
            value = _DocumentationElement;
            return (value as Hl7.Fhir.Model.Markdown) is not null;
          case "shortDoco":
            if (_ShortDocoElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            {
              value = Overflow["shortDoco"];
              return true;
            }
            value = _ShortDocoElement;
            return (value as Hl7.Fhir.Model.FhirString) is not null;
          case "usage":
            if (_Usage.InOverflow<List<Hl7.Fhir.Model.UsageContext>>())
            {
              value = Overflow["usage"];
              return true;
            }
            value = _Usage;
            return (value as List<Hl7.Fhir.Model.UsageContext>)?.Any() is true;
          case "any":
            if (_AnyElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>())
            {
              value = Overflow["any"];
              return true;
            }
            value = _AnyElement;
            return (value as Hl7.Fhir.Model.FhirBoolean) is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "purpose":
            if (value is not (Code<Hl7.Fhir.Model.ElementDefinition.AdditionalBindingPurposeVS> or null))
            {
              PurposeElement = OverflowNull<Code<Hl7.Fhir.Model.ElementDefinition.AdditionalBindingPurposeVS>>.INSTANCE;
              Overflow["purpose"] = value;
            }
            else PurposeElement = (Code<Hl7.Fhir.Model.ElementDefinition.AdditionalBindingPurposeVS>?)value!;
            return this;
          case "valueSet":
            if (value is not (Hl7.Fhir.Model.Canonical or null))
            {
              ValueSetElement = OverflowNull<Hl7.Fhir.Model.Canonical>.INSTANCE;
              Overflow["valueSet"] = value;
            }
            else ValueSetElement = (Hl7.Fhir.Model.Canonical?)value!;
            return this;
          case "documentation":
            if (value is not (Hl7.Fhir.Model.Markdown or null))
            {
              DocumentationElement = OverflowNull<Hl7.Fhir.Model.Markdown>.INSTANCE;
              Overflow["documentation"] = value;
            }
            else DocumentationElement = (Hl7.Fhir.Model.Markdown?)value;
            return this;
          case "shortDoco":
            if (value is not (Hl7.Fhir.Model.FhirString or null))
            {
              ShortDocoElement = OverflowNull<Hl7.Fhir.Model.FhirString>.INSTANCE;
              Overflow["shortDoco"] = value;
            }
            else ShortDocoElement = (Hl7.Fhir.Model.FhirString?)value;
            return this;
          case "usage":
            if (value is not (List<Hl7.Fhir.Model.UsageContext> or null))
            {
              Usage = OverflowNull<List<Hl7.Fhir.Model.UsageContext>>.INSTANCE;
              Overflow["usage"] = value;
            }
            else Usage = (List<Hl7.Fhir.Model.UsageContext>?)value!;
            return this;
          case "any":
            if (value is not (Hl7.Fhir.Model.FhirBoolean or null))
            {
              AnyElement = OverflowNull<Hl7.Fhir.Model.FhirBoolean>.INSTANCE;
              Overflow["any"] = value;
            }
            else AnyElement = (Hl7.Fhir.Model.FhirBoolean?)value;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_PurposeElement is not null && !_PurposeElement.InOverflow<Code<Hl7.Fhir.Model.ElementDefinition.AdditionalBindingPurposeVS>>()) yield return new KeyValuePair<string,object>("purpose",_PurposeElement);
        if (_ValueSetElement is not null && !_ValueSetElement.InOverflow<Hl7.Fhir.Model.Canonical>()) yield return new KeyValuePair<string,object>("valueSet",_ValueSetElement);
        if (_DocumentationElement is not null && !_DocumentationElement.InOverflow<Hl7.Fhir.Model.Markdown>()) yield return new KeyValuePair<string,object>("documentation",_DocumentationElement);
        if (_ShortDocoElement is not null && !_ShortDocoElement.InOverflow<Hl7.Fhir.Model.FhirString>()) yield return new KeyValuePair<string,object>("shortDoco",_ShortDocoElement);
        if (_Usage?.Any() is true && !_Usage.InOverflow<List<Hl7.Fhir.Model.UsageContext>>()) yield return new KeyValuePair<string,object>("usage",_Usage);
        if (_AnyElement is not null && !_AnyElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>()) yield return new KeyValuePair<string,object>("any",_AnyElement);
      }

    }

    /// <summary>
    /// Map element to another set of definitions
    /// </summary>
    /// <remarks>
    /// Identifies a concept from an external specification that roughly corresponds to this element.
    /// Mappings are not necessarily specific enough for safe translation.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("ElementDefinition.mapping", IsBackboneType=true)]
    public partial class MappingComponent : Hl7.Fhir.Model.Element
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "ElementDefinition.mapping";

      /// <summary>
      /// Reference to mapping declaration.
      /// </summary>
      [FhirElement("identity", InSummary=true, Order=30)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.Id IdentityElement
      {
        get
        {
          if(_IdentityElement.InOverflow<Hl7.Fhir.Model.Id>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Id), Overflow["identity"]);
          return _IdentityElement!;
        }

        set
        {
          if (_IdentityElement.InOverflow<Hl7.Fhir.Model.Id>())
            Overflow.Remove("identity");
          _IdentityElement = value;
          OnPropertyChanged("IdentityElement");
        }

      }

      private Hl7.Fhir.Model.Id? _IdentityElement;

      /// <summary>
      /// Reference to mapping declaration
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? Identity
      {
        get => IdentityElement?.Value;
        set
        {
          IdentityElement = value is null ? null! : new Hl7.Fhir.Model.Id(value);
          OnPropertyChanged("Identity");
        }
      }

      /// <summary>
      /// Computable language of mapping.
      /// </summary>
      [FhirElement("language", InSummary=true, Order=40)]
      [Binding("MimeType")]
      [DataMember]
      public Hl7.Fhir.Model.Code? LanguageElement
      {
        get
        {
          if(_LanguageElement.InOverflow<Hl7.Fhir.Model.Code>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Code), Overflow["language"]);
          return _LanguageElement;
        }

        set
        {
          if (_LanguageElement.InOverflow<Hl7.Fhir.Model.Code>())
            Overflow.Remove("language");
          _LanguageElement = value;
          OnPropertyChanged("LanguageElement");
        }

      }

      private Hl7.Fhir.Model.Code? _LanguageElement;

      /// <summary>
      /// Computable language of mapping
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? Language
      {
        get => LanguageElement?.Value;
        set
        {
          LanguageElement = value is null ? null! : new Hl7.Fhir.Model.Code(value);
          OnPropertyChanged("Language");
        }
      }

      /// <summary>
      /// Details of the mapping.
      /// </summary>
      [FhirElement("map", InSummary=true, Order=50)]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString MapElement
      {
        get
        {
          if(_MapElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirString), Overflow["map"]);
          return _MapElement!;
        }

        set
        {
          if (_MapElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            Overflow.Remove("map");
          _MapElement = value;
          OnPropertyChanged("MapElement");
        }

      }

      private Hl7.Fhir.Model.FhirString? _MapElement;

      /// <summary>
      /// Details of the mapping
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? Map
      {
        get => MapElement?.Value;
        set
        {
          MapElement = value is null ? null! : new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Map");
        }
      }

      /// <summary>
      /// Comments about the mapping or its use.
      /// </summary>
      /// <remarks>
      /// The type of this element has changed over time. Make sure to use Hl7.Fhir.Model.FhirString in STU3, R4 and R4B, Hl7.Fhir.Model.Markdown starting from R5.
      /// </remarks>
      [FhirElement("comment", InSummary=true, Order=60)]
      [AllowedTypes(typeof(Hl7.Fhir.Model.FhirString), Since = FhirRelease.STU3)]
      [AllowedTypes(typeof(Hl7.Fhir.Model.Markdown), Since = FhirRelease.R5)]
      [DataMember]
      public Hl7.Fhir.Model.PrimitiveType? CommentElement
      {
        get
        {
          if(_CommentElement.InOverflow<DynamicPrimitive>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.PrimitiveType), Overflow["comment"]);
          return _CommentElement;
        }

        set
        {
          if (_CommentElement.InOverflow<DynamicPrimitive>())
            Overflow.Remove("comment");
          _CommentElement = value;
          OnPropertyChanged("CommentElement");
        }

      }

      private Hl7.Fhir.Model.PrimitiveType? _CommentElement;

      /// <summary>
      /// Comments about the mapping or its use. Use this property in STU3, R4 and R4B.
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? CommentString
      {
        get => ((IValue<string>?)CommentElement)?.Value;
        set
        {
          CommentElement = value is null ? null! : new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("CommentString");
        }
      }

      /// <summary>
      /// Comments about the mapping or its use. Use this property starting from R5.
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? Comment
      {
        get => ((IValue<string>?)CommentElement)?.Value;
        set
        {
          CommentElement = value is null ? null! : new Hl7.Fhir.Model.Markdown(value);
          OnPropertyChanged("Comment");
        }
      }

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not MappingComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_IdentityElement is not null) dest.IdentityElement = (Hl7.Fhir.Model.Id)_IdentityElement.DeepCopyInternal();
        if(_LanguageElement is not null) dest.LanguageElement = (Hl7.Fhir.Model.Code)_LanguageElement.DeepCopyInternal();
        if(_MapElement is not null) dest.MapElement = (Hl7.Fhir.Model.FhirString)_MapElement.DeepCopyInternal();
        if(_CommentElement is not null) dest.CommentElement = (Hl7.Fhir.Model.PrimitiveType)_CommentElement.DeepCopyInternal();
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new MappingComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not MappingComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_IdentityElement, otherT._IdentityElement)) return false;
        if(!comparer.Equals(_LanguageElement, otherT._LanguageElement)) return false;
        if(!comparer.Equals(_MapElement, otherT._MapElement)) return false;
        if(!comparer.Equals(_CommentElement, otherT._CommentElement)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "identity":
            if (_IdentityElement.InOverflow<Hl7.Fhir.Model.Id>())
            {
              value = Overflow["identity"];
              return true;
            }
            value = _IdentityElement;
            return (value as Hl7.Fhir.Model.Id) is not null;
          case "language":
            if (_LanguageElement.InOverflow<Hl7.Fhir.Model.Code>())
            {
              value = Overflow["language"];
              return true;
            }
            value = _LanguageElement;
            return (value as Hl7.Fhir.Model.Code) is not null;
          case "map":
            if (_MapElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            {
              value = Overflow["map"];
              return true;
            }
            value = _MapElement;
            return (value as Hl7.Fhir.Model.FhirString) is not null;
          case "comment":
            if (_CommentElement.InOverflow<DynamicPrimitive>())
            {
              value = Overflow["comment"];
              return true;
            }
            value = _CommentElement;
            return (value as Hl7.Fhir.Model.PrimitiveType) is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "identity":
            if (value is not (Hl7.Fhir.Model.Id or null))
            {
              IdentityElement = OverflowNull<Hl7.Fhir.Model.Id>.INSTANCE;
              Overflow["identity"] = value;
            }
            else IdentityElement = (Hl7.Fhir.Model.Id?)value!;
            return this;
          case "language":
            if (value is not (Hl7.Fhir.Model.Code or null))
            {
              LanguageElement = OverflowNull<Hl7.Fhir.Model.Code>.INSTANCE;
              Overflow["language"] = value;
            }
            else LanguageElement = (Hl7.Fhir.Model.Code?)value;
            return this;
          case "map":
            if (value is not (Hl7.Fhir.Model.FhirString or null))
            {
              MapElement = OverflowNull<Hl7.Fhir.Model.FhirString>.INSTANCE;
              Overflow["map"] = value;
            }
            else MapElement = (Hl7.Fhir.Model.FhirString?)value!;
            return this;
          case "comment":
            if (value is not (Hl7.Fhir.Model.PrimitiveType or null))
            {
              CommentElement = OverflowNull<DynamicPrimitive>.INSTANCE;
              Overflow["comment"] = value;
            }
            else CommentElement = (Hl7.Fhir.Model.PrimitiveType?)value;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_IdentityElement is not null && !_IdentityElement.InOverflow<Hl7.Fhir.Model.Id>()) yield return new KeyValuePair<string,object>("identity",_IdentityElement);
        if (_LanguageElement is not null && !_LanguageElement.InOverflow<Hl7.Fhir.Model.Code>()) yield return new KeyValuePair<string,object>("language",_LanguageElement);
        if (_MapElement is not null && !_MapElement.InOverflow<Hl7.Fhir.Model.FhirString>()) yield return new KeyValuePair<string,object>("map",_MapElement);
        if (_CommentElement is not null && !_CommentElement.InOverflow<DynamicPrimitive>()) yield return new KeyValuePair<string,object>("comment",_CommentElement);
      }

    }

    /// <summary>
    /// Path of the element in the hierarchy of elements.
    /// </summary>
    [FhirElement("path", InSummary=true, Order=40)]
    [Cardinality(Min=1,Max=1)]
    [DataMember]
    public Hl7.Fhir.Model.FhirString PathElement
    {
      get
      {
        if(_PathElement.InOverflow<Hl7.Fhir.Model.FhirString>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirString), Overflow["path"]);
        return _PathElement!;
      }

      set
      {
        if (_PathElement.InOverflow<Hl7.Fhir.Model.FhirString>())
          Overflow.Remove("path");
        _PathElement = value;
        OnPropertyChanged("PathElement");
      }

    }

    private Hl7.Fhir.Model.FhirString? _PathElement;

    /// <summary>
    /// Path of the element in the hierarchy of elements
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string? Path
    {
      get => PathElement?.Value;
      set
      {
        PathElement = value is null ? null! : new Hl7.Fhir.Model.FhirString(value);
        OnPropertyChanged("Path");
      }
    }

    /// <summary>
    /// xmlAttr | xmlText | typeAttr | cdaText | xhtml.
    /// </summary>
    [FhirElement("representation", InSummary=true, Order=50)]
    [Binding("PropertyRepresentation")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Code<Hl7.Fhir.Model.ElementDefinition.PropertyRepresentation>> RepresentationElement
    {
      get
      {
        if(_RepresentationElement.InOverflow<List<Code<Hl7.Fhir.Model.ElementDefinition.PropertyRepresentation>>>())
          throw CodedValidationException.FromTypes(typeof(List<Code<Hl7.Fhir.Model.ElementDefinition.PropertyRepresentation>>), Overflow["representation"]);
        return _RepresentationElement ??= [];
      }

      set
      {
        if (_RepresentationElement.InOverflow<List<Code<Hl7.Fhir.Model.ElementDefinition.PropertyRepresentation>>>())
          Overflow.Remove("representation");
        _RepresentationElement = value;
        OnPropertyChanged("RepresentationElement");
      }

    }

    private List<Code<Hl7.Fhir.Model.ElementDefinition.PropertyRepresentation>>? _RepresentationElement;

    /// <summary>
    /// xmlAttr | xmlText | typeAttr | cdaText | xhtml
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public IEnumerable<Hl7.Fhir.Model.ElementDefinition.PropertyRepresentation?> Representation
    {
      get => _RepresentationElement?.Select(elem => elem.Value) ?? [];
      set
      {
        if (value == null)
          RepresentationElement = null!;
        else
          RepresentationElement = new List<Code<Hl7.Fhir.Model.ElementDefinition.PropertyRepresentation>>(value.Select(elem=>new Code<Hl7.Fhir.Model.ElementDefinition.PropertyRepresentation>(elem)));
        OnPropertyChanged("Representation");
      }
    }

    /// <summary>
    /// Name for this particular element (in a set of slices).
    /// </summary>
    [FhirElement("sliceName", InSummary=true, Order=60)]
    [DataMember]
    public Hl7.Fhir.Model.FhirString? SliceNameElement
    {
      get
      {
        if(_SliceNameElement.InOverflow<Hl7.Fhir.Model.FhirString>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirString), Overflow["sliceName"]);
        return _SliceNameElement;
      }

      set
      {
        if (_SliceNameElement.InOverflow<Hl7.Fhir.Model.FhirString>())
          Overflow.Remove("sliceName");
        _SliceNameElement = value;
        OnPropertyChanged("SliceNameElement");
      }

    }

    private Hl7.Fhir.Model.FhirString? _SliceNameElement;

    /// <summary>
    /// Name for this particular element (in a set of slices)
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string? SliceName
    {
      get => SliceNameElement?.Value;
      set
      {
        SliceNameElement = value is null ? null! : new Hl7.Fhir.Model.FhirString(value);
        OnPropertyChanged("SliceName");
      }
    }

    /// <summary>
    /// If this slice definition constrains an inherited slice definition (or not).
    /// </summary>
    [FhirElement("sliceIsConstraining", InSummary=true, Order=70)]
    [DataMember]
    public Hl7.Fhir.Model.FhirBoolean? SliceIsConstrainingElement
    {
      get
      {
        if(_SliceIsConstrainingElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirBoolean), Overflow["sliceIsConstraining"]);
        return _SliceIsConstrainingElement;
      }

      set
      {
        if (_SliceIsConstrainingElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>())
          Overflow.Remove("sliceIsConstraining");
        _SliceIsConstrainingElement = value;
        OnPropertyChanged("SliceIsConstrainingElement");
      }

    }

    private Hl7.Fhir.Model.FhirBoolean? _SliceIsConstrainingElement;

    /// <summary>
    /// If this slice definition constrains an inherited slice definition (or not)
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public bool? SliceIsConstraining
    {
      get => SliceIsConstrainingElement?.Value;
      set
      {
        SliceIsConstrainingElement = value is null ? null! : new Hl7.Fhir.Model.FhirBoolean(value);
        OnPropertyChanged("SliceIsConstraining");
      }
    }

    /// <summary>
    /// Name for element to display with or prompt for element.
    /// </summary>
    [FhirElement("label", InSummary=true, Order=80)]
    [DataMember]
    public Hl7.Fhir.Model.FhirString? LabelElement
    {
      get
      {
        if(_LabelElement.InOverflow<Hl7.Fhir.Model.FhirString>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirString), Overflow["label"]);
        return _LabelElement;
      }

      set
      {
        if (_LabelElement.InOverflow<Hl7.Fhir.Model.FhirString>())
          Overflow.Remove("label");
        _LabelElement = value;
        OnPropertyChanged("LabelElement");
      }

    }

    private Hl7.Fhir.Model.FhirString? _LabelElement;

    /// <summary>
    /// Name for element to display with or prompt for element
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string? Label
    {
      get => LabelElement?.Value;
      set
      {
        LabelElement = value is null ? null! : new Hl7.Fhir.Model.FhirString(value);
        OnPropertyChanged("Label");
      }
    }

    /// <summary>
    /// Corresponding codes in terminologies.
    /// </summary>
    [FhirElement("code", InSummary=true, Order=90)]
    [Binding("ElementDefinitionCode")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Hl7.Fhir.Model.Coding> Code
    {
      get
      {
        if(_Code.InOverflow<List<Hl7.Fhir.Model.Coding>>())
          throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.Coding>), Overflow["code"]);
        return _Code ??= [];
      }

      set
      {
        if (_Code.InOverflow<List<Hl7.Fhir.Model.Coding>>())
          Overflow.Remove("code");
        _Code = value;
        OnPropertyChanged("Code");
      }

    }

    private List<Hl7.Fhir.Model.Coding>? _Code;

    /// <summary>
    /// This element is sliced - slices follow.
    /// </summary>
    [FhirElement("slicing", InSummary=true, Order=100)]
    [DataMember]
    public Hl7.Fhir.Model.ElementDefinition.SlicingComponent? Slicing
    {
      get
      {
        if(_Slicing.InOverflow<Hl7.Fhir.Model.ElementDefinition.SlicingComponent>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.ElementDefinition.SlicingComponent), Overflow["slicing"]);
        return _Slicing;
      }

      set
      {
        if (_Slicing.InOverflow<Hl7.Fhir.Model.ElementDefinition.SlicingComponent>())
          Overflow.Remove("slicing");
        _Slicing = value;
        OnPropertyChanged("Slicing");
      }

    }

    private Hl7.Fhir.Model.ElementDefinition.SlicingComponent? _Slicing;

    /// <summary>
    /// Concise definition for space-constrained presentation.
    /// </summary>
    [FhirElement("short", InSummary=true, Order=110)]
    [DataMember]
    public Hl7.Fhir.Model.FhirString? ShortElement
    {
      get
      {
        if(_ShortElement.InOverflow<Hl7.Fhir.Model.FhirString>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirString), Overflow["short"]);
        return _ShortElement;
      }

      set
      {
        if (_ShortElement.InOverflow<Hl7.Fhir.Model.FhirString>())
          Overflow.Remove("short");
        _ShortElement = value;
        OnPropertyChanged("ShortElement");
      }

    }

    private Hl7.Fhir.Model.FhirString? _ShortElement;

    /// <summary>
    /// Concise definition for space-constrained presentation
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string? Short
    {
      get => ShortElement?.Value;
      set
      {
        ShortElement = value is null ? null! : new Hl7.Fhir.Model.FhirString(value);
        OnPropertyChanged("Short");
      }
    }

    /// <summary>
    /// Full formal definition as narrative text.
    /// </summary>
    [FhirElement("definition", InSummary=true, Order=120)]
    [DataMember]
    public Hl7.Fhir.Model.Markdown? DefinitionElement
    {
      get
      {
        if(_DefinitionElement.InOverflow<Hl7.Fhir.Model.Markdown>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Markdown), Overflow["definition"]);
        return _DefinitionElement;
      }

      set
      {
        if (_DefinitionElement.InOverflow<Hl7.Fhir.Model.Markdown>())
          Overflow.Remove("definition");
        _DefinitionElement = value;
        OnPropertyChanged("DefinitionElement");
      }

    }

    private Hl7.Fhir.Model.Markdown? _DefinitionElement;

    /// <summary>
    /// Full formal definition as narrative text
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string? Definition
    {
      get => DefinitionElement?.Value;
      set
      {
        DefinitionElement = value is null ? null! : new Hl7.Fhir.Model.Markdown(value);
        OnPropertyChanged("Definition");
      }
    }

    /// <summary>
    /// Comments about the use of this element.
    /// </summary>
    [FhirElement("comment", InSummary=true, Order=130)]
    [DataMember]
    public Hl7.Fhir.Model.Markdown? CommentElement
    {
      get
      {
        if(_CommentElement.InOverflow<Hl7.Fhir.Model.Markdown>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Markdown), Overflow["comment"]);
        return _CommentElement;
      }

      set
      {
        if (_CommentElement.InOverflow<Hl7.Fhir.Model.Markdown>())
          Overflow.Remove("comment");
        _CommentElement = value;
        OnPropertyChanged("CommentElement");
      }

    }

    private Hl7.Fhir.Model.Markdown? _CommentElement;

    /// <summary>
    /// Comments about the use of this element
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string? Comment
    {
      get => CommentElement?.Value;
      set
      {
        CommentElement = value is null ? null! : new Hl7.Fhir.Model.Markdown(value);
        OnPropertyChanged("Comment");
      }
    }

    /// <summary>
    /// Why this resource has been created.
    /// </summary>
    [FhirElement("requirements", InSummary=true, Order=140)]
    [DataMember]
    public Hl7.Fhir.Model.Markdown? RequirementsElement
    {
      get
      {
        if(_RequirementsElement.InOverflow<Hl7.Fhir.Model.Markdown>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Markdown), Overflow["requirements"]);
        return _RequirementsElement;
      }

      set
      {
        if (_RequirementsElement.InOverflow<Hl7.Fhir.Model.Markdown>())
          Overflow.Remove("requirements");
        _RequirementsElement = value;
        OnPropertyChanged("RequirementsElement");
      }

    }

    private Hl7.Fhir.Model.Markdown? _RequirementsElement;

    /// <summary>
    /// Why this resource has been created
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string? Requirements
    {
      get => RequirementsElement?.Value;
      set
      {
        RequirementsElement = value is null ? null! : new Hl7.Fhir.Model.Markdown(value);
        OnPropertyChanged("Requirements");
      }
    }

    /// <summary>
    /// Other names.
    /// </summary>
    [FhirElement("alias", InSummary=true, Order=150)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Hl7.Fhir.Model.FhirString> AliasElement
    {
      get
      {
        if(_AliasElement.InOverflow<List<Hl7.Fhir.Model.FhirString>>())
          throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.FhirString>), Overflow["alias"]);
        return _AliasElement ??= [];
      }

      set
      {
        if (_AliasElement.InOverflow<List<Hl7.Fhir.Model.FhirString>>())
          Overflow.Remove("alias");
        _AliasElement = value;
        OnPropertyChanged("AliasElement");
      }

    }

    private List<Hl7.Fhir.Model.FhirString>? _AliasElement;

    /// <summary>
    /// Other names
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public IEnumerable<string?> Alias
    {
      get => _AliasElement?.Select(elem => elem.Value) ?? [];
      set
      {
        if (value == null)
          AliasElement = null!;
        else
          AliasElement = new List<Hl7.Fhir.Model.FhirString>(value.Select(elem=>new Hl7.Fhir.Model.FhirString(elem)));
        OnPropertyChanged("Alias");
      }
    }

    /// <summary>
    /// Minimum Cardinality.
    /// </summary>
    [FhirElement("min", InSummary=true, Order=160)]
    [DataMember]
    public Hl7.Fhir.Model.UnsignedInt? MinElement
    {
      get
      {
        if(_MinElement.InOverflow<Hl7.Fhir.Model.UnsignedInt>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.UnsignedInt), Overflow["min"]);
        return _MinElement;
      }

      set
      {
        if (_MinElement.InOverflow<Hl7.Fhir.Model.UnsignedInt>())
          Overflow.Remove("min");
        _MinElement = value;
        OnPropertyChanged("MinElement");
      }

    }

    private Hl7.Fhir.Model.UnsignedInt? _MinElement;

    /// <summary>
    /// Minimum Cardinality
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public int? Min
    {
      get => MinElement?.Value;
      set
      {
        MinElement = value is null ? null! : new Hl7.Fhir.Model.UnsignedInt(value);
        OnPropertyChanged("Min");
      }
    }

    /// <summary>
    /// Maximum Cardinality (a number or *).
    /// </summary>
    [FhirElement("max", InSummary=true, Order=170)]
    [DataMember]
    public Hl7.Fhir.Model.FhirString? MaxElement
    {
      get
      {
        if(_MaxElement.InOverflow<Hl7.Fhir.Model.FhirString>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirString), Overflow["max"]);
        return _MaxElement;
      }

      set
      {
        if (_MaxElement.InOverflow<Hl7.Fhir.Model.FhirString>())
          Overflow.Remove("max");
        _MaxElement = value;
        OnPropertyChanged("MaxElement");
      }

    }

    private Hl7.Fhir.Model.FhirString? _MaxElement;

    /// <summary>
    /// Maximum Cardinality (a number or *)
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string? Max
    {
      get => MaxElement?.Value;
      set
      {
        MaxElement = value is null ? null! : new Hl7.Fhir.Model.FhirString(value);
        OnPropertyChanged("Max");
      }
    }

    /// <summary>
    /// Base definition information for tools.
    /// </summary>
    [FhirElement("base", InSummary=true, Order=180)]
    [DataMember]
    public Hl7.Fhir.Model.ElementDefinition.BaseComponent? Base
    {
      get
      {
        if(_Base.InOverflow<Hl7.Fhir.Model.ElementDefinition.BaseComponent>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.ElementDefinition.BaseComponent), Overflow["base"]);
        return _Base;
      }

      set
      {
        if (_Base.InOverflow<Hl7.Fhir.Model.ElementDefinition.BaseComponent>())
          Overflow.Remove("base");
        _Base = value;
        OnPropertyChanged("Base");
      }

    }

    private Hl7.Fhir.Model.ElementDefinition.BaseComponent? _Base;

    /// <summary>
    /// Reference to definition of content for the element.
    /// </summary>
    [FhirElement("contentReference", InSummary=true, Order=190)]
    [DataMember]
    public Hl7.Fhir.Model.FhirUri? ContentReferenceElement
    {
      get
      {
        if(_ContentReferenceElement.InOverflow<Hl7.Fhir.Model.FhirUri>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirUri), Overflow["contentReference"]);
        return _ContentReferenceElement;
      }

      set
      {
        if (_ContentReferenceElement.InOverflow<Hl7.Fhir.Model.FhirUri>())
          Overflow.Remove("contentReference");
        _ContentReferenceElement = value;
        OnPropertyChanged("ContentReferenceElement");
      }

    }

    private Hl7.Fhir.Model.FhirUri? _ContentReferenceElement;

    /// <summary>
    /// Reference to definition of content for the element
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string? ContentReference
    {
      get => ContentReferenceElement?.Value;
      set
      {
        ContentReferenceElement = value is null ? null! : new Hl7.Fhir.Model.FhirUri(value);
        OnPropertyChanged("ContentReference");
      }
    }

    /// <summary>
    /// Data type and Profile for this element.
    /// </summary>
    [FhirElement("type", InSummary=true, Order=200)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Hl7.Fhir.Model.ElementDefinition.TypeRefComponent> Type
    {
      get
      {
        if(_Type.InOverflow<List<Hl7.Fhir.Model.ElementDefinition.TypeRefComponent>>())
          throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.ElementDefinition.TypeRefComponent>), Overflow["type"]);
        return _Type ??= [];
      }

      set
      {
        if (_Type.InOverflow<List<Hl7.Fhir.Model.ElementDefinition.TypeRefComponent>>())
          Overflow.Remove("type");
        _Type = value;
        OnPropertyChanged("Type");
      }

    }

    private List<Hl7.Fhir.Model.ElementDefinition.TypeRefComponent>? _Type;

    /// <summary>
    /// Specified value if missing from instance.
    /// </summary>
    [FhirElement("defaultValue", InSummary=true, Order=210, Choice=ChoiceType.DatatypeChoice)]
    [CLSCompliant(false)]
    [AllowedTypes(OpenChoice = true)]
    [DataMember]
    public Hl7.Fhir.Model.DataType? DefaultValue
    {
      get
      {
        if(_DefaultValue.InOverflow<DynamicDataType>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.DataType), Overflow["defaultValue"]);
        return _DefaultValue;
      }

      set
      {
        if (_DefaultValue.InOverflow<DynamicDataType>())
          Overflow.Remove("defaultValue");
        _DefaultValue = value;
        OnPropertyChanged("DefaultValue");
      }

    }

    private Hl7.Fhir.Model.DataType? _DefaultValue;

    /// <summary>
    /// Implicit meaning when this element is missing.
    /// </summary>
    [FhirElement("meaningWhenMissing", InSummary=true, Order=220)]
    [DataMember]
    public Hl7.Fhir.Model.Markdown? MeaningWhenMissingElement
    {
      get
      {
        if(_MeaningWhenMissingElement.InOverflow<Hl7.Fhir.Model.Markdown>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Markdown), Overflow["meaningWhenMissing"]);
        return _MeaningWhenMissingElement;
      }

      set
      {
        if (_MeaningWhenMissingElement.InOverflow<Hl7.Fhir.Model.Markdown>())
          Overflow.Remove("meaningWhenMissing");
        _MeaningWhenMissingElement = value;
        OnPropertyChanged("MeaningWhenMissingElement");
      }

    }

    private Hl7.Fhir.Model.Markdown? _MeaningWhenMissingElement;

    /// <summary>
    /// Implicit meaning when this element is missing
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string? MeaningWhenMissing
    {
      get => MeaningWhenMissingElement?.Value;
      set
      {
        MeaningWhenMissingElement = value is null ? null! : new Hl7.Fhir.Model.Markdown(value);
        OnPropertyChanged("MeaningWhenMissing");
      }
    }

    /// <summary>
    /// What the order of the elements means.
    /// </summary>
    [FhirElement("orderMeaning", InSummary=true, Order=230)]
    [DataMember]
    public Hl7.Fhir.Model.FhirString? OrderMeaningElement
    {
      get
      {
        if(_OrderMeaningElement.InOverflow<Hl7.Fhir.Model.FhirString>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirString), Overflow["orderMeaning"]);
        return _OrderMeaningElement;
      }

      set
      {
        if (_OrderMeaningElement.InOverflow<Hl7.Fhir.Model.FhirString>())
          Overflow.Remove("orderMeaning");
        _OrderMeaningElement = value;
        OnPropertyChanged("OrderMeaningElement");
      }

    }

    private Hl7.Fhir.Model.FhirString? _OrderMeaningElement;

    /// <summary>
    /// What the order of the elements means
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string? OrderMeaning
    {
      get => OrderMeaningElement?.Value;
      set
      {
        OrderMeaningElement = value is null ? null! : new Hl7.Fhir.Model.FhirString(value);
        OnPropertyChanged("OrderMeaning");
      }
    }

    /// <summary>
    /// Value must be exactly this.
    /// </summary>
    [FhirElement("fixed", InSummary=true, Order=240, Choice=ChoiceType.DatatypeChoice)]
    [CLSCompliant(false)]
    [AllowedTypes(OpenChoice = true)]
    [DataMember]
    public Hl7.Fhir.Model.DataType? Fixed
    {
      get
      {
        if(_Fixed.InOverflow<DynamicDataType>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.DataType), Overflow["fixed"]);
        return _Fixed;
      }

      set
      {
        if (_Fixed.InOverflow<DynamicDataType>())
          Overflow.Remove("fixed");
        _Fixed = value;
        OnPropertyChanged("Fixed");
      }

    }

    private Hl7.Fhir.Model.DataType? _Fixed;

    /// <summary>
    /// Value must have at least these property values.
    /// </summary>
    [FhirElement("pattern", InSummary=true, Order=250, Choice=ChoiceType.DatatypeChoice)]
    [CLSCompliant(false)]
    [AllowedTypes(OpenChoice = true)]
    [DataMember]
    public Hl7.Fhir.Model.DataType? Pattern
    {
      get
      {
        if(_Pattern.InOverflow<DynamicDataType>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.DataType), Overflow["pattern"]);
        return _Pattern;
      }

      set
      {
        if (_Pattern.InOverflow<DynamicDataType>())
          Overflow.Remove("pattern");
        _Pattern = value;
        OnPropertyChanged("Pattern");
      }

    }

    private Hl7.Fhir.Model.DataType? _Pattern;

    /// <summary>
    /// Example value (as defined for type).
    /// </summary>
    [FhirElement("example", InSummary=true, Order=260)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Hl7.Fhir.Model.ElementDefinition.ExampleComponent> Example
    {
      get
      {
        if(_Example.InOverflow<List<Hl7.Fhir.Model.ElementDefinition.ExampleComponent>>())
          throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.ElementDefinition.ExampleComponent>), Overflow["example"]);
        return _Example ??= [];
      }

      set
      {
        if (_Example.InOverflow<List<Hl7.Fhir.Model.ElementDefinition.ExampleComponent>>())
          Overflow.Remove("example");
        _Example = value;
        OnPropertyChanged("Example");
      }

    }

    private List<Hl7.Fhir.Model.ElementDefinition.ExampleComponent>? _Example;

    /// <summary>
    /// Minimum Allowed Value (for some types).
    /// </summary>
    [FhirElement("minValue", InSummary=true, Order=270, Choice=ChoiceType.DatatypeChoice)]
    [CLSCompliant(false)]
    [AllowedTypes(typeof(Hl7.Fhir.Model.Date),typeof(Hl7.Fhir.Model.FhirDateTime),typeof(Hl7.Fhir.Model.Instant),typeof(Hl7.Fhir.Model.Time),typeof(Hl7.Fhir.Model.FhirDecimal),typeof(Hl7.Fhir.Model.Integer),typeof(Hl7.Fhir.Model.Integer64),typeof(Hl7.Fhir.Model.PositiveInt),typeof(Hl7.Fhir.Model.UnsignedInt),typeof(Hl7.Fhir.Model.Quantity))]
    [DataMember]
    public Hl7.Fhir.Model.DataType? MinValue
    {
      get
      {
        if(_MinValue.InOverflow<DynamicDataType>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.DataType), Overflow["minValue"]);
        return _MinValue;
      }

      set
      {
        if (_MinValue.InOverflow<DynamicDataType>())
          Overflow.Remove("minValue");
        _MinValue = value;
        OnPropertyChanged("MinValue");
      }

    }

    private Hl7.Fhir.Model.DataType? _MinValue;

    /// <summary>
    /// Maximum Allowed Value (for some types).
    /// </summary>
    [FhirElement("maxValue", InSummary=true, Order=280, Choice=ChoiceType.DatatypeChoice)]
    [CLSCompliant(false)]
    [AllowedTypes(typeof(Hl7.Fhir.Model.Date),typeof(Hl7.Fhir.Model.FhirDateTime),typeof(Hl7.Fhir.Model.Instant),typeof(Hl7.Fhir.Model.Time),typeof(Hl7.Fhir.Model.FhirDecimal),typeof(Hl7.Fhir.Model.Integer),typeof(Hl7.Fhir.Model.Integer64),typeof(Hl7.Fhir.Model.PositiveInt),typeof(Hl7.Fhir.Model.UnsignedInt),typeof(Hl7.Fhir.Model.Quantity))]
    [DataMember]
    public Hl7.Fhir.Model.DataType? MaxValue
    {
      get
      {
        if(_MaxValue.InOverflow<DynamicDataType>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.DataType), Overflow["maxValue"]);
        return _MaxValue;
      }

      set
      {
        if (_MaxValue.InOverflow<DynamicDataType>())
          Overflow.Remove("maxValue");
        _MaxValue = value;
        OnPropertyChanged("MaxValue");
      }

    }

    private Hl7.Fhir.Model.DataType? _MaxValue;

    /// <summary>
    /// Max length for string type data.
    /// </summary>
    [FhirElement("maxLength", InSummary=true, Order=290)]
    [DataMember]
    public Hl7.Fhir.Model.Integer? MaxLengthElement
    {
      get
      {
        if(_MaxLengthElement.InOverflow<Hl7.Fhir.Model.Integer>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Integer), Overflow["maxLength"]);
        return _MaxLengthElement;
      }

      set
      {
        if (_MaxLengthElement.InOverflow<Hl7.Fhir.Model.Integer>())
          Overflow.Remove("maxLength");
        _MaxLengthElement = value;
        OnPropertyChanged("MaxLengthElement");
      }

    }

    private Hl7.Fhir.Model.Integer? _MaxLengthElement;

    /// <summary>
    /// Max length for string type data
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public int? MaxLength
    {
      get => MaxLengthElement?.Value;
      set
      {
        MaxLengthElement = value is null ? null! : new Hl7.Fhir.Model.Integer(value);
        OnPropertyChanged("MaxLength");
      }
    }

    /// <summary>
    /// Reference to invariant about presence.
    /// </summary>
    [FhirElement("condition", InSummary=true, Order=300)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Hl7.Fhir.Model.Id> ConditionElement
    {
      get
      {
        if(_ConditionElement.InOverflow<List<Hl7.Fhir.Model.Id>>())
          throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.Id>), Overflow["condition"]);
        return _ConditionElement ??= [];
      }

      set
      {
        if (_ConditionElement.InOverflow<List<Hl7.Fhir.Model.Id>>())
          Overflow.Remove("condition");
        _ConditionElement = value;
        OnPropertyChanged("ConditionElement");
      }

    }

    private List<Hl7.Fhir.Model.Id>? _ConditionElement;

    /// <summary>
    /// Reference to invariant about presence
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public IEnumerable<string?> Condition
    {
      get => _ConditionElement?.Select(elem => elem.Value) ?? [];
      set
      {
        if (value == null)
          ConditionElement = null!;
        else
          ConditionElement = new List<Hl7.Fhir.Model.Id>(value.Select(elem=>new Hl7.Fhir.Model.Id(elem)));
        OnPropertyChanged("Condition");
      }
    }

    /// <summary>
    /// Condition that must evaluate to true.
    /// </summary>
    [FhirElement("constraint", InSummary=true, Order=310)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Hl7.Fhir.Model.ElementDefinition.ConstraintComponent> Constraint
    {
      get
      {
        if(_Constraint.InOverflow<List<Hl7.Fhir.Model.ElementDefinition.ConstraintComponent>>())
          throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.ElementDefinition.ConstraintComponent>), Overflow["constraint"]);
        return _Constraint ??= [];
      }

      set
      {
        if (_Constraint.InOverflow<List<Hl7.Fhir.Model.ElementDefinition.ConstraintComponent>>())
          Overflow.Remove("constraint");
        _Constraint = value;
        OnPropertyChanged("Constraint");
      }

    }

    private List<Hl7.Fhir.Model.ElementDefinition.ConstraintComponent>? _Constraint;

    /// <summary>
    /// For primitives, that a value must be present - not replaced by an extension.
    /// </summary>
    /// <remarks>
    /// Element was introduced in R5, do not use when working with older releases.
    /// </remarks>
    [FhirElement("mustHaveValue", InSummary=true, Order=320, Since=FhirRelease.R5)]
    [DataMember]
    public Hl7.Fhir.Model.FhirBoolean? MustHaveValueElement
    {
      get
      {
        if(_MustHaveValueElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirBoolean), Overflow["mustHaveValue"]);
        return _MustHaveValueElement;
      }

      set
      {
        if (_MustHaveValueElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>())
          Overflow.Remove("mustHaveValue");
        _MustHaveValueElement = value;
        OnPropertyChanged("MustHaveValueElement");
      }

    }

    private Hl7.Fhir.Model.FhirBoolean? _MustHaveValueElement;

    /// <summary>
    /// For primitives, that a value must be present - not replaced by an extension
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public bool? MustHaveValue
    {
      get => MustHaveValueElement?.Value;
      set
      {
        MustHaveValueElement = value is null ? null! : new Hl7.Fhir.Model.FhirBoolean(value);
        OnPropertyChanged("MustHaveValue");
      }
    }

    /// <summary>
    /// Extensions that are allowed to replace a primitive value.
    /// </summary>
    /// <remarks>
    /// Element was introduced in R5, do not use when working with older releases.
    /// </remarks>
    [FhirElement("valueAlternatives", InSummary=true, Order=330, Since=FhirRelease.R5)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Hl7.Fhir.Model.Canonical> ValueAlternativesElement
    {
      get
      {
        if(_ValueAlternativesElement.InOverflow<List<Hl7.Fhir.Model.Canonical>>())
          throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.Canonical>), Overflow["valueAlternatives"]);
        return _ValueAlternativesElement ??= [];
      }

      set
      {
        if (_ValueAlternativesElement.InOverflow<List<Hl7.Fhir.Model.Canonical>>())
          Overflow.Remove("valueAlternatives");
        _ValueAlternativesElement = value;
        OnPropertyChanged("ValueAlternativesElement");
      }

    }

    private List<Hl7.Fhir.Model.Canonical>? _ValueAlternativesElement;

    /// <summary>
    /// Extensions that are allowed to replace a primitive value
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public IEnumerable<string?> ValueAlternatives
    {
      get => _ValueAlternativesElement?.Select(elem => elem.Value) ?? [];
      set
      {
        if (value == null)
          ValueAlternativesElement = null!;
        else
          ValueAlternativesElement = new List<Hl7.Fhir.Model.Canonical>(value.Select(elem=>new Hl7.Fhir.Model.Canonical(elem)));
        OnPropertyChanged("ValueAlternatives");
      }
    }

    /// <summary>
    /// If the element must be supported (discouraged - see obligations).
    /// </summary>
    [FhirElement("mustSupport", InSummary=true, Order=340)]
    [DataMember]
    public Hl7.Fhir.Model.FhirBoolean? MustSupportElement
    {
      get
      {
        if(_MustSupportElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirBoolean), Overflow["mustSupport"]);
        return _MustSupportElement;
      }

      set
      {
        if (_MustSupportElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>())
          Overflow.Remove("mustSupport");
        _MustSupportElement = value;
        OnPropertyChanged("MustSupportElement");
      }

    }

    private Hl7.Fhir.Model.FhirBoolean? _MustSupportElement;

    /// <summary>
    /// If the element must be supported (discouraged - see obligations)
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public bool? MustSupport
    {
      get => MustSupportElement?.Value;
      set
      {
        MustSupportElement = value is null ? null! : new Hl7.Fhir.Model.FhirBoolean(value);
        OnPropertyChanged("MustSupport");
      }
    }

    /// <summary>
    /// If this modifies the meaning of other elements.
    /// </summary>
    [FhirElement("isModifier", InSummary=true, Order=350)]
    [DataMember]
    public Hl7.Fhir.Model.FhirBoolean? IsModifierElement
    {
      get
      {
        if(_IsModifierElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirBoolean), Overflow["isModifier"]);
        return _IsModifierElement;
      }

      set
      {
        if (_IsModifierElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>())
          Overflow.Remove("isModifier");
        _IsModifierElement = value;
        OnPropertyChanged("IsModifierElement");
      }

    }

    private Hl7.Fhir.Model.FhirBoolean? _IsModifierElement;

    /// <summary>
    /// If this modifies the meaning of other elements
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public bool? IsModifier
    {
      get => IsModifierElement?.Value;
      set
      {
        IsModifierElement = value is null ? null! : new Hl7.Fhir.Model.FhirBoolean(value);
        OnPropertyChanged("IsModifier");
      }
    }

    /// <summary>
    /// Reason that this element is marked as a modifier.
    /// </summary>
    [FhirElement("isModifierReason", InSummary=true, Order=360)]
    [DataMember]
    public Hl7.Fhir.Model.FhirString? IsModifierReasonElement
    {
      get
      {
        if(_IsModifierReasonElement.InOverflow<Hl7.Fhir.Model.FhirString>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirString), Overflow["isModifierReason"]);
        return _IsModifierReasonElement;
      }

      set
      {
        if (_IsModifierReasonElement.InOverflow<Hl7.Fhir.Model.FhirString>())
          Overflow.Remove("isModifierReason");
        _IsModifierReasonElement = value;
        OnPropertyChanged("IsModifierReasonElement");
      }

    }

    private Hl7.Fhir.Model.FhirString? _IsModifierReasonElement;

    /// <summary>
    /// Reason that this element is marked as a modifier
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string? IsModifierReason
    {
      get => IsModifierReasonElement?.Value;
      set
      {
        IsModifierReasonElement = value is null ? null! : new Hl7.Fhir.Model.FhirString(value);
        OnPropertyChanged("IsModifierReason");
      }
    }

    /// <summary>
    /// Include when _summary = true?.
    /// </summary>
    [FhirElement("isSummary", InSummary=true, Order=370)]
    [DataMember]
    public Hl7.Fhir.Model.FhirBoolean? IsSummaryElement
    {
      get
      {
        if(_IsSummaryElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirBoolean), Overflow["isSummary"]);
        return _IsSummaryElement;
      }

      set
      {
        if (_IsSummaryElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>())
          Overflow.Remove("isSummary");
        _IsSummaryElement = value;
        OnPropertyChanged("IsSummaryElement");
      }

    }

    private Hl7.Fhir.Model.FhirBoolean? _IsSummaryElement;

    /// <summary>
    /// Include when _summary = true?
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public bool? IsSummary
    {
      get => IsSummaryElement?.Value;
      set
      {
        IsSummaryElement = value is null ? null! : new Hl7.Fhir.Model.FhirBoolean(value);
        OnPropertyChanged("IsSummary");
      }
    }

    /// <summary>
    /// ValueSet details if this is coded.
    /// </summary>
    [FhirElement("binding", InSummary=true, Order=380)]
    [DataMember]
    public Hl7.Fhir.Model.ElementDefinition.ElementDefinitionBindingComponent? Binding
    {
      get
      {
        if(_Binding.InOverflow<Hl7.Fhir.Model.ElementDefinition.ElementDefinitionBindingComponent>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.ElementDefinition.ElementDefinitionBindingComponent), Overflow["binding"]);
        return _Binding;
      }

      set
      {
        if (_Binding.InOverflow<Hl7.Fhir.Model.ElementDefinition.ElementDefinitionBindingComponent>())
          Overflow.Remove("binding");
        _Binding = value;
        OnPropertyChanged("Binding");
      }

    }

    private Hl7.Fhir.Model.ElementDefinition.ElementDefinitionBindingComponent? _Binding;

    /// <summary>
    /// Map element to another set of definitions.
    /// </summary>
    [FhirElement("mapping", InSummary=true, Order=390)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Hl7.Fhir.Model.ElementDefinition.MappingComponent> Mapping
    {
      get
      {
        if(_Mapping.InOverflow<List<Hl7.Fhir.Model.ElementDefinition.MappingComponent>>())
          throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.ElementDefinition.MappingComponent>), Overflow["mapping"]);
        return _Mapping ??= [];
      }

      set
      {
        if (_Mapping.InOverflow<List<Hl7.Fhir.Model.ElementDefinition.MappingComponent>>())
          Overflow.Remove("mapping");
        _Mapping = value;
        OnPropertyChanged("Mapping");
      }

    }

    private List<Hl7.Fhir.Model.ElementDefinition.MappingComponent>? _Mapping;

    protected internal override void CopyToInternal(Base other)
    {
      if(other is not ElementDefinition dest)
        throw new ArgumentException("Can only copy to an object of the same type", "other");

      base.CopyToInternal(dest);
      if(_PathElement is not null) dest.PathElement = (Hl7.Fhir.Model.FhirString)_PathElement.DeepCopyInternal();
      if(_RepresentationElement is not null) dest.RepresentationElement = new List<Code<Hl7.Fhir.Model.ElementDefinition.PropertyRepresentation>>(_RepresentationElement.DeepCopyInternal());
      if(_SliceNameElement is not null) dest.SliceNameElement = (Hl7.Fhir.Model.FhirString)_SliceNameElement.DeepCopyInternal();
      if(_SliceIsConstrainingElement is not null) dest.SliceIsConstrainingElement = (Hl7.Fhir.Model.FhirBoolean)_SliceIsConstrainingElement.DeepCopyInternal();
      if(_LabelElement is not null) dest.LabelElement = (Hl7.Fhir.Model.FhirString)_LabelElement.DeepCopyInternal();
      if(_Code is not null) dest.Code = new List<Hl7.Fhir.Model.Coding>(_Code.DeepCopyInternal());
      if(_Slicing is not null) dest.Slicing = (Hl7.Fhir.Model.ElementDefinition.SlicingComponent)_Slicing.DeepCopyInternal();
      if(_ShortElement is not null) dest.ShortElement = (Hl7.Fhir.Model.FhirString)_ShortElement.DeepCopyInternal();
      if(_DefinitionElement is not null) dest.DefinitionElement = (Hl7.Fhir.Model.Markdown)_DefinitionElement.DeepCopyInternal();
      if(_CommentElement is not null) dest.CommentElement = (Hl7.Fhir.Model.Markdown)_CommentElement.DeepCopyInternal();
      if(_RequirementsElement is not null) dest.RequirementsElement = (Hl7.Fhir.Model.Markdown)_RequirementsElement.DeepCopyInternal();
      if(_AliasElement is not null) dest.AliasElement = new List<Hl7.Fhir.Model.FhirString>(_AliasElement.DeepCopyInternal());
      if(_MinElement is not null) dest.MinElement = (Hl7.Fhir.Model.UnsignedInt)_MinElement.DeepCopyInternal();
      if(_MaxElement is not null) dest.MaxElement = (Hl7.Fhir.Model.FhirString)_MaxElement.DeepCopyInternal();
      if(_Base is not null) dest.Base = (Hl7.Fhir.Model.ElementDefinition.BaseComponent)_Base.DeepCopyInternal();
      if(_ContentReferenceElement is not null) dest.ContentReferenceElement = (Hl7.Fhir.Model.FhirUri)_ContentReferenceElement.DeepCopyInternal();
      if(_Type is not null) dest.Type = new List<Hl7.Fhir.Model.ElementDefinition.TypeRefComponent>(_Type.DeepCopyInternal());
      if(_DefaultValue is not null) dest.DefaultValue = (Hl7.Fhir.Model.DataType)_DefaultValue.DeepCopyInternal();
      if(_MeaningWhenMissingElement is not null) dest.MeaningWhenMissingElement = (Hl7.Fhir.Model.Markdown)_MeaningWhenMissingElement.DeepCopyInternal();
      if(_OrderMeaningElement is not null) dest.OrderMeaningElement = (Hl7.Fhir.Model.FhirString)_OrderMeaningElement.DeepCopyInternal();
      if(_Fixed is not null) dest.Fixed = (Hl7.Fhir.Model.DataType)_Fixed.DeepCopyInternal();
      if(_Pattern is not null) dest.Pattern = (Hl7.Fhir.Model.DataType)_Pattern.DeepCopyInternal();
      if(_Example is not null) dest.Example = new List<Hl7.Fhir.Model.ElementDefinition.ExampleComponent>(_Example.DeepCopyInternal());
      if(_MinValue is not null) dest.MinValue = (Hl7.Fhir.Model.DataType)_MinValue.DeepCopyInternal();
      if(_MaxValue is not null) dest.MaxValue = (Hl7.Fhir.Model.DataType)_MaxValue.DeepCopyInternal();
      if(_MaxLengthElement is not null) dest.MaxLengthElement = (Hl7.Fhir.Model.Integer)_MaxLengthElement.DeepCopyInternal();
      if(_ConditionElement is not null) dest.ConditionElement = new List<Hl7.Fhir.Model.Id>(_ConditionElement.DeepCopyInternal());
      if(_Constraint is not null) dest.Constraint = new List<Hl7.Fhir.Model.ElementDefinition.ConstraintComponent>(_Constraint.DeepCopyInternal());
      if(_MustHaveValueElement is not null) dest.MustHaveValueElement = (Hl7.Fhir.Model.FhirBoolean)_MustHaveValueElement.DeepCopyInternal();
      if(_ValueAlternativesElement is not null) dest.ValueAlternativesElement = new List<Hl7.Fhir.Model.Canonical>(_ValueAlternativesElement.DeepCopyInternal());
      if(_MustSupportElement is not null) dest.MustSupportElement = (Hl7.Fhir.Model.FhirBoolean)_MustSupportElement.DeepCopyInternal();
      if(_IsModifierElement is not null) dest.IsModifierElement = (Hl7.Fhir.Model.FhirBoolean)_IsModifierElement.DeepCopyInternal();
      if(_IsModifierReasonElement is not null) dest.IsModifierReasonElement = (Hl7.Fhir.Model.FhirString)_IsModifierReasonElement.DeepCopyInternal();
      if(_IsSummaryElement is not null) dest.IsSummaryElement = (Hl7.Fhir.Model.FhirBoolean)_IsSummaryElement.DeepCopyInternal();
      if(_Binding is not null) dest.Binding = (Hl7.Fhir.Model.ElementDefinition.ElementDefinitionBindingComponent)_Binding.DeepCopyInternal();
      if(_Mapping is not null) dest.Mapping = new List<Hl7.Fhir.Model.ElementDefinition.MappingComponent>(_Mapping.DeepCopyInternal());
    }

    protected internal override Base DeepCopyInternal()
    {
      var instance = new ElementDefinition();
      CopyToInternal(instance);
      return instance;
    }

    public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
    {
      if(other is not ElementDefinition otherT) return false;

      if(!base.CompareChildren(otherT, comparer)) return false;
      #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
      if(!comparer.Equals(_PathElement, otherT._PathElement)) return false;
      if(!comparer.ListEquals(_RepresentationElement, otherT._RepresentationElement)) return false;
      if(!comparer.Equals(_SliceNameElement, otherT._SliceNameElement)) return false;
      if(!comparer.Equals(_SliceIsConstrainingElement, otherT._SliceIsConstrainingElement)) return false;
      if(!comparer.Equals(_LabelElement, otherT._LabelElement)) return false;
      if(!comparer.ListEquals(_Code, otherT._Code)) return false;
      if(!comparer.Equals(_Slicing, otherT._Slicing)) return false;
      if(!comparer.Equals(_ShortElement, otherT._ShortElement)) return false;
      if(!comparer.Equals(_DefinitionElement, otherT._DefinitionElement)) return false;
      if(!comparer.Equals(_CommentElement, otherT._CommentElement)) return false;
      if(!comparer.Equals(_RequirementsElement, otherT._RequirementsElement)) return false;
      if(!comparer.ListEquals(_AliasElement, otherT._AliasElement)) return false;
      if(!comparer.Equals(_MinElement, otherT._MinElement)) return false;
      if(!comparer.Equals(_MaxElement, otherT._MaxElement)) return false;
      if(!comparer.Equals(_Base, otherT._Base)) return false;
      if(!comparer.Equals(_ContentReferenceElement, otherT._ContentReferenceElement)) return false;
      if(!comparer.ListEquals(_Type, otherT._Type)) return false;
      if(!comparer.Equals(_DefaultValue, otherT._DefaultValue)) return false;
      if(!comparer.Equals(_MeaningWhenMissingElement, otherT._MeaningWhenMissingElement)) return false;
      if(!comparer.Equals(_OrderMeaningElement, otherT._OrderMeaningElement)) return false;
      if(!comparer.Equals(_Fixed, otherT._Fixed)) return false;
      if(!comparer.Equals(_Pattern, otherT._Pattern)) return false;
      if(!comparer.ListEquals(_Example, otherT._Example)) return false;
      if(!comparer.Equals(_MinValue, otherT._MinValue)) return false;
      if(!comparer.Equals(_MaxValue, otherT._MaxValue)) return false;
      if(!comparer.Equals(_MaxLengthElement, otherT._MaxLengthElement)) return false;
      if(!comparer.ListEquals(_ConditionElement, otherT._ConditionElement)) return false;
      if(!comparer.ListEquals(_Constraint, otherT._Constraint)) return false;
      if(!comparer.Equals(_MustHaveValueElement, otherT._MustHaveValueElement)) return false;
      if(!comparer.ListEquals(_ValueAlternativesElement, otherT._ValueAlternativesElement)) return false;
      if(!comparer.Equals(_MustSupportElement, otherT._MustSupportElement)) return false;
      if(!comparer.Equals(_IsModifierElement, otherT._IsModifierElement)) return false;
      if(!comparer.Equals(_IsModifierReasonElement, otherT._IsModifierReasonElement)) return false;
      if(!comparer.Equals(_IsSummaryElement, otherT._IsSummaryElement)) return false;
      if(!comparer.Equals(_Binding, otherT._Binding)) return false;
      if(!comparer.ListEquals(_Mapping, otherT._Mapping)) return false;
      #pragma warning restore CS8604 // Possible null reference argument.

      return true;
    }

    public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
    {
      switch (key)
      {
        case "path":
          if (_PathElement.InOverflow<Hl7.Fhir.Model.FhirString>())
          {
            value = Overflow["path"];
            return true;
          }
          value = _PathElement;
          return (value as Hl7.Fhir.Model.FhirString) is not null;
        case "representation":
          if (_RepresentationElement.InOverflow<List<Code<Hl7.Fhir.Model.ElementDefinition.PropertyRepresentation>>>())
          {
            value = Overflow["representation"];
            return true;
          }
          value = _RepresentationElement;
          return (value as List<Code<Hl7.Fhir.Model.ElementDefinition.PropertyRepresentation>>)?.Any() is true;
        case "sliceName":
          if (_SliceNameElement.InOverflow<Hl7.Fhir.Model.FhirString>())
          {
            value = Overflow["sliceName"];
            return true;
          }
          value = _SliceNameElement;
          return (value as Hl7.Fhir.Model.FhirString) is not null;
        case "sliceIsConstraining":
          if (_SliceIsConstrainingElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>())
          {
            value = Overflow["sliceIsConstraining"];
            return true;
          }
          value = _SliceIsConstrainingElement;
          return (value as Hl7.Fhir.Model.FhirBoolean) is not null;
        case "label":
          if (_LabelElement.InOverflow<Hl7.Fhir.Model.FhirString>())
          {
            value = Overflow["label"];
            return true;
          }
          value = _LabelElement;
          return (value as Hl7.Fhir.Model.FhirString) is not null;
        case "code":
          if (_Code.InOverflow<List<Hl7.Fhir.Model.Coding>>())
          {
            value = Overflow["code"];
            return true;
          }
          value = _Code;
          return (value as List<Hl7.Fhir.Model.Coding>)?.Any() is true;
        case "slicing":
          if (_Slicing.InOverflow<Hl7.Fhir.Model.ElementDefinition.SlicingComponent>())
          {
            value = Overflow["slicing"];
            return true;
          }
          value = _Slicing;
          return (value as Hl7.Fhir.Model.ElementDefinition.SlicingComponent) is not null;
        case "short":
          if (_ShortElement.InOverflow<Hl7.Fhir.Model.FhirString>())
          {
            value = Overflow["short"];
            return true;
          }
          value = _ShortElement;
          return (value as Hl7.Fhir.Model.FhirString) is not null;
        case "definition":
          if (_DefinitionElement.InOverflow<Hl7.Fhir.Model.Markdown>())
          {
            value = Overflow["definition"];
            return true;
          }
          value = _DefinitionElement;
          return (value as Hl7.Fhir.Model.Markdown) is not null;
        case "comment":
          if (_CommentElement.InOverflow<Hl7.Fhir.Model.Markdown>())
          {
            value = Overflow["comment"];
            return true;
          }
          value = _CommentElement;
          return (value as Hl7.Fhir.Model.Markdown) is not null;
        case "requirements":
          if (_RequirementsElement.InOverflow<Hl7.Fhir.Model.Markdown>())
          {
            value = Overflow["requirements"];
            return true;
          }
          value = _RequirementsElement;
          return (value as Hl7.Fhir.Model.Markdown) is not null;
        case "alias":
          if (_AliasElement.InOverflow<List<Hl7.Fhir.Model.FhirString>>())
          {
            value = Overflow["alias"];
            return true;
          }
          value = _AliasElement;
          return (value as List<Hl7.Fhir.Model.FhirString>)?.Any() is true;
        case "min":
          if (_MinElement.InOverflow<Hl7.Fhir.Model.UnsignedInt>())
          {
            value = Overflow["min"];
            return true;
          }
          value = _MinElement;
          return (value as Hl7.Fhir.Model.UnsignedInt) is not null;
        case "max":
          if (_MaxElement.InOverflow<Hl7.Fhir.Model.FhirString>())
          {
            value = Overflow["max"];
            return true;
          }
          value = _MaxElement;
          return (value as Hl7.Fhir.Model.FhirString) is not null;
        case "base":
          if (_Base.InOverflow<Hl7.Fhir.Model.ElementDefinition.BaseComponent>())
          {
            value = Overflow["base"];
            return true;
          }
          value = _Base;
          return (value as Hl7.Fhir.Model.ElementDefinition.BaseComponent) is not null;
        case "contentReference":
          if (_ContentReferenceElement.InOverflow<Hl7.Fhir.Model.FhirUri>())
          {
            value = Overflow["contentReference"];
            return true;
          }
          value = _ContentReferenceElement;
          return (value as Hl7.Fhir.Model.FhirUri) is not null;
        case "type":
          if (_Type.InOverflow<List<Hl7.Fhir.Model.ElementDefinition.TypeRefComponent>>())
          {
            value = Overflow["type"];
            return true;
          }
          value = _Type;
          return (value as List<Hl7.Fhir.Model.ElementDefinition.TypeRefComponent>)?.Any() is true;
        case "defaultValue":
          if (_DefaultValue.InOverflow<DynamicDataType>())
          {
            value = Overflow["defaultValue"];
            return true;
          }
          value = _DefaultValue;
          return (value as Hl7.Fhir.Model.DataType) is not null;
        case "meaningWhenMissing":
          if (_MeaningWhenMissingElement.InOverflow<Hl7.Fhir.Model.Markdown>())
          {
            value = Overflow["meaningWhenMissing"];
            return true;
          }
          value = _MeaningWhenMissingElement;
          return (value as Hl7.Fhir.Model.Markdown) is not null;
        case "orderMeaning":
          if (_OrderMeaningElement.InOverflow<Hl7.Fhir.Model.FhirString>())
          {
            value = Overflow["orderMeaning"];
            return true;
          }
          value = _OrderMeaningElement;
          return (value as Hl7.Fhir.Model.FhirString) is not null;
        case "fixed":
          if (_Fixed.InOverflow<DynamicDataType>())
          {
            value = Overflow["fixed"];
            return true;
          }
          value = _Fixed;
          return (value as Hl7.Fhir.Model.DataType) is not null;
        case "pattern":
          if (_Pattern.InOverflow<DynamicDataType>())
          {
            value = Overflow["pattern"];
            return true;
          }
          value = _Pattern;
          return (value as Hl7.Fhir.Model.DataType) is not null;
        case "example":
          if (_Example.InOverflow<List<Hl7.Fhir.Model.ElementDefinition.ExampleComponent>>())
          {
            value = Overflow["example"];
            return true;
          }
          value = _Example;
          return (value as List<Hl7.Fhir.Model.ElementDefinition.ExampleComponent>)?.Any() is true;
        case "minValue":
          if (_MinValue.InOverflow<DynamicDataType>())
          {
            value = Overflow["minValue"];
            return true;
          }
          value = _MinValue;
          return (value as Hl7.Fhir.Model.DataType) is not null;
        case "maxValue":
          if (_MaxValue.InOverflow<DynamicDataType>())
          {
            value = Overflow["maxValue"];
            return true;
          }
          value = _MaxValue;
          return (value as Hl7.Fhir.Model.DataType) is not null;
        case "maxLength":
          if (_MaxLengthElement.InOverflow<Hl7.Fhir.Model.Integer>())
          {
            value = Overflow["maxLength"];
            return true;
          }
          value = _MaxLengthElement;
          return (value as Hl7.Fhir.Model.Integer) is not null;
        case "condition":
          if (_ConditionElement.InOverflow<List<Hl7.Fhir.Model.Id>>())
          {
            value = Overflow["condition"];
            return true;
          }
          value = _ConditionElement;
          return (value as List<Hl7.Fhir.Model.Id>)?.Any() is true;
        case "constraint":
          if (_Constraint.InOverflow<List<Hl7.Fhir.Model.ElementDefinition.ConstraintComponent>>())
          {
            value = Overflow["constraint"];
            return true;
          }
          value = _Constraint;
          return (value as List<Hl7.Fhir.Model.ElementDefinition.ConstraintComponent>)?.Any() is true;
        case "mustHaveValue":
          if (_MustHaveValueElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>())
          {
            value = Overflow["mustHaveValue"];
            return true;
          }
          value = _MustHaveValueElement;
          return (value as Hl7.Fhir.Model.FhirBoolean) is not null;
        case "valueAlternatives":
          if (_ValueAlternativesElement.InOverflow<List<Hl7.Fhir.Model.Canonical>>())
          {
            value = Overflow["valueAlternatives"];
            return true;
          }
          value = _ValueAlternativesElement;
          return (value as List<Hl7.Fhir.Model.Canonical>)?.Any() is true;
        case "mustSupport":
          if (_MustSupportElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>())
          {
            value = Overflow["mustSupport"];
            return true;
          }
          value = _MustSupportElement;
          return (value as Hl7.Fhir.Model.FhirBoolean) is not null;
        case "isModifier":
          if (_IsModifierElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>())
          {
            value = Overflow["isModifier"];
            return true;
          }
          value = _IsModifierElement;
          return (value as Hl7.Fhir.Model.FhirBoolean) is not null;
        case "isModifierReason":
          if (_IsModifierReasonElement.InOverflow<Hl7.Fhir.Model.FhirString>())
          {
            value = Overflow["isModifierReason"];
            return true;
          }
          value = _IsModifierReasonElement;
          return (value as Hl7.Fhir.Model.FhirString) is not null;
        case "isSummary":
          if (_IsSummaryElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>())
          {
            value = Overflow["isSummary"];
            return true;
          }
          value = _IsSummaryElement;
          return (value as Hl7.Fhir.Model.FhirBoolean) is not null;
        case "binding":
          if (_Binding.InOverflow<Hl7.Fhir.Model.ElementDefinition.ElementDefinitionBindingComponent>())
          {
            value = Overflow["binding"];
            return true;
          }
          value = _Binding;
          return (value as Hl7.Fhir.Model.ElementDefinition.ElementDefinitionBindingComponent) is not null;
        case "mapping":
          if (_Mapping.InOverflow<List<Hl7.Fhir.Model.ElementDefinition.MappingComponent>>())
          {
            value = Overflow["mapping"];
            return true;
          }
          value = _Mapping;
          return (value as List<Hl7.Fhir.Model.ElementDefinition.MappingComponent>)?.Any() is true;
        default:
          return base.TryGetValue(key, out value);
      }

    }

    public override Base SetValue(string key, object? value)
    {
      if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
      switch (key)
      {
        case "path":
          if (value is not (Hl7.Fhir.Model.FhirString or null))
          {
            PathElement = OverflowNull<Hl7.Fhir.Model.FhirString>.INSTANCE;
            Overflow["path"] = value;
          }
          else PathElement = (Hl7.Fhir.Model.FhirString?)value!;
          return this;
        case "representation":
          if (value is not (List<Code<Hl7.Fhir.Model.ElementDefinition.PropertyRepresentation>> or null))
          {
            RepresentationElement = OverflowNull<List<Code<Hl7.Fhir.Model.ElementDefinition.PropertyRepresentation>>>.INSTANCE;
            Overflow["representation"] = value;
          }
          else RepresentationElement = (List<Code<Hl7.Fhir.Model.ElementDefinition.PropertyRepresentation>>?)value!;
          return this;
        case "sliceName":
          if (value is not (Hl7.Fhir.Model.FhirString or null))
          {
            SliceNameElement = OverflowNull<Hl7.Fhir.Model.FhirString>.INSTANCE;
            Overflow["sliceName"] = value;
          }
          else SliceNameElement = (Hl7.Fhir.Model.FhirString?)value;
          return this;
        case "sliceIsConstraining":
          if (value is not (Hl7.Fhir.Model.FhirBoolean or null))
          {
            SliceIsConstrainingElement = OverflowNull<Hl7.Fhir.Model.FhirBoolean>.INSTANCE;
            Overflow["sliceIsConstraining"] = value;
          }
          else SliceIsConstrainingElement = (Hl7.Fhir.Model.FhirBoolean?)value;
          return this;
        case "label":
          if (value is not (Hl7.Fhir.Model.FhirString or null))
          {
            LabelElement = OverflowNull<Hl7.Fhir.Model.FhirString>.INSTANCE;
            Overflow["label"] = value;
          }
          else LabelElement = (Hl7.Fhir.Model.FhirString?)value;
          return this;
        case "code":
          if (value is not (List<Hl7.Fhir.Model.Coding> or null))
          {
            Code = OverflowNull<List<Hl7.Fhir.Model.Coding>>.INSTANCE;
            Overflow["code"] = value;
          }
          else Code = (List<Hl7.Fhir.Model.Coding>?)value!;
          return this;
        case "slicing":
          if (value is not (Hl7.Fhir.Model.ElementDefinition.SlicingComponent or null))
          {
            Slicing = OverflowNull<Hl7.Fhir.Model.ElementDefinition.SlicingComponent>.INSTANCE;
            Overflow["slicing"] = value;
          }
          else Slicing = (Hl7.Fhir.Model.ElementDefinition.SlicingComponent?)value;
          return this;
        case "short":
          if (value is not (Hl7.Fhir.Model.FhirString or null))
          {
            ShortElement = OverflowNull<Hl7.Fhir.Model.FhirString>.INSTANCE;
            Overflow["short"] = value;
          }
          else ShortElement = (Hl7.Fhir.Model.FhirString?)value;
          return this;
        case "definition":
          if (value is not (Hl7.Fhir.Model.Markdown or null))
          {
            DefinitionElement = OverflowNull<Hl7.Fhir.Model.Markdown>.INSTANCE;
            Overflow["definition"] = value;
          }
          else DefinitionElement = (Hl7.Fhir.Model.Markdown?)value;
          return this;
        case "comment":
          if (value is not (Hl7.Fhir.Model.Markdown or null))
          {
            CommentElement = OverflowNull<Hl7.Fhir.Model.Markdown>.INSTANCE;
            Overflow["comment"] = value;
          }
          else CommentElement = (Hl7.Fhir.Model.Markdown?)value;
          return this;
        case "requirements":
          if (value is not (Hl7.Fhir.Model.Markdown or null))
          {
            RequirementsElement = OverflowNull<Hl7.Fhir.Model.Markdown>.INSTANCE;
            Overflow["requirements"] = value;
          }
          else RequirementsElement = (Hl7.Fhir.Model.Markdown?)value;
          return this;
        case "alias":
          if (value is not (List<Hl7.Fhir.Model.FhirString> or null))
          {
            AliasElement = OverflowNull<List<Hl7.Fhir.Model.FhirString>>.INSTANCE;
            Overflow["alias"] = value;
          }
          else AliasElement = (List<Hl7.Fhir.Model.FhirString>?)value!;
          return this;
        case "min":
          if (value is not (Hl7.Fhir.Model.UnsignedInt or null))
          {
            MinElement = OverflowNull<Hl7.Fhir.Model.UnsignedInt>.INSTANCE;
            Overflow["min"] = value;
          }
          else MinElement = (Hl7.Fhir.Model.UnsignedInt?)value;
          return this;
        case "max":
          if (value is not (Hl7.Fhir.Model.FhirString or null))
          {
            MaxElement = OverflowNull<Hl7.Fhir.Model.FhirString>.INSTANCE;
            Overflow["max"] = value;
          }
          else MaxElement = (Hl7.Fhir.Model.FhirString?)value;
          return this;
        case "base":
          if (value is not (Hl7.Fhir.Model.ElementDefinition.BaseComponent or null))
          {
            Base = OverflowNull<Hl7.Fhir.Model.ElementDefinition.BaseComponent>.INSTANCE;
            Overflow["base"] = value;
          }
          else Base = (Hl7.Fhir.Model.ElementDefinition.BaseComponent?)value;
          return this;
        case "contentReference":
          if (value is not (Hl7.Fhir.Model.FhirUri or null))
          {
            ContentReferenceElement = OverflowNull<Hl7.Fhir.Model.FhirUri>.INSTANCE;
            Overflow["contentReference"] = value;
          }
          else ContentReferenceElement = (Hl7.Fhir.Model.FhirUri?)value;
          return this;
        case "type":
          if (value is not (List<Hl7.Fhir.Model.ElementDefinition.TypeRefComponent> or null))
          {
            Type = OverflowNull<List<Hl7.Fhir.Model.ElementDefinition.TypeRefComponent>>.INSTANCE;
            Overflow["type"] = value;
          }
          else Type = (List<Hl7.Fhir.Model.ElementDefinition.TypeRefComponent>?)value!;
          return this;
        case "defaultValue":
          if (value is not (Hl7.Fhir.Model.DataType or null))
          {
            DefaultValue = OverflowNull<DynamicDataType>.INSTANCE;
            Overflow["defaultValue"] = value;
          }
          else DefaultValue = (Hl7.Fhir.Model.DataType?)value;
          return this;
        case "meaningWhenMissing":
          if (value is not (Hl7.Fhir.Model.Markdown or null))
          {
            MeaningWhenMissingElement = OverflowNull<Hl7.Fhir.Model.Markdown>.INSTANCE;
            Overflow["meaningWhenMissing"] = value;
          }
          else MeaningWhenMissingElement = (Hl7.Fhir.Model.Markdown?)value;
          return this;
        case "orderMeaning":
          if (value is not (Hl7.Fhir.Model.FhirString or null))
          {
            OrderMeaningElement = OverflowNull<Hl7.Fhir.Model.FhirString>.INSTANCE;
            Overflow["orderMeaning"] = value;
          }
          else OrderMeaningElement = (Hl7.Fhir.Model.FhirString?)value;
          return this;
        case "fixed":
          if (value is not (Hl7.Fhir.Model.DataType or null))
          {
            Fixed = OverflowNull<DynamicDataType>.INSTANCE;
            Overflow["fixed"] = value;
          }
          else Fixed = (Hl7.Fhir.Model.DataType?)value;
          return this;
        case "pattern":
          if (value is not (Hl7.Fhir.Model.DataType or null))
          {
            Pattern = OverflowNull<DynamicDataType>.INSTANCE;
            Overflow["pattern"] = value;
          }
          else Pattern = (Hl7.Fhir.Model.DataType?)value;
          return this;
        case "example":
          if (value is not (List<Hl7.Fhir.Model.ElementDefinition.ExampleComponent> or null))
          {
            Example = OverflowNull<List<Hl7.Fhir.Model.ElementDefinition.ExampleComponent>>.INSTANCE;
            Overflow["example"] = value;
          }
          else Example = (List<Hl7.Fhir.Model.ElementDefinition.ExampleComponent>?)value!;
          return this;
        case "minValue":
          if (value is not (Hl7.Fhir.Model.DataType or null))
          {
            MinValue = OverflowNull<DynamicDataType>.INSTANCE;
            Overflow["minValue"] = value;
          }
          else MinValue = (Hl7.Fhir.Model.DataType?)value;
          return this;
        case "maxValue":
          if (value is not (Hl7.Fhir.Model.DataType or null))
          {
            MaxValue = OverflowNull<DynamicDataType>.INSTANCE;
            Overflow["maxValue"] = value;
          }
          else MaxValue = (Hl7.Fhir.Model.DataType?)value;
          return this;
        case "maxLength":
          if (value is not (Hl7.Fhir.Model.Integer or null))
          {
            MaxLengthElement = OverflowNull<Hl7.Fhir.Model.Integer>.INSTANCE;
            Overflow["maxLength"] = value;
          }
          else MaxLengthElement = (Hl7.Fhir.Model.Integer?)value;
          return this;
        case "condition":
          if (value is not (List<Hl7.Fhir.Model.Id> or null))
          {
            ConditionElement = OverflowNull<List<Hl7.Fhir.Model.Id>>.INSTANCE;
            Overflow["condition"] = value;
          }
          else ConditionElement = (List<Hl7.Fhir.Model.Id>?)value!;
          return this;
        case "constraint":
          if (value is not (List<Hl7.Fhir.Model.ElementDefinition.ConstraintComponent> or null))
          {
            Constraint = OverflowNull<List<Hl7.Fhir.Model.ElementDefinition.ConstraintComponent>>.INSTANCE;
            Overflow["constraint"] = value;
          }
          else Constraint = (List<Hl7.Fhir.Model.ElementDefinition.ConstraintComponent>?)value!;
          return this;
        case "mustHaveValue":
          if (value is not (Hl7.Fhir.Model.FhirBoolean or null))
          {
            MustHaveValueElement = OverflowNull<Hl7.Fhir.Model.FhirBoolean>.INSTANCE;
            Overflow["mustHaveValue"] = value;
          }
          else MustHaveValueElement = (Hl7.Fhir.Model.FhirBoolean?)value;
          return this;
        case "valueAlternatives":
          if (value is not (List<Hl7.Fhir.Model.Canonical> or null))
          {
            ValueAlternativesElement = OverflowNull<List<Hl7.Fhir.Model.Canonical>>.INSTANCE;
            Overflow["valueAlternatives"] = value;
          }
          else ValueAlternativesElement = (List<Hl7.Fhir.Model.Canonical>?)value!;
          return this;
        case "mustSupport":
          if (value is not (Hl7.Fhir.Model.FhirBoolean or null))
          {
            MustSupportElement = OverflowNull<Hl7.Fhir.Model.FhirBoolean>.INSTANCE;
            Overflow["mustSupport"] = value;
          }
          else MustSupportElement = (Hl7.Fhir.Model.FhirBoolean?)value;
          return this;
        case "isModifier":
          if (value is not (Hl7.Fhir.Model.FhirBoolean or null))
          {
            IsModifierElement = OverflowNull<Hl7.Fhir.Model.FhirBoolean>.INSTANCE;
            Overflow["isModifier"] = value;
          }
          else IsModifierElement = (Hl7.Fhir.Model.FhirBoolean?)value;
          return this;
        case "isModifierReason":
          if (value is not (Hl7.Fhir.Model.FhirString or null))
          {
            IsModifierReasonElement = OverflowNull<Hl7.Fhir.Model.FhirString>.INSTANCE;
            Overflow["isModifierReason"] = value;
          }
          else IsModifierReasonElement = (Hl7.Fhir.Model.FhirString?)value;
          return this;
        case "isSummary":
          if (value is not (Hl7.Fhir.Model.FhirBoolean or null))
          {
            IsSummaryElement = OverflowNull<Hl7.Fhir.Model.FhirBoolean>.INSTANCE;
            Overflow["isSummary"] = value;
          }
          else IsSummaryElement = (Hl7.Fhir.Model.FhirBoolean?)value;
          return this;
        case "binding":
          if (value is not (Hl7.Fhir.Model.ElementDefinition.ElementDefinitionBindingComponent or null))
          {
            Binding = OverflowNull<Hl7.Fhir.Model.ElementDefinition.ElementDefinitionBindingComponent>.INSTANCE;
            Overflow["binding"] = value;
          }
          else Binding = (Hl7.Fhir.Model.ElementDefinition.ElementDefinitionBindingComponent?)value;
          return this;
        case "mapping":
          if (value is not (List<Hl7.Fhir.Model.ElementDefinition.MappingComponent> or null))
          {
            Mapping = OverflowNull<List<Hl7.Fhir.Model.ElementDefinition.MappingComponent>>.INSTANCE;
            Overflow["mapping"] = value;
          }
          else Mapping = (List<Hl7.Fhir.Model.ElementDefinition.MappingComponent>?)value!;
          return this;
        default:
          return base.SetValue(key, value);
      }

    }

    public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
    {
      foreach (var kvp in base.EnumerateElements()) yield return kvp;
      if (_PathElement is not null && !_PathElement.InOverflow<Hl7.Fhir.Model.FhirString>()) yield return new KeyValuePair<string,object>("path",_PathElement);
      if (_RepresentationElement?.Any() is true && !_RepresentationElement.InOverflow<List<Code<Hl7.Fhir.Model.ElementDefinition.PropertyRepresentation>>>()) yield return new KeyValuePair<string,object>("representation",_RepresentationElement);
      if (_SliceNameElement is not null && !_SliceNameElement.InOverflow<Hl7.Fhir.Model.FhirString>()) yield return new KeyValuePair<string,object>("sliceName",_SliceNameElement);
      if (_SliceIsConstrainingElement is not null && !_SliceIsConstrainingElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>()) yield return new KeyValuePair<string,object>("sliceIsConstraining",_SliceIsConstrainingElement);
      if (_LabelElement is not null && !_LabelElement.InOverflow<Hl7.Fhir.Model.FhirString>()) yield return new KeyValuePair<string,object>("label",_LabelElement);
      if (_Code?.Any() is true && !_Code.InOverflow<List<Hl7.Fhir.Model.Coding>>()) yield return new KeyValuePair<string,object>("code",_Code);
      if (_Slicing is not null && !_Slicing.InOverflow<Hl7.Fhir.Model.ElementDefinition.SlicingComponent>()) yield return new KeyValuePair<string,object>("slicing",_Slicing);
      if (_ShortElement is not null && !_ShortElement.InOverflow<Hl7.Fhir.Model.FhirString>()) yield return new KeyValuePair<string,object>("short",_ShortElement);
      if (_DefinitionElement is not null && !_DefinitionElement.InOverflow<Hl7.Fhir.Model.Markdown>()) yield return new KeyValuePair<string,object>("definition",_DefinitionElement);
      if (_CommentElement is not null && !_CommentElement.InOverflow<Hl7.Fhir.Model.Markdown>()) yield return new KeyValuePair<string,object>("comment",_CommentElement);
      if (_RequirementsElement is not null && !_RequirementsElement.InOverflow<Hl7.Fhir.Model.Markdown>()) yield return new KeyValuePair<string,object>("requirements",_RequirementsElement);
      if (_AliasElement?.Any() is true && !_AliasElement.InOverflow<List<Hl7.Fhir.Model.FhirString>>()) yield return new KeyValuePair<string,object>("alias",_AliasElement);
      if (_MinElement is not null && !_MinElement.InOverflow<Hl7.Fhir.Model.UnsignedInt>()) yield return new KeyValuePair<string,object>("min",_MinElement);
      if (_MaxElement is not null && !_MaxElement.InOverflow<Hl7.Fhir.Model.FhirString>()) yield return new KeyValuePair<string,object>("max",_MaxElement);
      if (_Base is not null && !_Base.InOverflow<Hl7.Fhir.Model.ElementDefinition.BaseComponent>()) yield return new KeyValuePair<string,object>("base",_Base);
      if (_ContentReferenceElement is not null && !_ContentReferenceElement.InOverflow<Hl7.Fhir.Model.FhirUri>()) yield return new KeyValuePair<string,object>("contentReference",_ContentReferenceElement);
      if (_Type?.Any() is true && !_Type.InOverflow<List<Hl7.Fhir.Model.ElementDefinition.TypeRefComponent>>()) yield return new KeyValuePair<string,object>("type",_Type);
      if (_DefaultValue is not null && !_DefaultValue.InOverflow<DynamicDataType>()) yield return new KeyValuePair<string,object>("defaultValue",_DefaultValue);
      if (_MeaningWhenMissingElement is not null && !_MeaningWhenMissingElement.InOverflow<Hl7.Fhir.Model.Markdown>()) yield return new KeyValuePair<string,object>("meaningWhenMissing",_MeaningWhenMissingElement);
      if (_OrderMeaningElement is not null && !_OrderMeaningElement.InOverflow<Hl7.Fhir.Model.FhirString>()) yield return new KeyValuePair<string,object>("orderMeaning",_OrderMeaningElement);
      if (_Fixed is not null && !_Fixed.InOverflow<DynamicDataType>()) yield return new KeyValuePair<string,object>("fixed",_Fixed);
      if (_Pattern is not null && !_Pattern.InOverflow<DynamicDataType>()) yield return new KeyValuePair<string,object>("pattern",_Pattern);
      if (_Example?.Any() is true && !_Example.InOverflow<List<Hl7.Fhir.Model.ElementDefinition.ExampleComponent>>()) yield return new KeyValuePair<string,object>("example",_Example);
      if (_MinValue is not null && !_MinValue.InOverflow<DynamicDataType>()) yield return new KeyValuePair<string,object>("minValue",_MinValue);
      if (_MaxValue is not null && !_MaxValue.InOverflow<DynamicDataType>()) yield return new KeyValuePair<string,object>("maxValue",_MaxValue);
      if (_MaxLengthElement is not null && !_MaxLengthElement.InOverflow<Hl7.Fhir.Model.Integer>()) yield return new KeyValuePair<string,object>("maxLength",_MaxLengthElement);
      if (_ConditionElement?.Any() is true && !_ConditionElement.InOverflow<List<Hl7.Fhir.Model.Id>>()) yield return new KeyValuePair<string,object>("condition",_ConditionElement);
      if (_Constraint?.Any() is true && !_Constraint.InOverflow<List<Hl7.Fhir.Model.ElementDefinition.ConstraintComponent>>()) yield return new KeyValuePair<string,object>("constraint",_Constraint);
      if (_MustHaveValueElement is not null && !_MustHaveValueElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>()) yield return new KeyValuePair<string,object>("mustHaveValue",_MustHaveValueElement);
      if (_ValueAlternativesElement?.Any() is true && !_ValueAlternativesElement.InOverflow<List<Hl7.Fhir.Model.Canonical>>()) yield return new KeyValuePair<string,object>("valueAlternatives",_ValueAlternativesElement);
      if (_MustSupportElement is not null && !_MustSupportElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>()) yield return new KeyValuePair<string,object>("mustSupport",_MustSupportElement);
      if (_IsModifierElement is not null && !_IsModifierElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>()) yield return new KeyValuePair<string,object>("isModifier",_IsModifierElement);
      if (_IsModifierReasonElement is not null && !_IsModifierReasonElement.InOverflow<Hl7.Fhir.Model.FhirString>()) yield return new KeyValuePair<string,object>("isModifierReason",_IsModifierReasonElement);
      if (_IsSummaryElement is not null && !_IsSummaryElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>()) yield return new KeyValuePair<string,object>("isSummary",_IsSummaryElement);
      if (_Binding is not null && !_Binding.InOverflow<Hl7.Fhir.Model.ElementDefinition.ElementDefinitionBindingComponent>()) yield return new KeyValuePair<string,object>("binding",_Binding);
      if (_Mapping?.Any() is true && !_Mapping.InOverflow<List<Hl7.Fhir.Model.ElementDefinition.MappingComponent>>()) yield return new KeyValuePair<string,object>("mapping",_Mapping);
    }

  }

}

// end of file
