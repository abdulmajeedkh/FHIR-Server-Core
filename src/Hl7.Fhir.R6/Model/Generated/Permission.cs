// <auto-generated/>
// Contents of: hl7.fhir.r6.expansions@6.0.0-ballot3, hl7.fhir.r6.core@6.0.0-ballot3

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using Hl7.Fhir.Introspection;
using Hl7.Fhir.Serialization;
using Hl7.Fhir.Specification;
using Hl7.Fhir.Utility;
using Hl7.Fhir.Validation;
using System.Diagnostics.CodeAnalysis;
using SystemPrimitive = Hl7.Fhir.ElementModel.Types;

#nullable enable

/*
  Copyright (c) 2011+, HL7, Inc.
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
*/

namespace Hl7.Fhir.Model
{
  /// <summary>
  /// Access Rules
  /// </summary>
  /// <remarks>
  /// Permission resource holds access rules for a given data and access request context.
  /// </remarks>
  [Serializable]
  [DataContract]
  [FhirType("Permission","http://hl7.org/fhir/StructureDefinition/Permission")]
  public partial class Permission : Hl7.Fhir.Model.DomainResource, IIdentifiable<List<Identifier>>
  {
    /// <summary>
    /// FHIR Type Name
    /// </summary>
    public override string TypeName => "Permission";

    /// <summary>
    /// Codes identifying the lifecycle stage of a product.
    /// (url: http://hl7.org/fhir/ValueSet/permission-status)
    /// (system: http://hl7.org/fhir/permission-status)
    /// </summary>
    [FhirEnumeration("PermissionStatus", "http://hl7.org/fhir/ValueSet/permission-status", "http://hl7.org/fhir/permission-status")]
    public enum PermissionStatus
    {
      /// <summary>
      /// Permission is given.
      /// (system: http://hl7.org/fhir/permission-status)
      /// </summary>
      [EnumLiteral("active"), Description("Active")]
      Active,
      /// <summary>
      /// Permission was entered in error and is not active.
      /// (system: http://hl7.org/fhir/permission-status)
      /// </summary>
      [EnumLiteral("entered-in-error"), Description("Entered in Error")]
      EnteredInError,
      /// <summary>
      /// Permission is being defined.
      /// (system: http://hl7.org/fhir/permission-status)
      /// </summary>
      [EnumLiteral("draft"), Description("Draft")]
      Draft,
      /// <summary>
      /// Permission not granted.
      /// (system: http://hl7.org/fhir/permission-status)
      /// </summary>
      [EnumLiteral("rejected"), Description("Rejected")]
      Rejected,
    }

    /// <summary>
    /// Codes identifying rule combining algorithm.
    /// (url: http://hl7.org/fhir/ValueSet/permission-rule-combining)
    /// (system: http://hl7.org/fhir/permission-rule-combining)
    /// </summary>
    [FhirEnumeration("PermissionRuleCombining", "http://hl7.org/fhir/ValueSet/permission-rule-combining", "http://hl7.org/fhir/permission-rule-combining")]
    public enum PermissionRuleCombining
    {
      /// <summary>
      /// The deny overrides combining algorithm is intended for those cases where a deny decision should have priority over a permit decision.
      /// (system: http://hl7.org/fhir/permission-rule-combining)
      /// </summary>
      [EnumLiteral("deny-overrides"), Description("Deny-overrides")]
      DenyOverrides,
      /// <summary>
      /// The permit overrides combining algorithm is intended for those cases where a permit decision should have priority over a deny decision.
      /// (system: http://hl7.org/fhir/permission-rule-combining)
      /// </summary>
      [EnumLiteral("permit-overrides"), Description("Permit-overrides")]
      PermitOverrides,
      /// <summary>
      /// The behavior of this algorithm is identical to that of the “Deny-overrides” rule-combining algorithm with one exception.  The order in which the collection of rules is evaluated SHALL match the order as listed in the permission.
      /// (system: http://hl7.org/fhir/permission-rule-combining)
      /// </summary>
      [EnumLiteral("ordered-deny-overrides"), Description("Ordered-deny-overrides")]
      OrderedDenyOverrides,
      /// <summary>
      /// The behavior of this algorithm is identical to that of the “Permit-overrides” rule-combining algorithm with one exception.  The order in which the collection of rules is evaluated SHALL match the order as listed in the permission.
      /// (system: http://hl7.org/fhir/permission-rule-combining)
      /// </summary>
      [EnumLiteral("ordered-permit-overrides"), Description("Ordered-permit-overrides")]
      OrderedPermitOverrides,
      /// <summary>
      /// The “Deny-unless-permit” combining algorithm is intended for those cases where a permit decision should have priority over a deny decision, and an “Indeterminate” or “NotApplicable” must never be the result. It is particularly useful at the top level in a policy structure to ensure that a PDP will always return a definite “Permit” or “Deny” result.
      /// (system: http://hl7.org/fhir/permission-rule-combining)
      /// </summary>
      [EnumLiteral("deny-unless-permit"), Description("Deny-unless-permit")]
      DenyUnlessPermit,
      /// <summary>
      /// The “Permit-unless-deny” combining algorithm is intended for those cases where a deny decision should have priority over a permit decision, and an “Indeterminate” or “NotApplicable” must never be the result. It is particularly useful at the top level in a policy structure to ensure that a PDP will always return a definite “Permit” or “Deny” result. This algorithm has the following behavior.
      /// (system: http://hl7.org/fhir/permission-rule-combining)
      /// </summary>
      [EnumLiteral("permit-unless-deny"), Description("Permit-unless-deny")]
      PermitUnlessDeny,
    }

    /// <summary>
    /// The asserted justification for using the data
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Permission.justification", IsBackboneType=true)]
    public partial class JustificationComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "Permission.justification";

      /// <summary>
      /// The regulatory grounds upon which this Permission builds.
      /// </summary>
      [FhirElement("basis", InSummary=true, Order=40)]
      [Binding("ConsentRegulatoryBasis")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.CodeableConcept> Basis
      {
        get
        {
          if(_Basis.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.CodeableConcept>), Overflow["basis"]);
          return _Basis ??= [];
        }

        set
        {
          if (_Basis.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>())
            Overflow.Remove("basis");
          _Basis = value;
          OnPropertyChanged("Basis");
        }

      }

      private List<Hl7.Fhir.Model.CodeableConcept>? _Basis;

      /// <summary>
      /// Justifing rational.
      /// </summary>
      [FhirElement("evidence", InSummary=true, Order=50)]
      [CLSCompliant(false)]
      [References("Resource")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.ResourceReference> Evidence
      {
        get
        {
          if(_Evidence.InOverflow<List<Hl7.Fhir.Model.ResourceReference>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.ResourceReference>), Overflow["evidence"]);
          return _Evidence ??= [];
        }

        set
        {
          if (_Evidence.InOverflow<List<Hl7.Fhir.Model.ResourceReference>>())
            Overflow.Remove("evidence");
          _Evidence = value;
          OnPropertyChanged("Evidence");
        }

      }

      private List<Hl7.Fhir.Model.ResourceReference>? _Evidence;

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not JustificationComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_Basis is not null) dest.Basis = new List<Hl7.Fhir.Model.CodeableConcept>(_Basis.DeepCopyInternal());
        if(_Evidence is not null) dest.Evidence = new List<Hl7.Fhir.Model.ResourceReference>(_Evidence.DeepCopyInternal());
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new JustificationComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not JustificationComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.ListEquals(_Basis, otherT._Basis)) return false;
        if(!comparer.ListEquals(_Evidence, otherT._Evidence)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "basis":
            if (_Basis.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>())
            {
              value = Overflow["basis"];
              return true;
            }
            value = _Basis;
            return (value as List<Hl7.Fhir.Model.CodeableConcept>)?.Any() is true;
          case "evidence":
            if (_Evidence.InOverflow<List<Hl7.Fhir.Model.ResourceReference>>())
            {
              value = Overflow["evidence"];
              return true;
            }
            value = _Evidence;
            return (value as List<Hl7.Fhir.Model.ResourceReference>)?.Any() is true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "basis":
            if (value is not (List<Hl7.Fhir.Model.CodeableConcept> or null))
            {
              Basis = OverflowNull<List<Hl7.Fhir.Model.CodeableConcept>>.INSTANCE;
              Overflow["basis"] = value;
            }
            else Basis = (List<Hl7.Fhir.Model.CodeableConcept>?)value!;
            return this;
          case "evidence":
            if (value is not (List<Hl7.Fhir.Model.ResourceReference> or null))
            {
              Evidence = OverflowNull<List<Hl7.Fhir.Model.ResourceReference>>.INSTANCE;
              Overflow["evidence"] = value;
            }
            else Evidence = (List<Hl7.Fhir.Model.ResourceReference>?)value!;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_Basis?.Any() is true && !_Basis.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>()) yield return new KeyValuePair<string,object>("basis",_Basis);
        if (_Evidence?.Any() is true && !_Evidence.InOverflow<List<Hl7.Fhir.Model.ResourceReference>>()) yield return new KeyValuePair<string,object>("evidence",_Evidence);
      }

    }

    /// <summary>
    /// Constraints to the Permission
    /// </summary>
    /// <remarks>
    /// A set of rules.
    /// Each `.rule` is evaluated within the combining rule identified in the `.combining` element.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("Permission.rule", IsBackboneType=true)]
    public partial class RuleComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "Permission.rule";

      /// <summary>
      /// Reference to a Permission.
      /// </summary>
      [FhirElement("import", InSummary=true, Order=40)]
      [CLSCompliant(false)]
      [References("Permission")]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference? Import
      {
        get
        {
          if(_Import.InOverflow<Hl7.Fhir.Model.ResourceReference>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.ResourceReference), Overflow["import"]);
          return _Import;
        }

        set
        {
          if (_Import.InOverflow<Hl7.Fhir.Model.ResourceReference>())
            Overflow.Remove("import");
          _Import = value;
          OnPropertyChanged("Import");
        }

      }

      private Hl7.Fhir.Model.ResourceReference? _Import;

      /// <summary>
      /// deny | permit.
      /// </summary>
      [FhirElement("type", InSummary=true, IsModifier=true, Order=50)]
      [Binding("PermissionProvisionType")]
      [DataMember]
      public Code<Hl7.Fhir.Model.ConsentProvisionType>? TypeElement
      {
        get
        {
          if(_TypeElement.InOverflow<Code<Hl7.Fhir.Model.ConsentProvisionType>>())
            throw CodedValidationException.FromTypes(typeof(Code<Hl7.Fhir.Model.ConsentProvisionType>), Overflow["type"]);
          return _TypeElement;
        }

        set
        {
          if (_TypeElement.InOverflow<Code<Hl7.Fhir.Model.ConsentProvisionType>>())
            Overflow.Remove("type");
          _TypeElement = value;
          OnPropertyChanged("TypeElement");
        }

      }

      private Code<Hl7.Fhir.Model.ConsentProvisionType>? _TypeElement;

      /// <summary>
      /// deny | permit
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public Hl7.Fhir.Model.ConsentProvisionType? Type
      {
        get => TypeElement?.Value;
        set
        {
          TypeElement = value is null ? null : new Code<Hl7.Fhir.Model.ConsentProvisionType>(value);
          OnPropertyChanged("Type");
        }
      }

      /// <summary>
      /// The selection criteria to identify data that is within scope of this provision.
      /// </summary>
      [FhirElement("data", InSummary=true, Order=60)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.Permission.DataComponent> Data
      {
        get
        {
          if(_Data.InOverflow<List<Hl7.Fhir.Model.Permission.DataComponent>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.Permission.DataComponent>), Overflow["data"]);
          return _Data ??= [];
        }

        set
        {
          if (_Data.InOverflow<List<Hl7.Fhir.Model.Permission.DataComponent>>())
            Overflow.Remove("data");
          _Data = value;
          OnPropertyChanged("Data");
        }

      }

      private List<Hl7.Fhir.Model.Permission.DataComponent>? _Data;

      /// <summary>
      /// A description or definition of which activities are allowed to be done on the data.
      /// </summary>
      [FhirElement("activity", InSummary=true, Order=70)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.Permission.ActivityComponent> Activity
      {
        get
        {
          if(_Activity.InOverflow<List<Hl7.Fhir.Model.Permission.ActivityComponent>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.Permission.ActivityComponent>), Overflow["activity"]);
          return _Activity ??= [];
        }

        set
        {
          if (_Activity.InOverflow<List<Hl7.Fhir.Model.Permission.ActivityComponent>>())
            Overflow.Remove("activity");
          _Activity = value;
          OnPropertyChanged("Activity");
        }

      }

      private List<Hl7.Fhir.Model.Permission.ActivityComponent>? _Activity;

      /// <summary>
      /// What limits apply to the use of the data.
      /// </summary>
      [FhirElement("limit", Order=80)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.Permission.LimitComponent> Limit
      {
        get
        {
          if(_Limit.InOverflow<List<Hl7.Fhir.Model.Permission.LimitComponent>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.Permission.LimitComponent>), Overflow["limit"]);
          return _Limit ??= [];
        }

        set
        {
          if (_Limit.InOverflow<List<Hl7.Fhir.Model.Permission.LimitComponent>>())
            Overflow.Remove("limit");
          _Limit = value;
          OnPropertyChanged("Limit");
        }

      }

      private List<Hl7.Fhir.Model.Permission.LimitComponent>? _Limit;

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not RuleComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_Import is not null) dest.Import = (Hl7.Fhir.Model.ResourceReference)_Import.DeepCopyInternal();
        if(_TypeElement is not null) dest.TypeElement = (Code<Hl7.Fhir.Model.ConsentProvisionType>)_TypeElement.DeepCopyInternal();
        if(_Data is not null) dest.Data = new List<Hl7.Fhir.Model.Permission.DataComponent>(_Data.DeepCopyInternal());
        if(_Activity is not null) dest.Activity = new List<Hl7.Fhir.Model.Permission.ActivityComponent>(_Activity.DeepCopyInternal());
        if(_Limit is not null) dest.Limit = new List<Hl7.Fhir.Model.Permission.LimitComponent>(_Limit.DeepCopyInternal());
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new RuleComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not RuleComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_Import, otherT._Import)) return false;
        if(!comparer.Equals(_TypeElement, otherT._TypeElement)) return false;
        if(!comparer.ListEquals(_Data, otherT._Data)) return false;
        if(!comparer.ListEquals(_Activity, otherT._Activity)) return false;
        if(!comparer.ListEquals(_Limit, otherT._Limit)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "import":
            if (_Import.InOverflow<Hl7.Fhir.Model.ResourceReference>())
            {
              value = Overflow["import"];
              return true;
            }
            value = _Import;
            return (value as Hl7.Fhir.Model.ResourceReference) is not null;
          case "type":
            if (_TypeElement.InOverflow<Code<Hl7.Fhir.Model.ConsentProvisionType>>())
            {
              value = Overflow["type"];
              return true;
            }
            value = _TypeElement;
            return (value as Code<Hl7.Fhir.Model.ConsentProvisionType>) is not null;
          case "data":
            if (_Data.InOverflow<List<Hl7.Fhir.Model.Permission.DataComponent>>())
            {
              value = Overflow["data"];
              return true;
            }
            value = _Data;
            return (value as List<Hl7.Fhir.Model.Permission.DataComponent>)?.Any() is true;
          case "activity":
            if (_Activity.InOverflow<List<Hl7.Fhir.Model.Permission.ActivityComponent>>())
            {
              value = Overflow["activity"];
              return true;
            }
            value = _Activity;
            return (value as List<Hl7.Fhir.Model.Permission.ActivityComponent>)?.Any() is true;
          case "limit":
            if (_Limit.InOverflow<List<Hl7.Fhir.Model.Permission.LimitComponent>>())
            {
              value = Overflow["limit"];
              return true;
            }
            value = _Limit;
            return (value as List<Hl7.Fhir.Model.Permission.LimitComponent>)?.Any() is true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "import":
            if (value is not (Hl7.Fhir.Model.ResourceReference or null))
            {
              Import = OverflowNull<Hl7.Fhir.Model.ResourceReference>.INSTANCE;
              Overflow["import"] = value;
            }
            else Import = (Hl7.Fhir.Model.ResourceReference?)value;
            return this;
          case "type":
            if (value is not (Code<Hl7.Fhir.Model.ConsentProvisionType> or null))
            {
              TypeElement = OverflowNull<Code<Hl7.Fhir.Model.ConsentProvisionType>>.INSTANCE;
              Overflow["type"] = value;
            }
            else TypeElement = (Code<Hl7.Fhir.Model.ConsentProvisionType>?)value;
            return this;
          case "data":
            if (value is not (List<Hl7.Fhir.Model.Permission.DataComponent> or null))
            {
              Data = OverflowNull<List<Hl7.Fhir.Model.Permission.DataComponent>>.INSTANCE;
              Overflow["data"] = value;
            }
            else Data = (List<Hl7.Fhir.Model.Permission.DataComponent>?)value!;
            return this;
          case "activity":
            if (value is not (List<Hl7.Fhir.Model.Permission.ActivityComponent> or null))
            {
              Activity = OverflowNull<List<Hl7.Fhir.Model.Permission.ActivityComponent>>.INSTANCE;
              Overflow["activity"] = value;
            }
            else Activity = (List<Hl7.Fhir.Model.Permission.ActivityComponent>?)value!;
            return this;
          case "limit":
            if (value is not (List<Hl7.Fhir.Model.Permission.LimitComponent> or null))
            {
              Limit = OverflowNull<List<Hl7.Fhir.Model.Permission.LimitComponent>>.INSTANCE;
              Overflow["limit"] = value;
            }
            else Limit = (List<Hl7.Fhir.Model.Permission.LimitComponent>?)value!;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_Import is not null && !_Import.InOverflow<Hl7.Fhir.Model.ResourceReference>()) yield return new KeyValuePair<string,object>("import",_Import);
        if (_TypeElement is not null && !_TypeElement.InOverflow<Code<Hl7.Fhir.Model.ConsentProvisionType>>()) yield return new KeyValuePair<string,object>("type",_TypeElement);
        if (_Data?.Any() is true && !_Data.InOverflow<List<Hl7.Fhir.Model.Permission.DataComponent>>()) yield return new KeyValuePair<string,object>("data",_Data);
        if (_Activity?.Any() is true && !_Activity.InOverflow<List<Hl7.Fhir.Model.Permission.ActivityComponent>>()) yield return new KeyValuePair<string,object>("activity",_Activity);
        if (_Limit?.Any() is true && !_Limit.InOverflow<List<Hl7.Fhir.Model.Permission.LimitComponent>>()) yield return new KeyValuePair<string,object>("limit",_Limit);
      }

    }

    /// <summary>
    /// The selection criteria to identify data that is within scope of this provision
    /// </summary>
    /// <remarks>
    /// A description or definition of which activities are allowed to be done on the data.
    /// Within a `.rule` any repetitions of the `.data` element are in an OR relationship. That is to say that the data identified by the rule is all the data identified by all repetitions of `.data`. Thus to identify one rule that applies to data tagged with `STD` and data that is tagged with `HIV`, one would repeat this at the `.data` level. Within the `.data` element, all elements and all repetitions of elements, are in an AND relationship. Thus to select data that has both `STD` and `HIV` one puts both into one `.rule`. To have different rules for `STD` from `HIV`, one would need to have two `.rule` elements. To have a rule that applies to both, those that have just `STD` and just `HIV`, this repetition may also be done at the data level as described above.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("Permission.rule.data", IsBackboneType=true)]
    public partial class DataComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "Permission.rule.data";

      /// <summary>
      /// Explicit FHIR Resource references.
      /// </summary>
      [FhirElement("resource", InSummary=true, Order=40)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.Permission.ResourceComponent> Resource
      {
        get
        {
          if(_Resource.InOverflow<List<Hl7.Fhir.Model.Permission.ResourceComponent>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.Permission.ResourceComponent>), Overflow["resource"]);
          return _Resource ??= [];
        }

        set
        {
          if (_Resource.InOverflow<List<Hl7.Fhir.Model.Permission.ResourceComponent>>())
            Overflow.Remove("resource");
          _Resource = value;
          OnPropertyChanged("Resource");
        }

      }

      private List<Hl7.Fhir.Model.Permission.ResourceComponent>? _Resource;

      /// <summary>
      /// Security tag code on .meta.security.
      /// </summary>
      [FhirElement("security", InSummary=true, Order=50)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.Coding> Security
      {
        get
        {
          if(_Security.InOverflow<List<Hl7.Fhir.Model.Coding>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.Coding>), Overflow["security"]);
          return _Security ??= [];
        }

        set
        {
          if (_Security.InOverflow<List<Hl7.Fhir.Model.Coding>>())
            Overflow.Remove("security");
          _Security = value;
          OnPropertyChanged("Security");
        }

      }

      private List<Hl7.Fhir.Model.Coding>? _Security;

      /// <summary>
      /// Timeframe encompasing data create/update.
      /// </summary>
      [FhirElement("period", InSummary=true, Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.Period? Period
      {
        get
        {
          if(_Period.InOverflow<Hl7.Fhir.Model.Period>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Period), Overflow["period"]);
          return _Period;
        }

        set
        {
          if (_Period.InOverflow<Hl7.Fhir.Model.Period>())
            Overflow.Remove("period");
          _Period = value;
          OnPropertyChanged("Period");
        }

      }

      private Hl7.Fhir.Model.Period? _Period;

      /// <summary>
      /// Expression identifying the data.
      /// </summary>
      [FhirElement("expression", InSummary=true, Order=70)]
      [DataMember]
      public Hl7.Fhir.Model.Expression? Expression
      {
        get
        {
          if(_Expression.InOverflow<Hl7.Fhir.Model.Expression>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Expression), Overflow["expression"]);
          return _Expression;
        }

        set
        {
          if (_Expression.InOverflow<Hl7.Fhir.Model.Expression>())
            Overflow.Remove("expression");
          _Expression = value;
          OnPropertyChanged("Expression");
        }

      }

      private Hl7.Fhir.Model.Expression? _Expression;

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not DataComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_Resource is not null) dest.Resource = new List<Hl7.Fhir.Model.Permission.ResourceComponent>(_Resource.DeepCopyInternal());
        if(_Security is not null) dest.Security = new List<Hl7.Fhir.Model.Coding>(_Security.DeepCopyInternal());
        if(_Period is not null) dest.Period = (Hl7.Fhir.Model.Period)_Period.DeepCopyInternal();
        if(_Expression is not null) dest.Expression = (Hl7.Fhir.Model.Expression)_Expression.DeepCopyInternal();
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new DataComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not DataComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.ListEquals(_Resource, otherT._Resource)) return false;
        if(!comparer.ListEquals(_Security, otherT._Security)) return false;
        if(!comparer.Equals(_Period, otherT._Period)) return false;
        if(!comparer.Equals(_Expression, otherT._Expression)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "resource":
            if (_Resource.InOverflow<List<Hl7.Fhir.Model.Permission.ResourceComponent>>())
            {
              value = Overflow["resource"];
              return true;
            }
            value = _Resource;
            return (value as List<Hl7.Fhir.Model.Permission.ResourceComponent>)?.Any() is true;
          case "security":
            if (_Security.InOverflow<List<Hl7.Fhir.Model.Coding>>())
            {
              value = Overflow["security"];
              return true;
            }
            value = _Security;
            return (value as List<Hl7.Fhir.Model.Coding>)?.Any() is true;
          case "period":
            if (_Period.InOverflow<Hl7.Fhir.Model.Period>())
            {
              value = Overflow["period"];
              return true;
            }
            value = _Period;
            return (value as Hl7.Fhir.Model.Period) is not null;
          case "expression":
            if (_Expression.InOverflow<Hl7.Fhir.Model.Expression>())
            {
              value = Overflow["expression"];
              return true;
            }
            value = _Expression;
            return (value as Hl7.Fhir.Model.Expression) is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "resource":
            if (value is not (List<Hl7.Fhir.Model.Permission.ResourceComponent> or null))
            {
              Resource = OverflowNull<List<Hl7.Fhir.Model.Permission.ResourceComponent>>.INSTANCE;
              Overflow["resource"] = value;
            }
            else Resource = (List<Hl7.Fhir.Model.Permission.ResourceComponent>?)value!;
            return this;
          case "security":
            if (value is not (List<Hl7.Fhir.Model.Coding> or null))
            {
              Security = OverflowNull<List<Hl7.Fhir.Model.Coding>>.INSTANCE;
              Overflow["security"] = value;
            }
            else Security = (List<Hl7.Fhir.Model.Coding>?)value!;
            return this;
          case "period":
            if (value is not (Hl7.Fhir.Model.Period or null))
            {
              Period = OverflowNull<Hl7.Fhir.Model.Period>.INSTANCE;
              Overflow["period"] = value;
            }
            else Period = (Hl7.Fhir.Model.Period?)value;
            return this;
          case "expression":
            if (value is not (Hl7.Fhir.Model.Expression or null))
            {
              Expression = OverflowNull<Hl7.Fhir.Model.Expression>.INSTANCE;
              Overflow["expression"] = value;
            }
            else Expression = (Hl7.Fhir.Model.Expression?)value;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_Resource?.Any() is true && !_Resource.InOverflow<List<Hl7.Fhir.Model.Permission.ResourceComponent>>()) yield return new KeyValuePair<string,object>("resource",_Resource);
        if (_Security?.Any() is true && !_Security.InOverflow<List<Hl7.Fhir.Model.Coding>>()) yield return new KeyValuePair<string,object>("security",_Security);
        if (_Period is not null && !_Period.InOverflow<Hl7.Fhir.Model.Period>()) yield return new KeyValuePair<string,object>("period",_Period);
        if (_Expression is not null && !_Expression.InOverflow<Hl7.Fhir.Model.Expression>()) yield return new KeyValuePair<string,object>("expression",_Expression);
      }

    }

    /// <summary>
    /// Explicit FHIR Resource references
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("Permission.rule.data.resource", IsBackboneType=true)]
    public partial class ResourceComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "Permission.rule.data.resource";

      /// <summary>
      /// instance | related | dependents | authoredby.
      /// </summary>
      [FhirElement("meaning", InSummary=true, Order=40)]
      [Binding("ConsentDataMeaning")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Code<Hl7.Fhir.Model.ConsentDataMeaning>? MeaningElement
      {
        get
        {
          if(_MeaningElement.InOverflow<Code<Hl7.Fhir.Model.ConsentDataMeaning>>())
            throw CodedValidationException.FromTypes(typeof(Code<Hl7.Fhir.Model.ConsentDataMeaning>), Overflow["meaning"]);
          return _MeaningElement;
        }

        set
        {
          if (_MeaningElement.InOverflow<Code<Hl7.Fhir.Model.ConsentDataMeaning>>())
            Overflow.Remove("meaning");
          _MeaningElement = value;
          OnPropertyChanged("MeaningElement");
        }

      }

      private Code<Hl7.Fhir.Model.ConsentDataMeaning>? _MeaningElement;

      /// <summary>
      /// instance | related | dependents | authoredby
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public Hl7.Fhir.Model.ConsentDataMeaning? Meaning
      {
        get => MeaningElement?.Value;
        set
        {
          MeaningElement = value is null ? null : new Code<Hl7.Fhir.Model.ConsentDataMeaning>(value);
          OnPropertyChanged("Meaning");
        }
      }

      /// <summary>
      /// The actual data reference.
      /// </summary>
      [FhirElement("reference", InSummary=true, Order=50)]
      [CLSCompliant(false)]
      [References("Resource")]
      [Cardinality(Min=1,Max=1)]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference? Reference
      {
        get
        {
          if(_Reference.InOverflow<Hl7.Fhir.Model.ResourceReference>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.ResourceReference), Overflow["reference"]);
          return _Reference;
        }

        set
        {
          if (_Reference.InOverflow<Hl7.Fhir.Model.ResourceReference>())
            Overflow.Remove("reference");
          _Reference = value;
          OnPropertyChanged("Reference");
        }

      }

      private Hl7.Fhir.Model.ResourceReference? _Reference;

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not ResourceComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_MeaningElement is not null) dest.MeaningElement = (Code<Hl7.Fhir.Model.ConsentDataMeaning>)_MeaningElement.DeepCopyInternal();
        if(_Reference is not null) dest.Reference = (Hl7.Fhir.Model.ResourceReference)_Reference.DeepCopyInternal();
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new ResourceComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not ResourceComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_MeaningElement, otherT._MeaningElement)) return false;
        if(!comparer.Equals(_Reference, otherT._Reference)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "meaning":
            if (_MeaningElement.InOverflow<Code<Hl7.Fhir.Model.ConsentDataMeaning>>())
            {
              value = Overflow["meaning"];
              return true;
            }
            value = _MeaningElement;
            return (value as Code<Hl7.Fhir.Model.ConsentDataMeaning>) is not null;
          case "reference":
            if (_Reference.InOverflow<Hl7.Fhir.Model.ResourceReference>())
            {
              value = Overflow["reference"];
              return true;
            }
            value = _Reference;
            return (value as Hl7.Fhir.Model.ResourceReference) is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "meaning":
            if (value is not (Code<Hl7.Fhir.Model.ConsentDataMeaning> or null))
            {
              MeaningElement = OverflowNull<Code<Hl7.Fhir.Model.ConsentDataMeaning>>.INSTANCE;
              Overflow["meaning"] = value;
            }
            else MeaningElement = (Code<Hl7.Fhir.Model.ConsentDataMeaning>?)value;
            return this;
          case "reference":
            if (value is not (Hl7.Fhir.Model.ResourceReference or null))
            {
              Reference = OverflowNull<Hl7.Fhir.Model.ResourceReference>.INSTANCE;
              Overflow["reference"] = value;
            }
            else Reference = (Hl7.Fhir.Model.ResourceReference?)value;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_MeaningElement is not null && !_MeaningElement.InOverflow<Code<Hl7.Fhir.Model.ConsentDataMeaning>>()) yield return new KeyValuePair<string,object>("meaning",_MeaningElement);
        if (_Reference is not null && !_Reference.InOverflow<Hl7.Fhir.Model.ResourceReference>()) yield return new KeyValuePair<string,object>("reference",_Reference);
      }

    }

    /// <summary>
    /// A description or definition of which activities are allowed to be done on the data
    /// </summary>
    /// <remarks>
    /// Within a `.rule` any repetitions of the `.activity` element are in an OR relationship. That is to say that the rule applies to all the repetitions of `.activity`. Thus to identify one rule that applies to both `TREAT` and `HOPERAT`, one would have one rule with repetitions at the .activity level. Within the `.activity` element, all elements and all repetitions of elements, are in an AND relationship. Thus to control an actity that is covering purpose of both `TREAT` and `HOPERAT`, one rule with an `.activity` `.purpose` holding both `TREAT` and `HOPERAT` can define that rule. However this will not cover activities covering only `TREAT`, for that repeat at the `.activity` with just a `.purpose` of `TREAT`.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("Permission.rule.activity", IsBackboneType=true)]
    public partial class ActivityComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "Permission.rule.activity";

      /// <summary>
      /// Who|what is controlled by this rule.
      /// </summary>
      [FhirElement("actor", Order=40)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.Permission.ActorComponent> Actor
      {
        get
        {
          if(_Actor.InOverflow<List<Hl7.Fhir.Model.Permission.ActorComponent>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.Permission.ActorComponent>), Overflow["actor"]);
          return _Actor ??= [];
        }

        set
        {
          if (_Actor.InOverflow<List<Hl7.Fhir.Model.Permission.ActorComponent>>())
            Overflow.Remove("actor");
          _Actor = value;
          OnPropertyChanged("Actor");
        }

      }

      private List<Hl7.Fhir.Model.Permission.ActorComponent>? _Actor;

      /// <summary>
      /// Actions controlled by this rule.
      /// </summary>
      [FhirElement("action", InSummary=true, Order=50)]
      [Binding("ProcessingActivityAction")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.CodeableConcept> Action
      {
        get
        {
          if(_Action.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.CodeableConcept>), Overflow["action"]);
          return _Action ??= [];
        }

        set
        {
          if (_Action.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>())
            Overflow.Remove("action");
          _Action = value;
          OnPropertyChanged("Action");
        }

      }

      private List<Hl7.Fhir.Model.CodeableConcept>? _Action;

      /// <summary>
      /// The purpose for which the permission is given.
      /// </summary>
      [FhirElement("purpose", InSummary=true, Order=60)]
      [Binding("PurposeOfUse")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.CodeableConcept> Purpose
      {
        get
        {
          if(_Purpose.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.CodeableConcept>), Overflow["purpose"]);
          return _Purpose ??= [];
        }

        set
        {
          if (_Purpose.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>())
            Overflow.Remove("purpose");
          _Purpose = value;
          OnPropertyChanged("Purpose");
        }

      }

      private List<Hl7.Fhir.Model.CodeableConcept>? _Purpose;

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not ActivityComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_Actor is not null) dest.Actor = new List<Hl7.Fhir.Model.Permission.ActorComponent>(_Actor.DeepCopyInternal());
        if(_Action is not null) dest.Action = new List<Hl7.Fhir.Model.CodeableConcept>(_Action.DeepCopyInternal());
        if(_Purpose is not null) dest.Purpose = new List<Hl7.Fhir.Model.CodeableConcept>(_Purpose.DeepCopyInternal());
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new ActivityComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not ActivityComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.ListEquals(_Actor, otherT._Actor)) return false;
        if(!comparer.ListEquals(_Action, otherT._Action)) return false;
        if(!comparer.ListEquals(_Purpose, otherT._Purpose)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "actor":
            if (_Actor.InOverflow<List<Hl7.Fhir.Model.Permission.ActorComponent>>())
            {
              value = Overflow["actor"];
              return true;
            }
            value = _Actor;
            return (value as List<Hl7.Fhir.Model.Permission.ActorComponent>)?.Any() is true;
          case "action":
            if (_Action.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>())
            {
              value = Overflow["action"];
              return true;
            }
            value = _Action;
            return (value as List<Hl7.Fhir.Model.CodeableConcept>)?.Any() is true;
          case "purpose":
            if (_Purpose.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>())
            {
              value = Overflow["purpose"];
              return true;
            }
            value = _Purpose;
            return (value as List<Hl7.Fhir.Model.CodeableConcept>)?.Any() is true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "actor":
            if (value is not (List<Hl7.Fhir.Model.Permission.ActorComponent> or null))
            {
              Actor = OverflowNull<List<Hl7.Fhir.Model.Permission.ActorComponent>>.INSTANCE;
              Overflow["actor"] = value;
            }
            else Actor = (List<Hl7.Fhir.Model.Permission.ActorComponent>?)value!;
            return this;
          case "action":
            if (value is not (List<Hl7.Fhir.Model.CodeableConcept> or null))
            {
              Action = OverflowNull<List<Hl7.Fhir.Model.CodeableConcept>>.INSTANCE;
              Overflow["action"] = value;
            }
            else Action = (List<Hl7.Fhir.Model.CodeableConcept>?)value!;
            return this;
          case "purpose":
            if (value is not (List<Hl7.Fhir.Model.CodeableConcept> or null))
            {
              Purpose = OverflowNull<List<Hl7.Fhir.Model.CodeableConcept>>.INSTANCE;
              Overflow["purpose"] = value;
            }
            else Purpose = (List<Hl7.Fhir.Model.CodeableConcept>?)value!;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_Actor?.Any() is true && !_Actor.InOverflow<List<Hl7.Fhir.Model.Permission.ActorComponent>>()) yield return new KeyValuePair<string,object>("actor",_Actor);
        if (_Action?.Any() is true && !_Action.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>()) yield return new KeyValuePair<string,object>("action",_Action);
        if (_Purpose?.Any() is true && !_Purpose.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>()) yield return new KeyValuePair<string,object>("purpose",_Purpose);
      }

    }

    /// <summary>
    /// Who|what is controlled by this rule
    /// </summary>
    /// <remarks>
    /// Who or what is controlled by this rule. Use group to identify a set of actors by some property they share (e.g. 'admitting officers').
    /// When both reference and role are given the actor is only selected when that reference actor is functionally carrying out that role.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("Permission.rule.activity.actor", IsBackboneType=true)]
    public partial class ActorComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "Permission.rule.activity.actor";

      /// <summary>
      /// How the actor is involved.
      /// </summary>
      [FhirElement("role", Order=40)]
      [Binding("ActorRole")]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept? Role
      {
        get
        {
          if(_Role.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.CodeableConcept), Overflow["role"]);
          return _Role;
        }

        set
        {
          if (_Role.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            Overflow.Remove("role");
          _Role = value;
          OnPropertyChanged("Role");
        }

      }

      private Hl7.Fhir.Model.CodeableConcept? _Role;

      /// <summary>
      /// Authorized actor(s).
      /// </summary>
      [FhirElement("reference", InSummary=true, Order=50)]
      [CLSCompliant(false)]
      [References("Device","Group","CareTeam","Organization","Patient","Practitioner","RelatedPerson","PractitionerRole","DeviceDefinition","HealthcareService")]
      [DataMember]
      public Hl7.Fhir.Model.ResourceReference? Reference
      {
        get
        {
          if(_Reference.InOverflow<Hl7.Fhir.Model.ResourceReference>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.ResourceReference), Overflow["reference"]);
          return _Reference;
        }

        set
        {
          if (_Reference.InOverflow<Hl7.Fhir.Model.ResourceReference>())
            Overflow.Remove("reference");
          _Reference = value;
          OnPropertyChanged("Reference");
        }

      }

      private Hl7.Fhir.Model.ResourceReference? _Reference;

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not ActorComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_Role is not null) dest.Role = (Hl7.Fhir.Model.CodeableConcept)_Role.DeepCopyInternal();
        if(_Reference is not null) dest.Reference = (Hl7.Fhir.Model.ResourceReference)_Reference.DeepCopyInternal();
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new ActorComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not ActorComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_Role, otherT._Role)) return false;
        if(!comparer.Equals(_Reference, otherT._Reference)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "role":
            if (_Role.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            {
              value = Overflow["role"];
              return true;
            }
            value = _Role;
            return (value as Hl7.Fhir.Model.CodeableConcept) is not null;
          case "reference":
            if (_Reference.InOverflow<Hl7.Fhir.Model.ResourceReference>())
            {
              value = Overflow["reference"];
              return true;
            }
            value = _Reference;
            return (value as Hl7.Fhir.Model.ResourceReference) is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "role":
            if (value is not (Hl7.Fhir.Model.CodeableConcept or null))
            {
              Role = OverflowNull<Hl7.Fhir.Model.CodeableConcept>.INSTANCE;
              Overflow["role"] = value;
            }
            else Role = (Hl7.Fhir.Model.CodeableConcept?)value;
            return this;
          case "reference":
            if (value is not (Hl7.Fhir.Model.ResourceReference or null))
            {
              Reference = OverflowNull<Hl7.Fhir.Model.ResourceReference>.INSTANCE;
              Overflow["reference"] = value;
            }
            else Reference = (Hl7.Fhir.Model.ResourceReference?)value;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_Role is not null && !_Role.InOverflow<Hl7.Fhir.Model.CodeableConcept>()) yield return new KeyValuePair<string,object>("role",_Role);
        if (_Reference is not null && !_Reference.InOverflow<Hl7.Fhir.Model.ResourceReference>()) yield return new KeyValuePair<string,object>("reference",_Reference);
      }

    }

    /// <summary>
    /// What limits apply to the use of the data
    /// </summary>
    /// <remarks>
    /// What restrictions must be applied to the use of the data by the actor.
    /// Within a `.rule` all repetitions of the `.limit` all apply to the rule. That is to say if there are multiple limits, and the rule permits the activity, then all the identified limits are applied to that authorized activity.
    /// </remarks>
    [Serializable]
    [DataContract]
    [FhirType("Permission.rule.limit", IsBackboneType=true)]
    public partial class LimitComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "Permission.rule.limit";

      /// <summary>
      /// What coded limits apply to the use of the data.
      /// </summary>
      [FhirElement("control", InSummary=true, Order=40)]
      [Binding("PermissionUsageLimits")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.CodeableConcept> Control
      {
        get
        {
          if(_Control.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.CodeableConcept>), Overflow["control"]);
          return _Control ??= [];
        }

        set
        {
          if (_Control.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>())
            Overflow.Remove("control");
          _Control = value;
          OnPropertyChanged("Control");
        }

      }

      private List<Hl7.Fhir.Model.CodeableConcept>? _Control;

      /// <summary>
      /// The sensitivity codes that must be removed from the data.
      /// </summary>
      [FhirElement("tag", InSummary=true, Order=50)]
      [Binding("PermissionUsageTags")]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.Coding> Tag
      {
        get
        {
          if(_Tag.InOverflow<List<Hl7.Fhir.Model.Coding>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.Coding>), Overflow["tag"]);
          return _Tag ??= [];
        }

        set
        {
          if (_Tag.InOverflow<List<Hl7.Fhir.Model.Coding>>())
            Overflow.Remove("tag");
          _Tag = value;
          OnPropertyChanged("Tag");
        }

      }

      private List<Hl7.Fhir.Model.Coding>? _Tag;

      /// <summary>
      /// What data elements that must be removed from the data.
      /// </summary>
      [FhirElement("element", InSummary=true, Order=60)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.FhirString> ElementElement
      {
        get
        {
          if(_ElementElement.InOverflow<List<Hl7.Fhir.Model.FhirString>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.FhirString>), Overflow["element"]);
          return _ElementElement ??= [];
        }

        set
        {
          if (_ElementElement.InOverflow<List<Hl7.Fhir.Model.FhirString>>())
            Overflow.Remove("element");
          _ElementElement = value;
          OnPropertyChanged("ElementElement");
        }

      }

      private List<Hl7.Fhir.Model.FhirString>? _ElementElement;

      /// <summary>
      /// What data elements that must be removed from the data
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public IEnumerable<string?> Element
      {
        get => _ElementElement?.Select(elem => elem.Value) ?? [];
        set
        {
          if (value == null)
            ElementElement = null!;
          else
            ElementElement = new List<Hl7.Fhir.Model.FhirString>(value.Select(elem=>new Hl7.Fhir.Model.FhirString(elem)));
          OnPropertyChanged("Element");
        }
      }

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not LimitComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_Control is not null) dest.Control = new List<Hl7.Fhir.Model.CodeableConcept>(_Control.DeepCopyInternal());
        if(_Tag is not null) dest.Tag = new List<Hl7.Fhir.Model.Coding>(_Tag.DeepCopyInternal());
        if(_ElementElement is not null) dest.ElementElement = new List<Hl7.Fhir.Model.FhirString>(_ElementElement.DeepCopyInternal());
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new LimitComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not LimitComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.ListEquals(_Control, otherT._Control)) return false;
        if(!comparer.ListEquals(_Tag, otherT._Tag)) return false;
        if(!comparer.ListEquals(_ElementElement, otherT._ElementElement)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "control":
            if (_Control.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>())
            {
              value = Overflow["control"];
              return true;
            }
            value = _Control;
            return (value as List<Hl7.Fhir.Model.CodeableConcept>)?.Any() is true;
          case "tag":
            if (_Tag.InOverflow<List<Hl7.Fhir.Model.Coding>>())
            {
              value = Overflow["tag"];
              return true;
            }
            value = _Tag;
            return (value as List<Hl7.Fhir.Model.Coding>)?.Any() is true;
          case "element":
            if (_ElementElement.InOverflow<List<Hl7.Fhir.Model.FhirString>>())
            {
              value = Overflow["element"];
              return true;
            }
            value = _ElementElement;
            return (value as List<Hl7.Fhir.Model.FhirString>)?.Any() is true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "control":
            if (value is not (List<Hl7.Fhir.Model.CodeableConcept> or null))
            {
              Control = OverflowNull<List<Hl7.Fhir.Model.CodeableConcept>>.INSTANCE;
              Overflow["control"] = value;
            }
            else Control = (List<Hl7.Fhir.Model.CodeableConcept>?)value!;
            return this;
          case "tag":
            if (value is not (List<Hl7.Fhir.Model.Coding> or null))
            {
              Tag = OverflowNull<List<Hl7.Fhir.Model.Coding>>.INSTANCE;
              Overflow["tag"] = value;
            }
            else Tag = (List<Hl7.Fhir.Model.Coding>?)value!;
            return this;
          case "element":
            if (value is not (List<Hl7.Fhir.Model.FhirString> or null))
            {
              ElementElement = OverflowNull<List<Hl7.Fhir.Model.FhirString>>.INSTANCE;
              Overflow["element"] = value;
            }
            else ElementElement = (List<Hl7.Fhir.Model.FhirString>?)value!;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_Control?.Any() is true && !_Control.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>()) yield return new KeyValuePair<string,object>("control",_Control);
        if (_Tag?.Any() is true && !_Tag.InOverflow<List<Hl7.Fhir.Model.Coding>>()) yield return new KeyValuePair<string,object>("tag",_Tag);
        if (_ElementElement?.Any() is true && !_ElementElement.InOverflow<List<Hl7.Fhir.Model.FhirString>>()) yield return new KeyValuePair<string,object>("element",_ElementElement);
      }

    }

    /// <summary>
    /// Business Identifier for permission.
    /// </summary>
    [FhirElement("identifier", InSummary=true, Order=90, FiveWs="FiveWs.identifier")]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Hl7.Fhir.Model.Identifier> Identifier
    {
      get
      {
        if(_Identifier.InOverflow<List<Hl7.Fhir.Model.Identifier>>())
          throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.Identifier>), Overflow["identifier"]);
        return _Identifier ??= [];
      }

      set
      {
        if (_Identifier.InOverflow<List<Hl7.Fhir.Model.Identifier>>())
          Overflow.Remove("identifier");
        _Identifier = value;
        OnPropertyChanged("Identifier");
      }

    }

    private List<Hl7.Fhir.Model.Identifier>? _Identifier;

    /// <summary>
    /// active | entered-in-error | draft | rejected.
    /// </summary>
    [FhirElement("status", InSummary=true, Order=100)]
    [Binding("PermissionStatus")]
    [Cardinality(Min=1,Max=1)]
    [DataMember]
    public Code<Hl7.Fhir.Model.Permission.PermissionStatus>? StatusElement
    {
      get
      {
        if(_StatusElement.InOverflow<Code<Hl7.Fhir.Model.Permission.PermissionStatus>>())
          throw CodedValidationException.FromTypes(typeof(Code<Hl7.Fhir.Model.Permission.PermissionStatus>), Overflow["status"]);
        return _StatusElement;
      }

      set
      {
        if (_StatusElement.InOverflow<Code<Hl7.Fhir.Model.Permission.PermissionStatus>>())
          Overflow.Remove("status");
        _StatusElement = value;
        OnPropertyChanged("StatusElement");
      }

    }

    private Code<Hl7.Fhir.Model.Permission.PermissionStatus>? _StatusElement;

    /// <summary>
    /// active | entered-in-error | draft | rejected
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public Hl7.Fhir.Model.Permission.PermissionStatus? Status
    {
      get => StatusElement?.Value;
      set
      {
        StatusElement = value is null ? null : new Code<Hl7.Fhir.Model.Permission.PermissionStatus>(value);
        OnPropertyChanged("Status");
      }
    }

    /// <summary>
    /// The person or entity that asserts the permission.
    /// </summary>
    [FhirElement("asserter", InSummary=true, Order=110)]
    [CLSCompliant(false)]
    [References("Practitioner","PractitionerRole","Organization","CareTeam","Patient","RelatedPerson","HealthcareService")]
    [DataMember]
    public Hl7.Fhir.Model.ResourceReference? Asserter
    {
      get
      {
        if(_Asserter.InOverflow<Hl7.Fhir.Model.ResourceReference>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.ResourceReference), Overflow["asserter"]);
        return _Asserter;
      }

      set
      {
        if (_Asserter.InOverflow<Hl7.Fhir.Model.ResourceReference>())
          Overflow.Remove("asserter");
        _Asserter = value;
        OnPropertyChanged("Asserter");
      }

    }

    private Hl7.Fhir.Model.ResourceReference? _Asserter;

    /// <summary>
    /// The date that permission was asserted.
    /// </summary>
    [FhirElement("date", InSummary=true, Order=120)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Hl7.Fhir.Model.FhirDateTime> DateElement
    {
      get
      {
        if(_DateElement.InOverflow<List<Hl7.Fhir.Model.FhirDateTime>>())
          throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.FhirDateTime>), Overflow["date"]);
        return _DateElement ??= [];
      }

      set
      {
        if (_DateElement.InOverflow<List<Hl7.Fhir.Model.FhirDateTime>>())
          Overflow.Remove("date");
        _DateElement = value;
        OnPropertyChanged("DateElement");
      }

    }

    private List<Hl7.Fhir.Model.FhirDateTime>? _DateElement;

    /// <summary>
    /// The date that permission was asserted
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public IEnumerable<string?> Date
    {
      get => _DateElement?.Select(elem => elem.Value) ?? [];
      set
      {
        if (value == null)
          DateElement = null!;
        else
          DateElement = new List<Hl7.Fhir.Model.FhirDateTime>(value.Select(elem=>new Hl7.Fhir.Model.FhirDateTime(elem)));
        OnPropertyChanged("Date");
      }
    }

    /// <summary>
    /// The period in which the permission is active.
    /// </summary>
    [FhirElement("validity", InSummary=true, Order=130)]
    [DataMember]
    public Hl7.Fhir.Model.Period? Validity
    {
      get
      {
        if(_Validity.InOverflow<Hl7.Fhir.Model.Period>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Period), Overflow["validity"]);
        return _Validity;
      }

      set
      {
        if (_Validity.InOverflow<Hl7.Fhir.Model.Period>())
          Overflow.Remove("validity");
        _Validity = value;
        OnPropertyChanged("Validity");
      }

    }

    private Hl7.Fhir.Model.Period? _Validity;

    /// <summary>
    /// The asserted justification for using the data.
    /// </summary>
    [FhirElement("justification", InSummary=true, Order=140)]
    [DataMember]
    public Hl7.Fhir.Model.Permission.JustificationComponent? Justification
    {
      get
      {
        if(_Justification.InOverflow<Hl7.Fhir.Model.Permission.JustificationComponent>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Permission.JustificationComponent), Overflow["justification"]);
        return _Justification;
      }

      set
      {
        if (_Justification.InOverflow<Hl7.Fhir.Model.Permission.JustificationComponent>())
          Overflow.Remove("justification");
        _Justification = value;
        OnPropertyChanged("Justification");
      }

    }

    private Hl7.Fhir.Model.Permission.JustificationComponent? _Justification;

    /// <summary>
    /// deny-overrides | permit-overrides | ordered-deny-overrides | ordered-permit-overrides | deny-unless-permit | permit-unless-deny.
    /// </summary>
    [FhirElement("combining", InSummary=true, IsModifier=true, Order=150)]
    [Binding("PermissionCombining")]
    [Cardinality(Min=1,Max=1)]
    [DataMember]
    public Code<Hl7.Fhir.Model.Permission.PermissionRuleCombining>? CombiningElement
    {
      get
      {
        if(_CombiningElement.InOverflow<Code<Hl7.Fhir.Model.Permission.PermissionRuleCombining>>())
          throw CodedValidationException.FromTypes(typeof(Code<Hl7.Fhir.Model.Permission.PermissionRuleCombining>), Overflow["combining"]);
        return _CombiningElement;
      }

      set
      {
        if (_CombiningElement.InOverflow<Code<Hl7.Fhir.Model.Permission.PermissionRuleCombining>>())
          Overflow.Remove("combining");
        _CombiningElement = value;
        OnPropertyChanged("CombiningElement");
      }

    }

    private Code<Hl7.Fhir.Model.Permission.PermissionRuleCombining>? _CombiningElement;

    /// <summary>
    /// deny-overrides | permit-overrides | ordered-deny-overrides | ordered-permit-overrides | deny-unless-permit | permit-unless-deny
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public Hl7.Fhir.Model.Permission.PermissionRuleCombining? Combining
    {
      get => CombiningElement?.Value;
      set
      {
        CombiningElement = value is null ? null : new Code<Hl7.Fhir.Model.Permission.PermissionRuleCombining>(value);
        OnPropertyChanged("Combining");
      }
    }

    /// <summary>
    /// Constraints to the Permission.
    /// </summary>
    [FhirElement("rule", InSummary=true, Order=160)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Hl7.Fhir.Model.Permission.RuleComponent> Rule
    {
      get
      {
        if(_Rule.InOverflow<List<Hl7.Fhir.Model.Permission.RuleComponent>>())
          throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.Permission.RuleComponent>), Overflow["rule"]);
        return _Rule ??= [];
      }

      set
      {
        if (_Rule.InOverflow<List<Hl7.Fhir.Model.Permission.RuleComponent>>())
          Overflow.Remove("rule");
        _Rule = value;
        OnPropertyChanged("Rule");
      }

    }

    private List<Hl7.Fhir.Model.Permission.RuleComponent>? _Rule;

    List<Identifier> IIdentifiable<List<Identifier>>.Identifier { get => Identifier; set => Identifier = value; }

    protected internal override void CopyToInternal(Base other)
    {
      if(other is not Permission dest)
        throw new ArgumentException("Can only copy to an object of the same type", "other");

      base.CopyToInternal(dest);
      if(_Identifier is not null) dest.Identifier = new List<Hl7.Fhir.Model.Identifier>(_Identifier.DeepCopyInternal());
      if(_StatusElement is not null) dest.StatusElement = (Code<Hl7.Fhir.Model.Permission.PermissionStatus>)_StatusElement.DeepCopyInternal();
      if(_Asserter is not null) dest.Asserter = (Hl7.Fhir.Model.ResourceReference)_Asserter.DeepCopyInternal();
      if(_DateElement is not null) dest.DateElement = new List<Hl7.Fhir.Model.FhirDateTime>(_DateElement.DeepCopyInternal());
      if(_Validity is not null) dest.Validity = (Hl7.Fhir.Model.Period)_Validity.DeepCopyInternal();
      if(_Justification is not null) dest.Justification = (Hl7.Fhir.Model.Permission.JustificationComponent)_Justification.DeepCopyInternal();
      if(_CombiningElement is not null) dest.CombiningElement = (Code<Hl7.Fhir.Model.Permission.PermissionRuleCombining>)_CombiningElement.DeepCopyInternal();
      if(_Rule is not null) dest.Rule = new List<Hl7.Fhir.Model.Permission.RuleComponent>(_Rule.DeepCopyInternal());
    }

    protected internal override Base DeepCopyInternal()
    {
      var instance = new Permission();
      CopyToInternal(instance);
      return instance;
    }

    public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
    {
      if(other is not Permission otherT) return false;

      if(!base.CompareChildren(otherT, comparer)) return false;
      #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
      if(!comparer.ListEquals(_Identifier, otherT._Identifier)) return false;
      if(!comparer.Equals(_StatusElement, otherT._StatusElement)) return false;
      if(!comparer.Equals(_Asserter, otherT._Asserter)) return false;
      if(!comparer.ListEquals(_DateElement, otherT._DateElement)) return false;
      if(!comparer.Equals(_Validity, otherT._Validity)) return false;
      if(!comparer.Equals(_Justification, otherT._Justification)) return false;
      if(!comparer.Equals(_CombiningElement, otherT._CombiningElement)) return false;
      if(!comparer.ListEquals(_Rule, otherT._Rule)) return false;
      #pragma warning restore CS8604 // Possible null reference argument.

      return true;
    }

    public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
    {
      switch (key)
      {
        case "identifier":
          if (_Identifier.InOverflow<List<Hl7.Fhir.Model.Identifier>>())
          {
            value = Overflow["identifier"];
            return true;
          }
          value = _Identifier;
          return (value as List<Hl7.Fhir.Model.Identifier>)?.Any() is true;
        case "status":
          if (_StatusElement.InOverflow<Code<Hl7.Fhir.Model.Permission.PermissionStatus>>())
          {
            value = Overflow["status"];
            return true;
          }
          value = _StatusElement;
          return (value as Code<Hl7.Fhir.Model.Permission.PermissionStatus>) is not null;
        case "asserter":
          if (_Asserter.InOverflow<Hl7.Fhir.Model.ResourceReference>())
          {
            value = Overflow["asserter"];
            return true;
          }
          value = _Asserter;
          return (value as Hl7.Fhir.Model.ResourceReference) is not null;
        case "date":
          if (_DateElement.InOverflow<List<Hl7.Fhir.Model.FhirDateTime>>())
          {
            value = Overflow["date"];
            return true;
          }
          value = _DateElement;
          return (value as List<Hl7.Fhir.Model.FhirDateTime>)?.Any() is true;
        case "validity":
          if (_Validity.InOverflow<Hl7.Fhir.Model.Period>())
          {
            value = Overflow["validity"];
            return true;
          }
          value = _Validity;
          return (value as Hl7.Fhir.Model.Period) is not null;
        case "justification":
          if (_Justification.InOverflow<Hl7.Fhir.Model.Permission.JustificationComponent>())
          {
            value = Overflow["justification"];
            return true;
          }
          value = _Justification;
          return (value as Hl7.Fhir.Model.Permission.JustificationComponent) is not null;
        case "combining":
          if (_CombiningElement.InOverflow<Code<Hl7.Fhir.Model.Permission.PermissionRuleCombining>>())
          {
            value = Overflow["combining"];
            return true;
          }
          value = _CombiningElement;
          return (value as Code<Hl7.Fhir.Model.Permission.PermissionRuleCombining>) is not null;
        case "rule":
          if (_Rule.InOverflow<List<Hl7.Fhir.Model.Permission.RuleComponent>>())
          {
            value = Overflow["rule"];
            return true;
          }
          value = _Rule;
          return (value as List<Hl7.Fhir.Model.Permission.RuleComponent>)?.Any() is true;
        default:
          return base.TryGetValue(key, out value);
      }

    }

    public override Base SetValue(string key, object? value)
    {
      if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
      switch (key)
      {
        case "identifier":
          if (value is not (List<Hl7.Fhir.Model.Identifier> or null))
          {
            Identifier = OverflowNull<List<Hl7.Fhir.Model.Identifier>>.INSTANCE;
            Overflow["identifier"] = value;
          }
          else Identifier = (List<Hl7.Fhir.Model.Identifier>?)value!;
          return this;
        case "status":
          if (value is not (Code<Hl7.Fhir.Model.Permission.PermissionStatus> or null))
          {
            StatusElement = OverflowNull<Code<Hl7.Fhir.Model.Permission.PermissionStatus>>.INSTANCE;
            Overflow["status"] = value;
          }
          else StatusElement = (Code<Hl7.Fhir.Model.Permission.PermissionStatus>?)value;
          return this;
        case "asserter":
          if (value is not (Hl7.Fhir.Model.ResourceReference or null))
          {
            Asserter = OverflowNull<Hl7.Fhir.Model.ResourceReference>.INSTANCE;
            Overflow["asserter"] = value;
          }
          else Asserter = (Hl7.Fhir.Model.ResourceReference?)value;
          return this;
        case "date":
          if (value is not (List<Hl7.Fhir.Model.FhirDateTime> or null))
          {
            DateElement = OverflowNull<List<Hl7.Fhir.Model.FhirDateTime>>.INSTANCE;
            Overflow["date"] = value;
          }
          else DateElement = (List<Hl7.Fhir.Model.FhirDateTime>?)value!;
          return this;
        case "validity":
          if (value is not (Hl7.Fhir.Model.Period or null))
          {
            Validity = OverflowNull<Hl7.Fhir.Model.Period>.INSTANCE;
            Overflow["validity"] = value;
          }
          else Validity = (Hl7.Fhir.Model.Period?)value;
          return this;
        case "justification":
          if (value is not (Hl7.Fhir.Model.Permission.JustificationComponent or null))
          {
            Justification = OverflowNull<Hl7.Fhir.Model.Permission.JustificationComponent>.INSTANCE;
            Overflow["justification"] = value;
          }
          else Justification = (Hl7.Fhir.Model.Permission.JustificationComponent?)value;
          return this;
        case "combining":
          if (value is not (Code<Hl7.Fhir.Model.Permission.PermissionRuleCombining> or null))
          {
            CombiningElement = OverflowNull<Code<Hl7.Fhir.Model.Permission.PermissionRuleCombining>>.INSTANCE;
            Overflow["combining"] = value;
          }
          else CombiningElement = (Code<Hl7.Fhir.Model.Permission.PermissionRuleCombining>?)value;
          return this;
        case "rule":
          if (value is not (List<Hl7.Fhir.Model.Permission.RuleComponent> or null))
          {
            Rule = OverflowNull<List<Hl7.Fhir.Model.Permission.RuleComponent>>.INSTANCE;
            Overflow["rule"] = value;
          }
          else Rule = (List<Hl7.Fhir.Model.Permission.RuleComponent>?)value!;
          return this;
        default:
          return base.SetValue(key, value);
      }

    }

    public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
    {
      foreach (var kvp in base.EnumerateElements()) yield return kvp;
      if (_Identifier?.Any() is true && !_Identifier.InOverflow<List<Hl7.Fhir.Model.Identifier>>()) yield return new KeyValuePair<string,object>("identifier",_Identifier);
      if (_StatusElement is not null && !_StatusElement.InOverflow<Code<Hl7.Fhir.Model.Permission.PermissionStatus>>()) yield return new KeyValuePair<string,object>("status",_StatusElement);
      if (_Asserter is not null && !_Asserter.InOverflow<Hl7.Fhir.Model.ResourceReference>()) yield return new KeyValuePair<string,object>("asserter",_Asserter);
      if (_DateElement?.Any() is true && !_DateElement.InOverflow<List<Hl7.Fhir.Model.FhirDateTime>>()) yield return new KeyValuePair<string,object>("date",_DateElement);
      if (_Validity is not null && !_Validity.InOverflow<Hl7.Fhir.Model.Period>()) yield return new KeyValuePair<string,object>("validity",_Validity);
      if (_Justification is not null && !_Justification.InOverflow<Hl7.Fhir.Model.Permission.JustificationComponent>()) yield return new KeyValuePair<string,object>("justification",_Justification);
      if (_CombiningElement is not null && !_CombiningElement.InOverflow<Code<Hl7.Fhir.Model.Permission.PermissionRuleCombining>>()) yield return new KeyValuePair<string,object>("combining",_CombiningElement);
      if (_Rule?.Any() is true && !_Rule.InOverflow<List<Hl7.Fhir.Model.Permission.RuleComponent>>()) yield return new KeyValuePair<string,object>("rule",_Rule);
    }

  }

}

// end of file
