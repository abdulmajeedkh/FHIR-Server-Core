// <auto-generated/>
// Contents of: hl7.fhir.r6.expansions@6.0.0-ballot3, hl7.fhir.r6.core@6.0.0-ballot3

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using Hl7.Fhir.Introspection;
using Hl7.Fhir.Serialization;
using Hl7.Fhir.Specification;
using Hl7.Fhir.Utility;
using Hl7.Fhir.Validation;
using System.Diagnostics.CodeAnalysis;
using SystemPrimitive = Hl7.Fhir.ElementModel.Types;

#nullable enable

/*
  Copyright (c) 2011+, HL7, Inc.
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
*/

namespace Hl7.Fhir.Model
{
  /// <summary>
  /// Properties of a substance specific to it being a polymer
  /// </summary>
  [Serializable]
  [DataContract]
  [FhirType("SubstancePolymer","http://hl7.org/fhir/StructureDefinition/SubstancePolymer")]
  public partial class SubstancePolymer : Hl7.Fhir.Model.DomainResource, IIdentifiable<Identifier?>
  {
    /// <summary>
    /// FHIR Type Name
    /// </summary>
    public override string TypeName => "SubstancePolymer";

    /// <summary>
    /// Todo
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("SubstancePolymer.monomerSet", IsBackboneType=true)]
    public partial class MonomerSetComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "SubstancePolymer.monomerSet";

      /// <summary>
      /// Captures the type of ratio to the entire polymer, e.g. Monomer/Polymer ratio, SRU/Polymer Ratio.
      /// </summary>
      [FhirElement("ratioType", InSummary=true, Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept? RatioType
      {
        get
        {
          if(_RatioType.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.CodeableConcept), Overflow["ratioType"]);
          return _RatioType;
        }

        set
        {
          if (_RatioType.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            Overflow.Remove("ratioType");
          _RatioType = value;
          OnPropertyChanged("RatioType");
        }

      }

      private Hl7.Fhir.Model.CodeableConcept? _RatioType;

      /// <summary>
      /// The starting materials - monomer(s) used in the synthesis of the polymer.
      /// </summary>
      [FhirElement("startingMaterial", InSummary=true, Order=50)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.SubstancePolymer.StartingMaterialComponent> StartingMaterial
      {
        get
        {
          if(_StartingMaterial.InOverflow<List<Hl7.Fhir.Model.SubstancePolymer.StartingMaterialComponent>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.SubstancePolymer.StartingMaterialComponent>), Overflow["startingMaterial"]);
          return _StartingMaterial ??= [];
        }

        set
        {
          if (_StartingMaterial.InOverflow<List<Hl7.Fhir.Model.SubstancePolymer.StartingMaterialComponent>>())
            Overflow.Remove("startingMaterial");
          _StartingMaterial = value;
          OnPropertyChanged("StartingMaterial");
        }

      }

      private List<Hl7.Fhir.Model.SubstancePolymer.StartingMaterialComponent>? _StartingMaterial;

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not MonomerSetComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_RatioType is not null) dest.RatioType = (Hl7.Fhir.Model.CodeableConcept)_RatioType.DeepCopyInternal();
        if(_StartingMaterial is not null) dest.StartingMaterial = new List<Hl7.Fhir.Model.SubstancePolymer.StartingMaterialComponent>(_StartingMaterial.DeepCopyInternal());
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new MonomerSetComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not MonomerSetComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_RatioType, otherT._RatioType)) return false;
        if(!comparer.ListEquals(_StartingMaterial, otherT._StartingMaterial)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "ratioType":
            if (_RatioType.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            {
              value = Overflow["ratioType"];
              return true;
            }
            value = _RatioType;
            return (value as Hl7.Fhir.Model.CodeableConcept) is not null;
          case "startingMaterial":
            if (_StartingMaterial.InOverflow<List<Hl7.Fhir.Model.SubstancePolymer.StartingMaterialComponent>>())
            {
              value = Overflow["startingMaterial"];
              return true;
            }
            value = _StartingMaterial;
            return (value as List<Hl7.Fhir.Model.SubstancePolymer.StartingMaterialComponent>)?.Any() is true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "ratioType":
            if (value is not (Hl7.Fhir.Model.CodeableConcept or null))
            {
              RatioType = OverflowNull<Hl7.Fhir.Model.CodeableConcept>.INSTANCE;
              Overflow["ratioType"] = value;
            }
            else RatioType = (Hl7.Fhir.Model.CodeableConcept?)value;
            return this;
          case "startingMaterial":
            if (value is not (List<Hl7.Fhir.Model.SubstancePolymer.StartingMaterialComponent> or null))
            {
              StartingMaterial = OverflowNull<List<Hl7.Fhir.Model.SubstancePolymer.StartingMaterialComponent>>.INSTANCE;
              Overflow["startingMaterial"] = value;
            }
            else StartingMaterial = (List<Hl7.Fhir.Model.SubstancePolymer.StartingMaterialComponent>?)value!;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_RatioType is not null && !_RatioType.InOverflow<Hl7.Fhir.Model.CodeableConcept>()) yield return new KeyValuePair<string,object>("ratioType",_RatioType);
        if (_StartingMaterial?.Any() is true && !_StartingMaterial.InOverflow<List<Hl7.Fhir.Model.SubstancePolymer.StartingMaterialComponent>>()) yield return new KeyValuePair<string,object>("startingMaterial",_StartingMaterial);
      }

    }

    /// <summary>
    /// The starting materials - monomer(s) used in the synthesis of the polymer
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("SubstancePolymer.monomerSet.startingMaterial", IsBackboneType=true)]
    public partial class StartingMaterialComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "SubstancePolymer.monomerSet.startingMaterial";

      /// <summary>
      /// The type of substance for this starting material.
      /// </summary>
      [FhirElement("code", InSummary=true, Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept? Code
      {
        get
        {
          if(_Code.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.CodeableConcept), Overflow["code"]);
          return _Code;
        }

        set
        {
          if (_Code.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            Overflow.Remove("code");
          _Code = value;
          OnPropertyChanged("Code");
        }

      }

      private Hl7.Fhir.Model.CodeableConcept? _Code;

      /// <summary>
      /// Substance high level category, e.g. chemical substance.
      /// </summary>
      [FhirElement("category", InSummary=true, Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept? Category
      {
        get
        {
          if(_Category.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.CodeableConcept), Overflow["category"]);
          return _Category;
        }

        set
        {
          if (_Category.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            Overflow.Remove("category");
          _Category = value;
          OnPropertyChanged("Category");
        }

      }

      private Hl7.Fhir.Model.CodeableConcept? _Category;

      /// <summary>
      /// Used to specify whether the attribute described is a defining element for the unique identification of the polymer.
      /// </summary>
      [FhirElement("isDefining", InSummary=true, Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.FhirBoolean? IsDefiningElement
      {
        get
        {
          if(_IsDefiningElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirBoolean), Overflow["isDefining"]);
          return _IsDefiningElement;
        }

        set
        {
          if (_IsDefiningElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>())
            Overflow.Remove("isDefining");
          _IsDefiningElement = value;
          OnPropertyChanged("IsDefiningElement");
        }

      }

      private Hl7.Fhir.Model.FhirBoolean? _IsDefiningElement;

      /// <summary>
      /// Used to specify whether the attribute described is a defining element for the unique identification of the polymer
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public bool? IsDefining
      {
        get => IsDefiningElement?.Value;
        set
        {
          IsDefiningElement = value is null ? null : new Hl7.Fhir.Model.FhirBoolean(value);
          OnPropertyChanged("IsDefining");
        }
      }

      /// <summary>
      /// A percentage.
      /// </summary>
      [FhirElement("amount", InSummary=true, Order=70)]
      [DataMember]
      public Hl7.Fhir.Model.Quantity? Amount
      {
        get
        {
          if(_Amount.InOverflow<Hl7.Fhir.Model.Quantity>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Quantity), Overflow["amount"]);
          return _Amount;
        }

        set
        {
          if (_Amount.InOverflow<Hl7.Fhir.Model.Quantity>())
            Overflow.Remove("amount");
          _Amount = value;
          OnPropertyChanged("Amount");
        }

      }

      private Hl7.Fhir.Model.Quantity? _Amount;

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not StartingMaterialComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_Code is not null) dest.Code = (Hl7.Fhir.Model.CodeableConcept)_Code.DeepCopyInternal();
        if(_Category is not null) dest.Category = (Hl7.Fhir.Model.CodeableConcept)_Category.DeepCopyInternal();
        if(_IsDefiningElement is not null) dest.IsDefiningElement = (Hl7.Fhir.Model.FhirBoolean)_IsDefiningElement.DeepCopyInternal();
        if(_Amount is not null) dest.Amount = (Hl7.Fhir.Model.Quantity)_Amount.DeepCopyInternal();
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new StartingMaterialComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not StartingMaterialComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_Code, otherT._Code)) return false;
        if(!comparer.Equals(_Category, otherT._Category)) return false;
        if(!comparer.Equals(_IsDefiningElement, otherT._IsDefiningElement)) return false;
        if(!comparer.Equals(_Amount, otherT._Amount)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "code":
            if (_Code.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            {
              value = Overflow["code"];
              return true;
            }
            value = _Code;
            return (value as Hl7.Fhir.Model.CodeableConcept) is not null;
          case "category":
            if (_Category.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            {
              value = Overflow["category"];
              return true;
            }
            value = _Category;
            return (value as Hl7.Fhir.Model.CodeableConcept) is not null;
          case "isDefining":
            if (_IsDefiningElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>())
            {
              value = Overflow["isDefining"];
              return true;
            }
            value = _IsDefiningElement;
            return (value as Hl7.Fhir.Model.FhirBoolean) is not null;
          case "amount":
            if (_Amount.InOverflow<Hl7.Fhir.Model.Quantity>())
            {
              value = Overflow["amount"];
              return true;
            }
            value = _Amount;
            return (value as Hl7.Fhir.Model.Quantity) is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "code":
            if (value is not (Hl7.Fhir.Model.CodeableConcept or null))
            {
              Code = OverflowNull<Hl7.Fhir.Model.CodeableConcept>.INSTANCE;
              Overflow["code"] = value;
            }
            else Code = (Hl7.Fhir.Model.CodeableConcept?)value;
            return this;
          case "category":
            if (value is not (Hl7.Fhir.Model.CodeableConcept or null))
            {
              Category = OverflowNull<Hl7.Fhir.Model.CodeableConcept>.INSTANCE;
              Overflow["category"] = value;
            }
            else Category = (Hl7.Fhir.Model.CodeableConcept?)value;
            return this;
          case "isDefining":
            if (value is not (Hl7.Fhir.Model.FhirBoolean or null))
            {
              IsDefiningElement = OverflowNull<Hl7.Fhir.Model.FhirBoolean>.INSTANCE;
              Overflow["isDefining"] = value;
            }
            else IsDefiningElement = (Hl7.Fhir.Model.FhirBoolean?)value;
            return this;
          case "amount":
            if (value is not (Hl7.Fhir.Model.Quantity or null))
            {
              Amount = OverflowNull<Hl7.Fhir.Model.Quantity>.INSTANCE;
              Overflow["amount"] = value;
            }
            else Amount = (Hl7.Fhir.Model.Quantity?)value;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_Code is not null && !_Code.InOverflow<Hl7.Fhir.Model.CodeableConcept>()) yield return new KeyValuePair<string,object>("code",_Code);
        if (_Category is not null && !_Category.InOverflow<Hl7.Fhir.Model.CodeableConcept>()) yield return new KeyValuePair<string,object>("category",_Category);
        if (_IsDefiningElement is not null && !_IsDefiningElement.InOverflow<Hl7.Fhir.Model.FhirBoolean>()) yield return new KeyValuePair<string,object>("isDefining",_IsDefiningElement);
        if (_Amount is not null && !_Amount.InOverflow<Hl7.Fhir.Model.Quantity>()) yield return new KeyValuePair<string,object>("amount",_Amount);
      }

    }

    /// <summary>
    /// Specifies and quantifies the repeated units and their configuration
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("SubstancePolymer.repeat", IsBackboneType=true)]
    public partial class RepeatComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "SubstancePolymer.repeat";

      /// <summary>
      /// A representation of an (average) molecular formula from a polymer.
      /// </summary>
      [FhirElement("averageMolecularFormula", InSummary=true, Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString? AverageMolecularFormulaElement
      {
        get
        {
          if(_AverageMolecularFormulaElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirString), Overflow["averageMolecularFormula"]);
          return _AverageMolecularFormulaElement;
        }

        set
        {
          if (_AverageMolecularFormulaElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            Overflow.Remove("averageMolecularFormula");
          _AverageMolecularFormulaElement = value;
          OnPropertyChanged("AverageMolecularFormulaElement");
        }

      }

      private Hl7.Fhir.Model.FhirString? _AverageMolecularFormulaElement;

      /// <summary>
      /// A representation of an (average) molecular formula from a polymer
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? AverageMolecularFormula
      {
        get => AverageMolecularFormulaElement?.Value;
        set
        {
          AverageMolecularFormulaElement = value is null ? null : new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("AverageMolecularFormula");
        }
      }

      /// <summary>
      /// How the quantitative amount of Structural Repeat Units is captured (e.g. Exact, Numeric, Average).
      /// </summary>
      [FhirElement("repeatUnitAmountType", InSummary=true, Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept? RepeatUnitAmountType
      {
        get
        {
          if(_RepeatUnitAmountType.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.CodeableConcept), Overflow["repeatUnitAmountType"]);
          return _RepeatUnitAmountType;
        }

        set
        {
          if (_RepeatUnitAmountType.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            Overflow.Remove("repeatUnitAmountType");
          _RepeatUnitAmountType = value;
          OnPropertyChanged("RepeatUnitAmountType");
        }

      }

      private Hl7.Fhir.Model.CodeableConcept? _RepeatUnitAmountType;

      /// <summary>
      /// An SRU - Structural Repeat Unit.
      /// </summary>
      [FhirElement("repeatUnit", InSummary=true, Order=60)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.SubstancePolymer.RepeatUnitComponent> RepeatUnit
      {
        get
        {
          if(_RepeatUnit.InOverflow<List<Hl7.Fhir.Model.SubstancePolymer.RepeatUnitComponent>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.SubstancePolymer.RepeatUnitComponent>), Overflow["repeatUnit"]);
          return _RepeatUnit ??= [];
        }

        set
        {
          if (_RepeatUnit.InOverflow<List<Hl7.Fhir.Model.SubstancePolymer.RepeatUnitComponent>>())
            Overflow.Remove("repeatUnit");
          _RepeatUnit = value;
          OnPropertyChanged("RepeatUnit");
        }

      }

      private List<Hl7.Fhir.Model.SubstancePolymer.RepeatUnitComponent>? _RepeatUnit;

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not RepeatComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_AverageMolecularFormulaElement is not null) dest.AverageMolecularFormulaElement = (Hl7.Fhir.Model.FhirString)_AverageMolecularFormulaElement.DeepCopyInternal();
        if(_RepeatUnitAmountType is not null) dest.RepeatUnitAmountType = (Hl7.Fhir.Model.CodeableConcept)_RepeatUnitAmountType.DeepCopyInternal();
        if(_RepeatUnit is not null) dest.RepeatUnit = new List<Hl7.Fhir.Model.SubstancePolymer.RepeatUnitComponent>(_RepeatUnit.DeepCopyInternal());
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new RepeatComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not RepeatComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_AverageMolecularFormulaElement, otherT._AverageMolecularFormulaElement)) return false;
        if(!comparer.Equals(_RepeatUnitAmountType, otherT._RepeatUnitAmountType)) return false;
        if(!comparer.ListEquals(_RepeatUnit, otherT._RepeatUnit)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "averageMolecularFormula":
            if (_AverageMolecularFormulaElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            {
              value = Overflow["averageMolecularFormula"];
              return true;
            }
            value = _AverageMolecularFormulaElement;
            return (value as Hl7.Fhir.Model.FhirString) is not null;
          case "repeatUnitAmountType":
            if (_RepeatUnitAmountType.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            {
              value = Overflow["repeatUnitAmountType"];
              return true;
            }
            value = _RepeatUnitAmountType;
            return (value as Hl7.Fhir.Model.CodeableConcept) is not null;
          case "repeatUnit":
            if (_RepeatUnit.InOverflow<List<Hl7.Fhir.Model.SubstancePolymer.RepeatUnitComponent>>())
            {
              value = Overflow["repeatUnit"];
              return true;
            }
            value = _RepeatUnit;
            return (value as List<Hl7.Fhir.Model.SubstancePolymer.RepeatUnitComponent>)?.Any() is true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "averageMolecularFormula":
            if (value is not (Hl7.Fhir.Model.FhirString or null))
            {
              AverageMolecularFormulaElement = OverflowNull<Hl7.Fhir.Model.FhirString>.INSTANCE;
              Overflow["averageMolecularFormula"] = value;
            }
            else AverageMolecularFormulaElement = (Hl7.Fhir.Model.FhirString?)value;
            return this;
          case "repeatUnitAmountType":
            if (value is not (Hl7.Fhir.Model.CodeableConcept or null))
            {
              RepeatUnitAmountType = OverflowNull<Hl7.Fhir.Model.CodeableConcept>.INSTANCE;
              Overflow["repeatUnitAmountType"] = value;
            }
            else RepeatUnitAmountType = (Hl7.Fhir.Model.CodeableConcept?)value;
            return this;
          case "repeatUnit":
            if (value is not (List<Hl7.Fhir.Model.SubstancePolymer.RepeatUnitComponent> or null))
            {
              RepeatUnit = OverflowNull<List<Hl7.Fhir.Model.SubstancePolymer.RepeatUnitComponent>>.INSTANCE;
              Overflow["repeatUnit"] = value;
            }
            else RepeatUnit = (List<Hl7.Fhir.Model.SubstancePolymer.RepeatUnitComponent>?)value!;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_AverageMolecularFormulaElement is not null && !_AverageMolecularFormulaElement.InOverflow<Hl7.Fhir.Model.FhirString>()) yield return new KeyValuePair<string,object>("averageMolecularFormula",_AverageMolecularFormulaElement);
        if (_RepeatUnitAmountType is not null && !_RepeatUnitAmountType.InOverflow<Hl7.Fhir.Model.CodeableConcept>()) yield return new KeyValuePair<string,object>("repeatUnitAmountType",_RepeatUnitAmountType);
        if (_RepeatUnit?.Any() is true && !_RepeatUnit.InOverflow<List<Hl7.Fhir.Model.SubstancePolymer.RepeatUnitComponent>>()) yield return new KeyValuePair<string,object>("repeatUnit",_RepeatUnit);
      }

    }

    /// <summary>
    /// An SRU - Structural Repeat Unit
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("SubstancePolymer.repeat.repeatUnit", IsBackboneType=true)]
    public partial class RepeatUnitComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "SubstancePolymer.repeat.repeatUnit";

      /// <summary>
      /// Structural repeat units are essential elements for defining polymers.
      /// </summary>
      [FhirElement("unit", InSummary=true, Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString? UnitElement
      {
        get
        {
          if(_UnitElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirString), Overflow["unit"]);
          return _UnitElement;
        }

        set
        {
          if (_UnitElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            Overflow.Remove("unit");
          _UnitElement = value;
          OnPropertyChanged("UnitElement");
        }

      }

      private Hl7.Fhir.Model.FhirString? _UnitElement;

      /// <summary>
      /// Structural repeat units are essential elements for defining polymers
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? Unit
      {
        get => UnitElement?.Value;
        set
        {
          UnitElement = value is null ? null : new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Unit");
        }
      }

      /// <summary>
      /// The orientation of the polymerisation, e.g. head-tail, head-head, random.
      /// </summary>
      [FhirElement("orientation", InSummary=true, Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept? Orientation
      {
        get
        {
          if(_Orientation.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.CodeableConcept), Overflow["orientation"]);
          return _Orientation;
        }

        set
        {
          if (_Orientation.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            Overflow.Remove("orientation");
          _Orientation = value;
          OnPropertyChanged("Orientation");
        }

      }

      private Hl7.Fhir.Model.CodeableConcept? _Orientation;

      /// <summary>
      /// Number of repeats of this unit.
      /// </summary>
      [FhirElement("amount", InSummary=true, Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.Integer? AmountElement
      {
        get
        {
          if(_AmountElement.InOverflow<Hl7.Fhir.Model.Integer>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Integer), Overflow["amount"]);
          return _AmountElement;
        }

        set
        {
          if (_AmountElement.InOverflow<Hl7.Fhir.Model.Integer>())
            Overflow.Remove("amount");
          _AmountElement = value;
          OnPropertyChanged("AmountElement");
        }

      }

      private Hl7.Fhir.Model.Integer? _AmountElement;

      /// <summary>
      /// Number of repeats of this unit
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? Amount
      {
        get => AmountElement?.Value;
        set
        {
          AmountElement = value is null ? null : new Hl7.Fhir.Model.Integer(value);
          OnPropertyChanged("Amount");
        }
      }

      /// <summary>
      /// Applies to homopolymer and block co-polymers where the degree of polymerisation within a block can be described.
      /// </summary>
      [FhirElement("degreeOfPolymerisation", InSummary=true, Order=70)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.SubstancePolymer.DegreeOfPolymerisationComponent> DegreeOfPolymerisation
      {
        get
        {
          if(_DegreeOfPolymerisation.InOverflow<List<Hl7.Fhir.Model.SubstancePolymer.DegreeOfPolymerisationComponent>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.SubstancePolymer.DegreeOfPolymerisationComponent>), Overflow["degreeOfPolymerisation"]);
          return _DegreeOfPolymerisation ??= [];
        }

        set
        {
          if (_DegreeOfPolymerisation.InOverflow<List<Hl7.Fhir.Model.SubstancePolymer.DegreeOfPolymerisationComponent>>())
            Overflow.Remove("degreeOfPolymerisation");
          _DegreeOfPolymerisation = value;
          OnPropertyChanged("DegreeOfPolymerisation");
        }

      }

      private List<Hl7.Fhir.Model.SubstancePolymer.DegreeOfPolymerisationComponent>? _DegreeOfPolymerisation;

      /// <summary>
      /// A graphical structure for this SRU.
      /// </summary>
      [FhirElement("structuralRepresentation", InSummary=true, Order=80)]
      [Cardinality(Min=0,Max=-1)]
      [DataMember]
      [AllowNull]
      public List<Hl7.Fhir.Model.SubstancePolymer.StructuralRepresentationComponent> StructuralRepresentation
      {
        get
        {
          if(_StructuralRepresentation.InOverflow<List<Hl7.Fhir.Model.SubstancePolymer.StructuralRepresentationComponent>>())
            throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.SubstancePolymer.StructuralRepresentationComponent>), Overflow["structuralRepresentation"]);
          return _StructuralRepresentation ??= [];
        }

        set
        {
          if (_StructuralRepresentation.InOverflow<List<Hl7.Fhir.Model.SubstancePolymer.StructuralRepresentationComponent>>())
            Overflow.Remove("structuralRepresentation");
          _StructuralRepresentation = value;
          OnPropertyChanged("StructuralRepresentation");
        }

      }

      private List<Hl7.Fhir.Model.SubstancePolymer.StructuralRepresentationComponent>? _StructuralRepresentation;

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not RepeatUnitComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_UnitElement is not null) dest.UnitElement = (Hl7.Fhir.Model.FhirString)_UnitElement.DeepCopyInternal();
        if(_Orientation is not null) dest.Orientation = (Hl7.Fhir.Model.CodeableConcept)_Orientation.DeepCopyInternal();
        if(_AmountElement is not null) dest.AmountElement = (Hl7.Fhir.Model.Integer)_AmountElement.DeepCopyInternal();
        if(_DegreeOfPolymerisation is not null) dest.DegreeOfPolymerisation = new List<Hl7.Fhir.Model.SubstancePolymer.DegreeOfPolymerisationComponent>(_DegreeOfPolymerisation.DeepCopyInternal());
        if(_StructuralRepresentation is not null) dest.StructuralRepresentation = new List<Hl7.Fhir.Model.SubstancePolymer.StructuralRepresentationComponent>(_StructuralRepresentation.DeepCopyInternal());
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new RepeatUnitComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not RepeatUnitComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_UnitElement, otherT._UnitElement)) return false;
        if(!comparer.Equals(_Orientation, otherT._Orientation)) return false;
        if(!comparer.Equals(_AmountElement, otherT._AmountElement)) return false;
        if(!comparer.ListEquals(_DegreeOfPolymerisation, otherT._DegreeOfPolymerisation)) return false;
        if(!comparer.ListEquals(_StructuralRepresentation, otherT._StructuralRepresentation)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "unit":
            if (_UnitElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            {
              value = Overflow["unit"];
              return true;
            }
            value = _UnitElement;
            return (value as Hl7.Fhir.Model.FhirString) is not null;
          case "orientation":
            if (_Orientation.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            {
              value = Overflow["orientation"];
              return true;
            }
            value = _Orientation;
            return (value as Hl7.Fhir.Model.CodeableConcept) is not null;
          case "amount":
            if (_AmountElement.InOverflow<Hl7.Fhir.Model.Integer>())
            {
              value = Overflow["amount"];
              return true;
            }
            value = _AmountElement;
            return (value as Hl7.Fhir.Model.Integer) is not null;
          case "degreeOfPolymerisation":
            if (_DegreeOfPolymerisation.InOverflow<List<Hl7.Fhir.Model.SubstancePolymer.DegreeOfPolymerisationComponent>>())
            {
              value = Overflow["degreeOfPolymerisation"];
              return true;
            }
            value = _DegreeOfPolymerisation;
            return (value as List<Hl7.Fhir.Model.SubstancePolymer.DegreeOfPolymerisationComponent>)?.Any() is true;
          case "structuralRepresentation":
            if (_StructuralRepresentation.InOverflow<List<Hl7.Fhir.Model.SubstancePolymer.StructuralRepresentationComponent>>())
            {
              value = Overflow["structuralRepresentation"];
              return true;
            }
            value = _StructuralRepresentation;
            return (value as List<Hl7.Fhir.Model.SubstancePolymer.StructuralRepresentationComponent>)?.Any() is true;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "unit":
            if (value is not (Hl7.Fhir.Model.FhirString or null))
            {
              UnitElement = OverflowNull<Hl7.Fhir.Model.FhirString>.INSTANCE;
              Overflow["unit"] = value;
            }
            else UnitElement = (Hl7.Fhir.Model.FhirString?)value;
            return this;
          case "orientation":
            if (value is not (Hl7.Fhir.Model.CodeableConcept or null))
            {
              Orientation = OverflowNull<Hl7.Fhir.Model.CodeableConcept>.INSTANCE;
              Overflow["orientation"] = value;
            }
            else Orientation = (Hl7.Fhir.Model.CodeableConcept?)value;
            return this;
          case "amount":
            if (value is not (Hl7.Fhir.Model.Integer or null))
            {
              AmountElement = OverflowNull<Hl7.Fhir.Model.Integer>.INSTANCE;
              Overflow["amount"] = value;
            }
            else AmountElement = (Hl7.Fhir.Model.Integer?)value;
            return this;
          case "degreeOfPolymerisation":
            if (value is not (List<Hl7.Fhir.Model.SubstancePolymer.DegreeOfPolymerisationComponent> or null))
            {
              DegreeOfPolymerisation = OverflowNull<List<Hl7.Fhir.Model.SubstancePolymer.DegreeOfPolymerisationComponent>>.INSTANCE;
              Overflow["degreeOfPolymerisation"] = value;
            }
            else DegreeOfPolymerisation = (List<Hl7.Fhir.Model.SubstancePolymer.DegreeOfPolymerisationComponent>?)value!;
            return this;
          case "structuralRepresentation":
            if (value is not (List<Hl7.Fhir.Model.SubstancePolymer.StructuralRepresentationComponent> or null))
            {
              StructuralRepresentation = OverflowNull<List<Hl7.Fhir.Model.SubstancePolymer.StructuralRepresentationComponent>>.INSTANCE;
              Overflow["structuralRepresentation"] = value;
            }
            else StructuralRepresentation = (List<Hl7.Fhir.Model.SubstancePolymer.StructuralRepresentationComponent>?)value!;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_UnitElement is not null && !_UnitElement.InOverflow<Hl7.Fhir.Model.FhirString>()) yield return new KeyValuePair<string,object>("unit",_UnitElement);
        if (_Orientation is not null && !_Orientation.InOverflow<Hl7.Fhir.Model.CodeableConcept>()) yield return new KeyValuePair<string,object>("orientation",_Orientation);
        if (_AmountElement is not null && !_AmountElement.InOverflow<Hl7.Fhir.Model.Integer>()) yield return new KeyValuePair<string,object>("amount",_AmountElement);
        if (_DegreeOfPolymerisation?.Any() is true && !_DegreeOfPolymerisation.InOverflow<List<Hl7.Fhir.Model.SubstancePolymer.DegreeOfPolymerisationComponent>>()) yield return new KeyValuePair<string,object>("degreeOfPolymerisation",_DegreeOfPolymerisation);
        if (_StructuralRepresentation?.Any() is true && !_StructuralRepresentation.InOverflow<List<Hl7.Fhir.Model.SubstancePolymer.StructuralRepresentationComponent>>()) yield return new KeyValuePair<string,object>("structuralRepresentation",_StructuralRepresentation);
      }

    }

    /// <summary>
    /// Applies to homopolymer and block co-polymers where the degree of polymerisation within a block can be described
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("SubstancePolymer.repeat.repeatUnit.degreeOfPolymerisation", IsBackboneType=true)]
    public partial class DegreeOfPolymerisationComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "SubstancePolymer.repeat.repeatUnit.degreeOfPolymerisation";

      /// <summary>
      /// The type of the degree of polymerisation shall be described, e.g. SRU/Polymer Ratio.
      /// </summary>
      [FhirElement("type", InSummary=true, Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept? Type
      {
        get
        {
          if(_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.CodeableConcept), Overflow["type"]);
          return _Type;
        }

        set
        {
          if (_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            Overflow.Remove("type");
          _Type = value;
          OnPropertyChanged("Type");
        }

      }

      private Hl7.Fhir.Model.CodeableConcept? _Type;

      /// <summary>
      /// An average amount of polymerisation.
      /// </summary>
      [FhirElement("average", InSummary=true, Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.Integer? AverageElement
      {
        get
        {
          if(_AverageElement.InOverflow<Hl7.Fhir.Model.Integer>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Integer), Overflow["average"]);
          return _AverageElement;
        }

        set
        {
          if (_AverageElement.InOverflow<Hl7.Fhir.Model.Integer>())
            Overflow.Remove("average");
          _AverageElement = value;
          OnPropertyChanged("AverageElement");
        }

      }

      private Hl7.Fhir.Model.Integer? _AverageElement;

      /// <summary>
      /// An average amount of polymerisation
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? Average
      {
        get => AverageElement?.Value;
        set
        {
          AverageElement = value is null ? null : new Hl7.Fhir.Model.Integer(value);
          OnPropertyChanged("Average");
        }
      }

      /// <summary>
      /// A low expected limit of the amount.
      /// </summary>
      [FhirElement("low", InSummary=true, Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.Integer? LowElement
      {
        get
        {
          if(_LowElement.InOverflow<Hl7.Fhir.Model.Integer>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Integer), Overflow["low"]);
          return _LowElement;
        }

        set
        {
          if (_LowElement.InOverflow<Hl7.Fhir.Model.Integer>())
            Overflow.Remove("low");
          _LowElement = value;
          OnPropertyChanged("LowElement");
        }

      }

      private Hl7.Fhir.Model.Integer? _LowElement;

      /// <summary>
      /// A low expected limit of the amount
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? Low
      {
        get => LowElement?.Value;
        set
        {
          LowElement = value is null ? null : new Hl7.Fhir.Model.Integer(value);
          OnPropertyChanged("Low");
        }
      }

      /// <summary>
      /// A high expected limit of the amount.
      /// </summary>
      [FhirElement("high", InSummary=true, Order=70)]
      [DataMember]
      public Hl7.Fhir.Model.Integer? HighElement
      {
        get
        {
          if(_HighElement.InOverflow<Hl7.Fhir.Model.Integer>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Integer), Overflow["high"]);
          return _HighElement;
        }

        set
        {
          if (_HighElement.InOverflow<Hl7.Fhir.Model.Integer>())
            Overflow.Remove("high");
          _HighElement = value;
          OnPropertyChanged("HighElement");
        }

      }

      private Hl7.Fhir.Model.Integer? _HighElement;

      /// <summary>
      /// A high expected limit of the amount
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public int? High
      {
        get => HighElement?.Value;
        set
        {
          HighElement = value is null ? null : new Hl7.Fhir.Model.Integer(value);
          OnPropertyChanged("High");
        }
      }

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not DegreeOfPolymerisationComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_Type is not null) dest.Type = (Hl7.Fhir.Model.CodeableConcept)_Type.DeepCopyInternal();
        if(_AverageElement is not null) dest.AverageElement = (Hl7.Fhir.Model.Integer)_AverageElement.DeepCopyInternal();
        if(_LowElement is not null) dest.LowElement = (Hl7.Fhir.Model.Integer)_LowElement.DeepCopyInternal();
        if(_HighElement is not null) dest.HighElement = (Hl7.Fhir.Model.Integer)_HighElement.DeepCopyInternal();
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new DegreeOfPolymerisationComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not DegreeOfPolymerisationComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_Type, otherT._Type)) return false;
        if(!comparer.Equals(_AverageElement, otherT._AverageElement)) return false;
        if(!comparer.Equals(_LowElement, otherT._LowElement)) return false;
        if(!comparer.Equals(_HighElement, otherT._HighElement)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "type":
            if (_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            {
              value = Overflow["type"];
              return true;
            }
            value = _Type;
            return (value as Hl7.Fhir.Model.CodeableConcept) is not null;
          case "average":
            if (_AverageElement.InOverflow<Hl7.Fhir.Model.Integer>())
            {
              value = Overflow["average"];
              return true;
            }
            value = _AverageElement;
            return (value as Hl7.Fhir.Model.Integer) is not null;
          case "low":
            if (_LowElement.InOverflow<Hl7.Fhir.Model.Integer>())
            {
              value = Overflow["low"];
              return true;
            }
            value = _LowElement;
            return (value as Hl7.Fhir.Model.Integer) is not null;
          case "high":
            if (_HighElement.InOverflow<Hl7.Fhir.Model.Integer>())
            {
              value = Overflow["high"];
              return true;
            }
            value = _HighElement;
            return (value as Hl7.Fhir.Model.Integer) is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "type":
            if (value is not (Hl7.Fhir.Model.CodeableConcept or null))
            {
              Type = OverflowNull<Hl7.Fhir.Model.CodeableConcept>.INSTANCE;
              Overflow["type"] = value;
            }
            else Type = (Hl7.Fhir.Model.CodeableConcept?)value;
            return this;
          case "average":
            if (value is not (Hl7.Fhir.Model.Integer or null))
            {
              AverageElement = OverflowNull<Hl7.Fhir.Model.Integer>.INSTANCE;
              Overflow["average"] = value;
            }
            else AverageElement = (Hl7.Fhir.Model.Integer?)value;
            return this;
          case "low":
            if (value is not (Hl7.Fhir.Model.Integer or null))
            {
              LowElement = OverflowNull<Hl7.Fhir.Model.Integer>.INSTANCE;
              Overflow["low"] = value;
            }
            else LowElement = (Hl7.Fhir.Model.Integer?)value;
            return this;
          case "high":
            if (value is not (Hl7.Fhir.Model.Integer or null))
            {
              HighElement = OverflowNull<Hl7.Fhir.Model.Integer>.INSTANCE;
              Overflow["high"] = value;
            }
            else HighElement = (Hl7.Fhir.Model.Integer?)value;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_Type is not null && !_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>()) yield return new KeyValuePair<string,object>("type",_Type);
        if (_AverageElement is not null && !_AverageElement.InOverflow<Hl7.Fhir.Model.Integer>()) yield return new KeyValuePair<string,object>("average",_AverageElement);
        if (_LowElement is not null && !_LowElement.InOverflow<Hl7.Fhir.Model.Integer>()) yield return new KeyValuePair<string,object>("low",_LowElement);
        if (_HighElement is not null && !_HighElement.InOverflow<Hl7.Fhir.Model.Integer>()) yield return new KeyValuePair<string,object>("high",_HighElement);
      }

    }

    /// <summary>
    /// A graphical structure for this SRU
    /// </summary>
    [Serializable]
    [DataContract]
    [FhirType("SubstancePolymer.repeat.repeatUnit.structuralRepresentation", IsBackboneType=true)]
    public partial class StructuralRepresentationComponent : Hl7.Fhir.Model.BackboneElement
    {
      /// <summary>
      /// FHIR Type Name
      /// </summary>
      public override string TypeName => "SubstancePolymer.repeat.repeatUnit.structuralRepresentation";

      /// <summary>
      /// The type of structure (e.g. Full, Partial, Representative).
      /// </summary>
      [FhirElement("type", InSummary=true, Order=40)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept? Type
      {
        get
        {
          if(_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.CodeableConcept), Overflow["type"]);
          return _Type;
        }

        set
        {
          if (_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            Overflow.Remove("type");
          _Type = value;
          OnPropertyChanged("Type");
        }

      }

      private Hl7.Fhir.Model.CodeableConcept? _Type;

      /// <summary>
      /// The structural representation as text string in a standard format e.g. InChI, SMILES, MOLFILE, CDX, SDF, PDB, mmCIF.
      /// </summary>
      [FhirElement("representation", InSummary=true, Order=50)]
      [DataMember]
      public Hl7.Fhir.Model.FhirString? RepresentationElement
      {
        get
        {
          if(_RepresentationElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirString), Overflow["representation"]);
          return _RepresentationElement;
        }

        set
        {
          if (_RepresentationElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            Overflow.Remove("representation");
          _RepresentationElement = value;
          OnPropertyChanged("RepresentationElement");
        }

      }

      private Hl7.Fhir.Model.FhirString? _RepresentationElement;

      /// <summary>
      /// The structural representation as text string in a standard format e.g. InChI, SMILES, MOLFILE, CDX, SDF, PDB, mmCIF
      /// </summary>
      /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
      [IgnoreDataMember]
      public string? Representation
      {
        get => RepresentationElement?.Value;
        set
        {
          RepresentationElement = value is null ? null : new Hl7.Fhir.Model.FhirString(value);
          OnPropertyChanged("Representation");
        }
      }

      /// <summary>
      /// The format of the representation e.g. InChI, SMILES, MOLFILE, CDX, SDF, PDB, mmCIF.
      /// </summary>
      [FhirElement("format", InSummary=true, Order=60)]
      [DataMember]
      public Hl7.Fhir.Model.CodeableConcept? Format
      {
        get
        {
          if(_Format.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.CodeableConcept), Overflow["format"]);
          return _Format;
        }

        set
        {
          if (_Format.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            Overflow.Remove("format");
          _Format = value;
          OnPropertyChanged("Format");
        }

      }

      private Hl7.Fhir.Model.CodeableConcept? _Format;

      /// <summary>
      /// An attached file with the structural representation.
      /// </summary>
      [FhirElement("attachment", InSummary=true, Order=70)]
      [DataMember]
      public Hl7.Fhir.Model.Attachment? Attachment
      {
        get
        {
          if(_Attachment.InOverflow<Hl7.Fhir.Model.Attachment>())
            throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Attachment), Overflow["attachment"]);
          return _Attachment;
        }

        set
        {
          if (_Attachment.InOverflow<Hl7.Fhir.Model.Attachment>())
            Overflow.Remove("attachment");
          _Attachment = value;
          OnPropertyChanged("Attachment");
        }

      }

      private Hl7.Fhir.Model.Attachment? _Attachment;

      protected internal override void CopyToInternal(Base other)
      {
        if(other is not StructuralRepresentationComponent dest)
          throw new ArgumentException("Can only copy to an object of the same type", "other");

        base.CopyToInternal(dest);
        if(_Type is not null) dest.Type = (Hl7.Fhir.Model.CodeableConcept)_Type.DeepCopyInternal();
        if(_RepresentationElement is not null) dest.RepresentationElement = (Hl7.Fhir.Model.FhirString)_RepresentationElement.DeepCopyInternal();
        if(_Format is not null) dest.Format = (Hl7.Fhir.Model.CodeableConcept)_Format.DeepCopyInternal();
        if(_Attachment is not null) dest.Attachment = (Hl7.Fhir.Model.Attachment)_Attachment.DeepCopyInternal();
      }

      protected internal override Base DeepCopyInternal()
      {
        var instance = new StructuralRepresentationComponent();
        CopyToInternal(instance);
        return instance;
      }

      public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
      {
        if(other is not StructuralRepresentationComponent otherT) return false;

        if(!base.CompareChildren(otherT, comparer)) return false;
        #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
        if(!comparer.Equals(_Type, otherT._Type)) return false;
        if(!comparer.Equals(_RepresentationElement, otherT._RepresentationElement)) return false;
        if(!comparer.Equals(_Format, otherT._Format)) return false;
        if(!comparer.Equals(_Attachment, otherT._Attachment)) return false;
        #pragma warning restore CS8604 // Possible null reference argument.

        return true;
      }

      public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
      {
        switch (key)
        {
          case "type":
            if (_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            {
              value = Overflow["type"];
              return true;
            }
            value = _Type;
            return (value as Hl7.Fhir.Model.CodeableConcept) is not null;
          case "representation":
            if (_RepresentationElement.InOverflow<Hl7.Fhir.Model.FhirString>())
            {
              value = Overflow["representation"];
              return true;
            }
            value = _RepresentationElement;
            return (value as Hl7.Fhir.Model.FhirString) is not null;
          case "format":
            if (_Format.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
            {
              value = Overflow["format"];
              return true;
            }
            value = _Format;
            return (value as Hl7.Fhir.Model.CodeableConcept) is not null;
          case "attachment":
            if (_Attachment.InOverflow<Hl7.Fhir.Model.Attachment>())
            {
              value = Overflow["attachment"];
              return true;
            }
            value = _Attachment;
            return (value as Hl7.Fhir.Model.Attachment) is not null;
          default:
            return base.TryGetValue(key, out value);
        }

      }

      public override Base SetValue(string key, object? value)
      {
        if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
        switch (key)
        {
          case "type":
            if (value is not (Hl7.Fhir.Model.CodeableConcept or null))
            {
              Type = OverflowNull<Hl7.Fhir.Model.CodeableConcept>.INSTANCE;
              Overflow["type"] = value;
            }
            else Type = (Hl7.Fhir.Model.CodeableConcept?)value;
            return this;
          case "representation":
            if (value is not (Hl7.Fhir.Model.FhirString or null))
            {
              RepresentationElement = OverflowNull<Hl7.Fhir.Model.FhirString>.INSTANCE;
              Overflow["representation"] = value;
            }
            else RepresentationElement = (Hl7.Fhir.Model.FhirString?)value;
            return this;
          case "format":
            if (value is not (Hl7.Fhir.Model.CodeableConcept or null))
            {
              Format = OverflowNull<Hl7.Fhir.Model.CodeableConcept>.INSTANCE;
              Overflow["format"] = value;
            }
            else Format = (Hl7.Fhir.Model.CodeableConcept?)value;
            return this;
          case "attachment":
            if (value is not (Hl7.Fhir.Model.Attachment or null))
            {
              Attachment = OverflowNull<Hl7.Fhir.Model.Attachment>.INSTANCE;
              Overflow["attachment"] = value;
            }
            else Attachment = (Hl7.Fhir.Model.Attachment?)value;
            return this;
          default:
            return base.SetValue(key, value);
        }

      }

      public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
      {
        foreach (var kvp in base.EnumerateElements()) yield return kvp;
        if (_Type is not null && !_Type.InOverflow<Hl7.Fhir.Model.CodeableConcept>()) yield return new KeyValuePair<string,object>("type",_Type);
        if (_RepresentationElement is not null && !_RepresentationElement.InOverflow<Hl7.Fhir.Model.FhirString>()) yield return new KeyValuePair<string,object>("representation",_RepresentationElement);
        if (_Format is not null && !_Format.InOverflow<Hl7.Fhir.Model.CodeableConcept>()) yield return new KeyValuePair<string,object>("format",_Format);
        if (_Attachment is not null && !_Attachment.InOverflow<Hl7.Fhir.Model.Attachment>()) yield return new KeyValuePair<string,object>("attachment",_Attachment);
      }

    }

    /// <summary>
    /// A business idenfier for this polymer, but typically this is handled by a SubstanceDefinition identifier.
    /// </summary>
    [FhirElement("identifier", InSummary=true, Order=90)]
    [DataMember]
    public Hl7.Fhir.Model.Identifier? Identifier
    {
      get
      {
        if(_Identifier.InOverflow<Hl7.Fhir.Model.Identifier>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.Identifier), Overflow["identifier"]);
        return _Identifier;
      }

      set
      {
        if (_Identifier.InOverflow<Hl7.Fhir.Model.Identifier>())
          Overflow.Remove("identifier");
        _Identifier = value;
        OnPropertyChanged("Identifier");
      }

    }

    private Hl7.Fhir.Model.Identifier? _Identifier;

    /// <summary>
    /// Overall type of the polymer.
    /// </summary>
    [FhirElement("class", InSummary=true, Order=100)]
    [DataMember]
    public Hl7.Fhir.Model.CodeableConcept? Class
    {
      get
      {
        if(_Class.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.CodeableConcept), Overflow["class"]);
        return _Class;
      }

      set
      {
        if (_Class.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
          Overflow.Remove("class");
        _Class = value;
        OnPropertyChanged("Class");
      }

    }

    private Hl7.Fhir.Model.CodeableConcept? _Class;

    /// <summary>
    /// Polymer geometry, e.g. linear, branched, cross-linked, network or dendritic.
    /// </summary>
    [FhirElement("geometry", InSummary=true, Order=110)]
    [DataMember]
    public Hl7.Fhir.Model.CodeableConcept? Geometry
    {
      get
      {
        if(_Geometry.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.CodeableConcept), Overflow["geometry"]);
        return _Geometry;
      }

      set
      {
        if (_Geometry.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
          Overflow.Remove("geometry");
        _Geometry = value;
        OnPropertyChanged("Geometry");
      }

    }

    private Hl7.Fhir.Model.CodeableConcept? _Geometry;

    /// <summary>
    /// Descrtibes the copolymer sequence type (polymer connectivity).
    /// </summary>
    [FhirElement("copolymerConnectivity", InSummary=true, Order=120)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Hl7.Fhir.Model.CodeableConcept> CopolymerConnectivity
    {
      get
      {
        if(_CopolymerConnectivity.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>())
          throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.CodeableConcept>), Overflow["copolymerConnectivity"]);
        return _CopolymerConnectivity ??= [];
      }

      set
      {
        if (_CopolymerConnectivity.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>())
          Overflow.Remove("copolymerConnectivity");
        _CopolymerConnectivity = value;
        OnPropertyChanged("CopolymerConnectivity");
      }

    }

    private List<Hl7.Fhir.Model.CodeableConcept>? _CopolymerConnectivity;

    /// <summary>
    /// Todo - this is intended to connect to a repeating full modification structure, also used by Protein and Nucleic Acid . String is just a placeholder.
    /// </summary>
    [FhirElement("modification", InSummary=true, Order=130)]
    [DataMember]
    public Hl7.Fhir.Model.FhirString? ModificationElement
    {
      get
      {
        if(_ModificationElement.InOverflow<Hl7.Fhir.Model.FhirString>())
          throw CodedValidationException.FromTypes(typeof(Hl7.Fhir.Model.FhirString), Overflow["modification"]);
        return _ModificationElement;
      }

      set
      {
        if (_ModificationElement.InOverflow<Hl7.Fhir.Model.FhirString>())
          Overflow.Remove("modification");
        _ModificationElement = value;
        OnPropertyChanged("ModificationElement");
      }

    }

    private Hl7.Fhir.Model.FhirString? _ModificationElement;

    /// <summary>
    /// Todo - this is intended to connect to a repeating full modification structure, also used by Protein and Nucleic Acid . String is just a placeholder
    /// </summary>
    /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
    [IgnoreDataMember]
    public string? Modification
    {
      get => ModificationElement?.Value;
      set
      {
        ModificationElement = value is null ? null : new Hl7.Fhir.Model.FhirString(value);
        OnPropertyChanged("Modification");
      }
    }

    /// <summary>
    /// Todo.
    /// </summary>
    [FhirElement("monomerSet", InSummary=true, Order=140)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Hl7.Fhir.Model.SubstancePolymer.MonomerSetComponent> MonomerSet
    {
      get
      {
        if(_MonomerSet.InOverflow<List<Hl7.Fhir.Model.SubstancePolymer.MonomerSetComponent>>())
          throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.SubstancePolymer.MonomerSetComponent>), Overflow["monomerSet"]);
        return _MonomerSet ??= [];
      }

      set
      {
        if (_MonomerSet.InOverflow<List<Hl7.Fhir.Model.SubstancePolymer.MonomerSetComponent>>())
          Overflow.Remove("monomerSet");
        _MonomerSet = value;
        OnPropertyChanged("MonomerSet");
      }

    }

    private List<Hl7.Fhir.Model.SubstancePolymer.MonomerSetComponent>? _MonomerSet;

    /// <summary>
    /// Specifies and quantifies the repeated units and their configuration.
    /// </summary>
    [FhirElement("repeat", InSummary=true, Order=150)]
    [Cardinality(Min=0,Max=-1)]
    [DataMember]
    [AllowNull]
    public List<Hl7.Fhir.Model.SubstancePolymer.RepeatComponent> Repeat
    {
      get
      {
        if(_Repeat.InOverflow<List<Hl7.Fhir.Model.SubstancePolymer.RepeatComponent>>())
          throw CodedValidationException.FromTypes(typeof(List<Hl7.Fhir.Model.SubstancePolymer.RepeatComponent>), Overflow["repeat"]);
        return _Repeat ??= [];
      }

      set
      {
        if (_Repeat.InOverflow<List<Hl7.Fhir.Model.SubstancePolymer.RepeatComponent>>())
          Overflow.Remove("repeat");
        _Repeat = value;
        OnPropertyChanged("Repeat");
      }

    }

    private List<Hl7.Fhir.Model.SubstancePolymer.RepeatComponent>? _Repeat;

    Identifier? IIdentifiable<Identifier?>.Identifier { get => Identifier; set => Identifier = value; }

    protected internal override void CopyToInternal(Base other)
    {
      if(other is not SubstancePolymer dest)
        throw new ArgumentException("Can only copy to an object of the same type", "other");

      base.CopyToInternal(dest);
      if(_Identifier is not null) dest.Identifier = (Hl7.Fhir.Model.Identifier)_Identifier.DeepCopyInternal();
      if(_Class is not null) dest.Class = (Hl7.Fhir.Model.CodeableConcept)_Class.DeepCopyInternal();
      if(_Geometry is not null) dest.Geometry = (Hl7.Fhir.Model.CodeableConcept)_Geometry.DeepCopyInternal();
      if(_CopolymerConnectivity is not null) dest.CopolymerConnectivity = new List<Hl7.Fhir.Model.CodeableConcept>(_CopolymerConnectivity.DeepCopyInternal());
      if(_ModificationElement is not null) dest.ModificationElement = (Hl7.Fhir.Model.FhirString)_ModificationElement.DeepCopyInternal();
      if(_MonomerSet is not null) dest.MonomerSet = new List<Hl7.Fhir.Model.SubstancePolymer.MonomerSetComponent>(_MonomerSet.DeepCopyInternal());
      if(_Repeat is not null) dest.Repeat = new List<Hl7.Fhir.Model.SubstancePolymer.RepeatComponent>(_Repeat.DeepCopyInternal());
    }

    protected internal override Base DeepCopyInternal()
    {
      var instance = new SubstancePolymer();
      CopyToInternal(instance);
      return instance;
    }

    public override bool CompareChildren(Base other, IEqualityComparer<Base> comparer)
    {
      if(other is not SubstancePolymer otherT) return false;

      if(!base.CompareChildren(otherT, comparer)) return false;
      #pragma warning disable CS8604 // Possible null reference argument - netstd2.1 has a wrong nullable signature here
      if(!comparer.Equals(_Identifier, otherT._Identifier)) return false;
      if(!comparer.Equals(_Class, otherT._Class)) return false;
      if(!comparer.Equals(_Geometry, otherT._Geometry)) return false;
      if(!comparer.ListEquals(_CopolymerConnectivity, otherT._CopolymerConnectivity)) return false;
      if(!comparer.Equals(_ModificationElement, otherT._ModificationElement)) return false;
      if(!comparer.ListEquals(_MonomerSet, otherT._MonomerSet)) return false;
      if(!comparer.ListEquals(_Repeat, otherT._Repeat)) return false;
      #pragma warning restore CS8604 // Possible null reference argument.

      return true;
    }

    public override bool TryGetValue(string key, [NotNullWhen(true)] out object? value)
    {
      switch (key)
      {
        case "identifier":
          if (_Identifier.InOverflow<Hl7.Fhir.Model.Identifier>())
          {
            value = Overflow["identifier"];
            return true;
          }
          value = _Identifier;
          return (value as Hl7.Fhir.Model.Identifier) is not null;
        case "class":
          if (_Class.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
          {
            value = Overflow["class"];
            return true;
          }
          value = _Class;
          return (value as Hl7.Fhir.Model.CodeableConcept) is not null;
        case "geometry":
          if (_Geometry.InOverflow<Hl7.Fhir.Model.CodeableConcept>())
          {
            value = Overflow["geometry"];
            return true;
          }
          value = _Geometry;
          return (value as Hl7.Fhir.Model.CodeableConcept) is not null;
        case "copolymerConnectivity":
          if (_CopolymerConnectivity.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>())
          {
            value = Overflow["copolymerConnectivity"];
            return true;
          }
          value = _CopolymerConnectivity;
          return (value as List<Hl7.Fhir.Model.CodeableConcept>)?.Any() is true;
        case "modification":
          if (_ModificationElement.InOverflow<Hl7.Fhir.Model.FhirString>())
          {
            value = Overflow["modification"];
            return true;
          }
          value = _ModificationElement;
          return (value as Hl7.Fhir.Model.FhirString) is not null;
        case "monomerSet":
          if (_MonomerSet.InOverflow<List<Hl7.Fhir.Model.SubstancePolymer.MonomerSetComponent>>())
          {
            value = Overflow["monomerSet"];
            return true;
          }
          value = _MonomerSet;
          return (value as List<Hl7.Fhir.Model.SubstancePolymer.MonomerSetComponent>)?.Any() is true;
        case "repeat":
          if (_Repeat.InOverflow<List<Hl7.Fhir.Model.SubstancePolymer.RepeatComponent>>())
          {
            value = Overflow["repeat"];
            return true;
          }
          value = _Repeat;
          return (value as List<Hl7.Fhir.Model.SubstancePolymer.RepeatComponent>)?.Any() is true;
        default:
          return base.TryGetValue(key, out value);
      }

    }

    public override Base SetValue(string key, object? value)
    {
      if(value is not (null or Hl7.Fhir.Model.Base or IList)) throw new ArgumentException("Value must be a Base or a list of Base", nameof(value));
      switch (key)
      {
        case "identifier":
          if (value is not (Hl7.Fhir.Model.Identifier or null))
          {
            Identifier = OverflowNull<Hl7.Fhir.Model.Identifier>.INSTANCE;
            Overflow["identifier"] = value;
          }
          else Identifier = (Hl7.Fhir.Model.Identifier?)value;
          return this;
        case "class":
          if (value is not (Hl7.Fhir.Model.CodeableConcept or null))
          {
            Class = OverflowNull<Hl7.Fhir.Model.CodeableConcept>.INSTANCE;
            Overflow["class"] = value;
          }
          else Class = (Hl7.Fhir.Model.CodeableConcept?)value;
          return this;
        case "geometry":
          if (value is not (Hl7.Fhir.Model.CodeableConcept or null))
          {
            Geometry = OverflowNull<Hl7.Fhir.Model.CodeableConcept>.INSTANCE;
            Overflow["geometry"] = value;
          }
          else Geometry = (Hl7.Fhir.Model.CodeableConcept?)value;
          return this;
        case "copolymerConnectivity":
          if (value is not (List<Hl7.Fhir.Model.CodeableConcept> or null))
          {
            CopolymerConnectivity = OverflowNull<List<Hl7.Fhir.Model.CodeableConcept>>.INSTANCE;
            Overflow["copolymerConnectivity"] = value;
          }
          else CopolymerConnectivity = (List<Hl7.Fhir.Model.CodeableConcept>?)value!;
          return this;
        case "modification":
          if (value is not (Hl7.Fhir.Model.FhirString or null))
          {
            ModificationElement = OverflowNull<Hl7.Fhir.Model.FhirString>.INSTANCE;
            Overflow["modification"] = value;
          }
          else ModificationElement = (Hl7.Fhir.Model.FhirString?)value;
          return this;
        case "monomerSet":
          if (value is not (List<Hl7.Fhir.Model.SubstancePolymer.MonomerSetComponent> or null))
          {
            MonomerSet = OverflowNull<List<Hl7.Fhir.Model.SubstancePolymer.MonomerSetComponent>>.INSTANCE;
            Overflow["monomerSet"] = value;
          }
          else MonomerSet = (List<Hl7.Fhir.Model.SubstancePolymer.MonomerSetComponent>?)value!;
          return this;
        case "repeat":
          if (value is not (List<Hl7.Fhir.Model.SubstancePolymer.RepeatComponent> or null))
          {
            Repeat = OverflowNull<List<Hl7.Fhir.Model.SubstancePolymer.RepeatComponent>>.INSTANCE;
            Overflow["repeat"] = value;
          }
          else Repeat = (List<Hl7.Fhir.Model.SubstancePolymer.RepeatComponent>?)value!;
          return this;
        default:
          return base.SetValue(key, value);
      }

    }

    public override IEnumerable<KeyValuePair<string, object>> EnumerateElements()
    {
      foreach (var kvp in base.EnumerateElements()) yield return kvp;
      if (_Identifier is not null && !_Identifier.InOverflow<Hl7.Fhir.Model.Identifier>()) yield return new KeyValuePair<string,object>("identifier",_Identifier);
      if (_Class is not null && !_Class.InOverflow<Hl7.Fhir.Model.CodeableConcept>()) yield return new KeyValuePair<string,object>("class",_Class);
      if (_Geometry is not null && !_Geometry.InOverflow<Hl7.Fhir.Model.CodeableConcept>()) yield return new KeyValuePair<string,object>("geometry",_Geometry);
      if (_CopolymerConnectivity?.Any() is true && !_CopolymerConnectivity.InOverflow<List<Hl7.Fhir.Model.CodeableConcept>>()) yield return new KeyValuePair<string,object>("copolymerConnectivity",_CopolymerConnectivity);
      if (_ModificationElement is not null && !_ModificationElement.InOverflow<Hl7.Fhir.Model.FhirString>()) yield return new KeyValuePair<string,object>("modification",_ModificationElement);
      if (_MonomerSet?.Any() is true && !_MonomerSet.InOverflow<List<Hl7.Fhir.Model.SubstancePolymer.MonomerSetComponent>>()) yield return new KeyValuePair<string,object>("monomerSet",_MonomerSet);
      if (_Repeat?.Any() is true && !_Repeat.InOverflow<List<Hl7.Fhir.Model.SubstancePolymer.RepeatComponent>>()) yield return new KeyValuePair<string,object>("repeat",_Repeat);
    }

  }

}

// end of file
